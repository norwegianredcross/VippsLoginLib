'use client';
import { jsxs, jsx } from 'react/jsx-runtime';
import { forwardRef, createContext, useState, useId, useRef, useEffect, useCallback } from 'react';
import '@u-elements/u-tags';
import { useMergeRefs } from '@floating-ui/react';
import { getDatalistValue, syncDatalistState } from '@u-elements/u-datalist';
import cl from 'clsx/lite';

const MultiSuggestionContext = createContext({});
const MultiSuggestion = forwardRef(function MultiSuggestion({ value, defaultValue, onValueChange, name, filter = true, allowCreate = false, className, ...rest }, ref) {
    const [listId, setListId] = useState(useId());
    const [selectedItems, setSelectedItems] = useState({});
    const inputRef = useRef(null);
    const uTagsRef = useRef(null);
    const mergedRefs = useMergeRefs([ref, uTagsRef]);
    const isControlled = Boolean(value);
    const [controlledDirty, setControlledDirty] = useState(false);
    /**
     * If we have set a default value, set it on initial render
     */
    useEffect(() => {
        if (!defaultValue)
            return;
        if (value) {
            console.warn('defaultValue can not be used in combination with value');
            return;
        }
        const items = uTagsRef.current?.querySelectorAll('u-option');
        if (!items)
            return;
        const defaultItems = Array.from(items).filter((item) => defaultValue.includes(item.value));
        for (const item of defaultItems) {
            uTagsRef.current?.dispatchEvent(new CustomEvent('add', {
                detail: { item },
            }));
            setSelectedItems((prevItems) => ({
                ...prevItems,
                [item.value]: item,
            }));
        }
        return () => {
            console.error('Default value changed during render');
        };
    }, [defaultValue]);
    /**
     * Controlled state management
     */
    useEffect(() => {
        if (!value)
            return;
        const items = inputRef.current?.list?.options;
        if (!items)
            return;
        const itemsArray = Array.from(items);
        const itemsArrayValues = itemsArray.map((item) => item.value);
        const selectedArray = Object.keys(selectedItems);
        const validValues = value.filter((val) => itemsArrayValues.includes(val));
        const itemsToAdd = validValues.filter((val) => !selectedArray.includes(val));
        const itemsToRemove = selectedArray.filter((val) => !validValues.includes(val));
        for (const item of itemsArray) {
            if (itemsToAdd.includes(item.value)) {
                uTagsRef.current?.dispatchEvent(new CustomEvent('add', {
                    detail: { item },
                }));
                setSelectedItems((prevItems) => ({
                    ...prevItems,
                    [item.value]: item,
                }));
            }
            if (itemsToRemove.includes(item.value)) {
                uTagsRef.current?.dispatchEvent(new CustomEvent('remove', {
                    detail: { item },
                }));
                setSelectedItems((prevItems) => {
                    const { [item.value]: _, ...rest } = prevItems;
                    return rest;
                });
            }
        }
    }, [value]);
    /**
     * Listerners and handling of adding/removing
     */
    useEffect(() => {
        if (!uTagsRef?.current)
            return;
        const handleItemsChange = (e) => {
            e.preventDefault();
            const item = e.detail.item;
            if (e.detail.action === 'add') {
                /**
                 * If creating is off, check if the value is allowed to be added
                 */
                if (!allowCreate) {
                    const optionExists = Array.from(inputRef.current?.list?.options || [], getDatalistValue).includes(item.value);
                    if (!optionExists)
                        return;
                }
                setSelectedItems((prevItems) => ({
                    ...prevItems,
                    [item.value]: item,
                }));
            }
            if (e.detail.action === 'remove') {
                setSelectedItems((prevItems) => {
                    const { [item.value]: _, ...rest } = prevItems;
                    return rest;
                });
            }
            if (isControlled)
                setControlledDirty(true);
        };
        uTagsRef.current.addEventListener('tags', handleItemsChange);
        return () => {
            uTagsRef.current?.removeEventListener('tags', handleItemsChange);
        };
    }, [uTagsRef, setSelectedItems]);
    /**
     * When controlled, trigger onValueChange callback for ordinary add/remove
     */
    useEffect(() => {
        if (!controlledDirty)
            return;
        onValueChange?.(Object.keys(selectedItems));
        setControlledDirty(false);
    }, [controlledDirty]);
    const handleFilter = useCallback((input) => {
        const list = input?.list;
        // Let <datalist> handle filtering if filter is true
        if (filter === true || !list)
            return;
        // Handle custom filter
        if (filter !== false) {
            let index = 0;
            for (const option of list.getElementsByTagName('u-option')) {
                if (!option.hasAttribute('data-empty'))
                    option.disabled = !filter({
                        index: index++, // Increment index for each <option>
                        input,
                        optionElement: option,
                        text: option.text,
                        value: getDatalistValue(option),
                    });
            }
        }
        syncDatalistState(input); // Sync the datalist state if filter is custom or false
    }, [filter]);
    return (jsxs(MultiSuggestionContext.Provider, { value: {
            inputRef,
            listId,
            selectedItems,
            setListId,
            handleFilter,
        }, children: [jsx("u-tags", { class: cl('ds-multi-suggestion', className), ref: mergedRefs, ...rest }), name && (jsx("select", { multiple: true, hidden: true, name: name, children: Object.values(selectedItems).map((item) => (jsx("option", { value: item.value }, item.value))) }))] }));
});

export { MultiSuggestion, MultiSuggestionContext };
