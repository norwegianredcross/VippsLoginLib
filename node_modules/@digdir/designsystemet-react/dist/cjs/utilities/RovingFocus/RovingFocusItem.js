'use client';
'use strict';

var jsxRuntime = require('react/jsx-runtime');
var react$1 = require('@floating-ui/react');
var reactSlot = require('@radix-ui/react-slot');
var react = require('react');
var useRovingFocus = require('./useRovingFocus.js');

/** Get the next focusable RovingFocusItem */
function getNextFocusableValue(items, value) {
    const currIndex = items.findIndex((item) => item.value === value);
    return items.at(currIndex === items.length - 1 ? 0 : currIndex + 1);
}
/** Get the previous focusable RovingFocusItem */
function getPrevFocusableValue(items, value) {
    const currIndex = items.findIndex((item) => item.value === value);
    return items.at(currIndex === 0 ? -1 : currIndex - 1);
}
const RovingFocusItem = react.forwardRef(({ value, asChild, ...rest }, ref) => {
    const Component = asChild ? reactSlot.Slot : 'div';
    const focusValue = value ?? (typeof rest.children === 'string' ? rest.children : '');
    const { getOrderedItems, getRovingProps, orientation } = useRovingFocus.useRovingFocus(focusValue);
    const rovingProps = getRovingProps({
        onKeyDown: (e) => {
            rest?.onKeyDown?.(e);
            const items = getOrderedItems();
            let nextItem;
            switch (orientation) {
                case 'horizontal':
                    if (e.key === 'ArrowRight') {
                        nextItem = getNextFocusableValue(items, focusValue);
                    }
                    if (e.key === 'ArrowLeft') {
                        nextItem = getPrevFocusableValue(items, focusValue);
                    }
                    break;
                case 'vertical':
                    if (e.key === 'ArrowDown') {
                        nextItem = getNextFocusableValue(items, focusValue);
                    }
                    if (e.key === 'ArrowUp') {
                        nextItem = getPrevFocusableValue(items, focusValue);
                    }
                    break;
                case 'ambiguous':
                    if (['ArrowRight', 'ArrowDown'].includes(e.key)) {
                        nextItem = getNextFocusableValue(items, focusValue);
                    }
                    if (['ArrowLeft', 'ArrowUp'].includes(e.key)) {
                        nextItem = getPrevFocusableValue(items, focusValue);
                    }
            }
            if (e.key === 'Home') {
                nextItem = items[0];
            }
            if (e.key === 'End') {
                nextItem = items[items.length - 1];
            }
            if (nextItem) {
                e.preventDefault();
                nextItem.element.focus();
            }
        },
    });
    const mergedRefs = react$1.useMergeRefs([ref, rovingProps.ref]);
    return (jsxRuntime.jsx(Component, { ...rest, ...rovingProps, ref: mergedRefs, children: rest.children }));
});

exports.RovingFocusItem = RovingFocusItem;
exports.getNextFocusableValue = getNextFocusableValue;
exports.getPrevFocusableValue = getPrevFocusableValue;
