'use client';
'use strict';

var react = require('react');

const toggleIndeterminate = (getIndeterminateInputs, getInputs) => {
    const inputs = getIndeterminateInputs();
    const checked = !!getInputs(true).length;
    const unchecked = !!getInputs(false).length;
    for (const input of inputs) {
        input.indeterminate = unchecked && checked;
        input.checked = !unchecked && checked;
    }
};
function useCheckboxGroup(props) {
    const { error, name: groupName, onChange, value = [], disabled, readOnly, required, } = props || {};
    const [groupValue, setGroupValue] = react.useState(value);
    const namedId = react.useId();
    const errorId = react.useId();
    const checkboxRefs = react.useRef(new Set());
    const indeterminateRefs = react.useRef(new Set());
    const inputRefs = react.useRef(new Map());
    const getInputs = (checked) => Array.from(checkboxRefs.current.values()).filter((input) => input.checked === checked);
    const getIndeterminateInputs = () => Array.from(indeterminateRefs.current.values());
    react.useEffect(() => {
        toggleIndeterminate(getIndeterminateInputs, getInputs);
    }, [groupValue]);
    return {
        /**
         * Current value of the group.
         */
        value: groupValue,
        /**
         * Set the value of the group.
         *
         * @param value string[]
         * @returns void
         */
        setValue: setGroupValue,
        /**
         * Props to send to the `Checkbox` component.
         * Accepts value or object
         * @example
         * <Checkbox {...getCheckboxProps('value')} />
         *
         * @example allow indeterminate
         * <Checkbox {...getCheckboxProps({ value: 'all', allowIndeterminate: true })} />
         */
        getCheckboxProps: (propsOrValue) => {
            const props = typeof propsOrValue === 'string'
                ? { value: propsOrValue }
                : propsOrValue || {};
            const { allowIndeterminate = false, ref: forwardedRef = undefined, value = '', ...rest } = props;
            const handleRef = (element) => {
                if (element) {
                    const refs = allowIndeterminate ? indeterminateRefs : checkboxRefs;
                    refs.current.add(element);
                    inputRefs.current.set(value, element);
                    if (getIndeterminateInputs().length) {
                        toggleIndeterminate(getIndeterminateInputs, getInputs);
                    }
                }
                else {
                    const oldElement = inputRefs.current.get(value);
                    if (oldElement) {
                        checkboxRefs.current.delete(oldElement);
                        indeterminateRefs.current.delete(oldElement);
                        inputRefs.current.delete(value);
                    }
                }
                if (forwardedRef) {
                    if (typeof forwardedRef === 'function') {
                        forwardedRef(element);
                    }
                    else {
                        forwardedRef.current = element;
                    }
                }
            };
            const handleChange = () => {
                const nextGroupValue = Array.from(getInputs(true), ({ value }) => value);
                setGroupValue(nextGroupValue);
                onChange?.(nextGroupValue, groupValue);
            };
            const indeterminateChange = () => {
                const element = inputRefs.current.get(value);
                if (!element)
                    return;
                const checked = !!element.checked;
                for (const input of getInputs(!checked)) {
                    input.click();
                }
            };
            return {
                ...rest,
                'aria-describedby': `${error ? errorId : ''} ${rest['aria-describedby'] || ''}`.trim() ||
                    undefined,
                'aria-invalid': !!error || rest['aria-invalid'],
                checked: allowIndeterminate ? undefined : groupValue.includes(value),
                name: rest.name || groupName || namedId,
                onChange: (e) => {
                    rest.onChange?.(e);
                    if (e.defaultPrevented)
                        return;
                    allowIndeterminate && indeterminateChange();
                    handleChange();
                },
                ref: handleRef,
                value,
                disabled: disabled || rest.disabled,
                readOnly: readOnly || rest.readOnly,
                required: required || rest.required,
            };
        },
        /**
         * Props to send to the `ValidationMessage` component.
         *
         * @example
         * <ValidationMessage {...validationMessageProps} />
         */
        validationMessageProps: {
            children: error,
            hidden: !error,
            id: errorId,
        },
    };
}

exports.useCheckboxGroup = useCheckboxGroup;
