'use strict';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// ../utils.ts
var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.navigator !== "undefined";
var IS_ANDROID = IS_BROWSER && /android/i.test(navigator.userAgent);
var IS_FIREFOX = IS_BROWSER && /firefox/i.test(navigator.userAgent);
var IS_IOS = IS_BROWSER && /iPad|iPhone|iPod/.test(navigator.userAgent);
var IS_SAFARI = IS_BROWSER && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var _a;
IS_BROWSER && // @ts-expect-error Typescript has not implemented userAgentData yet https://stackoverflow.com/a/71392474
/^Mac/i.test(((_a = navigator.userAgentData) == null ? undefined : _a.platform) || navigator.platform);
var SAFE_LABELLEDBY = `${IS_ANDROID ? "data" : "aria"}-labelledby`;
var SAFE_MULTISELECTABLE = `${IS_SAFARI ? "aria" : "data"}-multiselectable`;
var DISPLAY_BLOCK = ":host(:not([hidden])) { display: block }";
var FOCUS_OUTLINE = "outline: 1px dotted; outline: 5px auto Highlight; outline: 5px auto -webkit-focus-ring-color";
var UHTMLElement = typeof HTMLElement === "undefined" ? class {
} : HTMLElement;
function attr(el, name, value) {
  var _a2;
  if (value === undefined) return (_a2 = el.getAttribute(name)) != null ? _a2 : null;
  if (value === null) el.removeAttribute(name);
  else if (el.getAttribute(name) !== value) el.setAttribute(name, value);
  return null;
}
var events = (action, element, rest) => {
  for (const type of rest[0].split(",")) {
    rest[0] = type;
    Element.prototype[`${action}EventListener`].apply(element, rest);
  }
};
var on = (element, ...rest) => events("add", element, rest);
var off = (element, ...rest) => events("remove", element, rest);
var attachStyle = (element, css) => element.attachShadow({ mode: "open" }).append(
  createElement("slot"),
  // Unnamed slot does automatically render all top element nodes
  createElement("style", css)
);
var observers = /* @__PURE__ */ new WeakMap();
var mutationObserver = (element, options) => {
  if (options === undefined) return observers.get(element);
  try {
    observers.get(element).disconnect();
    observers.delete(element);
  } catch (err) {
  }
  if (options) {
    const observer = new MutationObserver(
      (detail) => element.handleEvent({ type: "mutation", detail })
    );
    observer.observe(element, options);
    observers.set(element, observer);
  }
};
var getRoot = (node) => {
  var _a2;
  const root = ((_a2 = node.getRootNode) == null ? undefined : _a2.call(node)) || node.ownerDocument;
  return root instanceof Document || root instanceof ShadowRoot ? root : document;
};
var id = 0;
var useId = (el) => {
  if (!el) return "";
  if (!el.id) el.id = `:${el.nodeName.toLowerCase()}${(++id).toString(32)}`;
  return el.id;
};
var createElement = (tagName, text, attrs) => {
  const el = document.createElement(tagName);
  if (text) el.textContent = text;
  return el;
};
var customElements = {
  define: (name, instance) => !IS_BROWSER || window.customElements.get(name) || window.customElements.define(name, instance)
};
var createAriaLive = (mode) => {
  if (!IS_BROWSER) return null;
  const live = createElement("div");
  live.style.cssText = "position:fixed;overflow:hidden;width:1px;white-space:nowrap";
  attr(live, "aria-live", mode);
  return document.body.appendChild(live);
};
function attributeTexts(texts, prop, value) {
  if (!prop) return Object.keys(texts).map((key2) => `data-sr-${key2}`);
  const key = (prop == null ? undefined : prop.startsWith("data-sr-")) && prop.slice(8);
  if (key && value && texts[key]) texts[key] = value;
  return [];
}

// u-option.ts
var DISABLED = "disabled";
var SELECTED = "selected";
var UHTMLOptionElement = class extends UHTMLElement {
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return [DISABLED, SELECTED];
  }
  constructor() {
    super();
    attachStyle(
      this,
      `${DISPLAY_BLOCK}:host(:focus){${FOCUS_OUTLINE}}:host{ cursor: pointer }`
    );
  }
  connectedCallback() {
    if (!IS_IOS) this.tabIndex = -1;
    if (!attr(this, "role")) attr(this, "role", "option");
    this.attributeChangedCallback();
  }
  attributeChangedCallback() {
    attr(this, "aria-disabled", `${this.disabled}`);
    attr(this, "aria-selected", `${this.selected}`);
  }
  /** Sets or retrieves whether the option in the list box is the default item. */
  get defaultSelected() {
    return this[SELECTED];
  }
  set defaultSelected(value) {
    this[SELECTED] = value;
  }
  get disabled() {
    return attr(this, DISABLED) !== null;
  }
  set disabled(value) {
    attr(this, DISABLED, value ? "" : null);
  }
  /** Retrieves a reference to the form that the object is embedded in. */
  get form() {
    return this.closest("form");
  }
  /** Sets or retrieves the ordinal position of an option in a list box. */
  get index() {
    var _a2;
    const options = (_a2 = this.closest("u-datalist")) == null ? undefined : _a2.getElementsByTagName("u-option");
    return Array.from(options || [this]).indexOf(this);
  }
  /** Sets or retrieves a value that you can use to implement your own label functionality for the object. */
  get label() {
    return attr(this, "label") || this.text;
  }
  set label(value) {
    attr(this, "label", value);
  }
  get selected() {
    return attr(this, SELECTED) !== null;
  }
  set selected(value) {
    attr(this, SELECTED, value ? "" : null);
  }
  /** Sets or retrieves the text string specified by the option tag. */
  get text() {
    var _a2;
    return ((_a2 = this.textContent) == null ? undefined : _a2.trim()) || "";
  }
  set text(text) {
    this.textContent = text;
  }
  /** Sets or retrieves the value which is returned to the server when the form control is submitted. */
  get value() {
    return attr(this, "value") || this.text;
  }
  set value(value) {
    attr(this, "value", value);
  }
};
customElements.define("u-option", UHTMLOptionElement);

// u-datalist.ts
var IS_PRESS = false;
var LIVE_TIMER;
var LIVE_SR_FIX = 0;
var LIVE = createAriaLive("assertive");
var IS_SAFARI_MAC = IS_SAFARI && !IS_IOS;
var EVENTS = "click,focusout,input,keydown,mousedown,mouseup";
var TEXTS = {
  singular: "%d hit",
  plural: "%d hits"
};
var UHTMLDataListElement = class extends UHTMLElement {
  constructor() {
    super();
    // Using underscore instead of private fields for backwards compatibility
    // _announceCount = 0;
    // _announceTimer: ReturnType<typeof setTimeout> | number = 0;
    this._blurTimer = 0;
    this._input = null;
    this._root = null;
    this._value = "";
    // Store sanitized value to speed up option filtering
    this._texts = __spreadValues({}, TEXTS);
    attachStyle(
      this,
      `${DISPLAY_BLOCK}::slotted(u-option[disabled]) { display: none !important }`
      // Hide disabled options
    );
  }
  // Speed up translated texts
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return ["id", ...attributeTexts(TEXTS)];
  }
  connectedCallback() {
    this.hidden = true;
    this._root = getRoot(this);
    if (LIVE && !LIVE.isConnected) document.body.append(LIVE);
    attr(this, "role", "listbox");
    on(this._root, "focusin", this);
    on(this._root, "focus", this, true);
    setTimeout(() => this.attributeChangedCallback());
  }
  disconnectedCallback() {
    off(this._root || this, "focus", this, true);
    off(this._root || this, "focusin", this);
    disconnectInput(this);
    this._root = null;
  }
  attributeChangedCallback(prop, _prev, next) {
    var _a2;
    attributeTexts(this._texts, prop, next);
    const inputs = (_a2 = this._root) == null ? undefined : _a2.querySelectorAll(`input[list="${this.id}"]`);
    for (const input of inputs || []) setupInput(this, input);
  }
  handleEvent(event) {
    const { type } = event;
    if (event.defaultPrevented) return;
    if (type === "click") onClick(this, event);
    if (type === "focus" || type === "focusin") onFocusIn(this, event);
    if (type === "focusout") onFocusOut(this);
    if (type === "keydown") onKeyDown(this, event);
    if (type === "mutation" || type === "input") setupOptions(this, event);
    if (type === "mouseup") IS_PRESS = false;
    if (type === "mousedown") IS_PRESS = this.contains(event.target);
  }
  get options() {
    return this.getElementsByTagName("u-option");
  }
};
var onFocusIn = (self, { target }) => {
  var _a2;
  const isInput = self._input === target;
  const isInside = isInput || self.contains(target);
  if (isInside) return clearTimeout(self._blurTimer);
  if (!isInput && target instanceof HTMLInputElement && attr(target, "list") === self.id) {
    if (self._input) disconnectInput(self);
    self._input = target;
    attr(self, SAFE_LABELLEDBY, useId((_a2 = self._input.labels) == null ? undefined : _a2[0]));
    on(self._root || self, EVENTS, self);
    mutationObserver(self, {
      attributeFilter: ["value"],
      // Listen for value changes to show u-options
      attributes: true,
      childList: true,
      subtree: true
    });
    setExpanded(self, true);
  }
};
var onFocusOut = (self) => {
  if (!IS_PRESS) self._blurTimer = setTimeout(() => disconnectInput(self));
};
var onClick = (self, { target }) => {
  var _a2, _b, _c, _d, _e;
  const isSingle = attr(self, SAFE_MULTISELECTABLE) !== "true";
  const option = [...self.options].find((opt) => opt.contains(target));
  if (self._input === target) {
    setExpanded(self, true);
  } else if (option && isInteractiveOption(option)) {
    for (const opt of self.options) {
      if (opt === option) opt.selected = true;
      else if (isSingle) opt.selected = false;
    }
    (_b = (_a2 = Object.getOwnPropertyDescriptor(
      HTMLInputElement.prototype,
      "value"
    )) == null ? undefined : _a2.set) == null ? undefined : _b.call(self._input, option.value);
    if (isSingle) {
      (_c = self._input) == null ? undefined : _c.focus();
      setExpanded(self, false);
    }
    (_d = self._input) == null ? undefined : _d.dispatchEvent(
      new Event("input", { bubbles: true, composed: true })
    );
    (_e = self._input) == null ? undefined : _e.dispatchEvent(new Event("change", { bubbles: true }));
  }
};
var onKeyDown = (self, event) => {
  var _a2, _b;
  if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return;
  if (event.key !== "Escape") setExpanded(self, true);
  const { key } = event;
  const active = (_a2 = self._root) == null ? undefined : _a2.activeElement;
  const options = getVisibleOptions(self);
  const index = options.indexOf(active);
  let next = -1;
  if (key === "ArrowDown") next = (index + 1) % options.length;
  if (key === "ArrowUp") next = (~index ? index : options.length) - 1;
  if (~index) {
    if (key === "Home" || key === "PageUp") next = 0;
    if (key === "End" || key === "PageDown") next = options.length - 1;
    if (key === "Enter") {
      options[index].click();
      return event.preventDefault();
    }
  }
  if (options[next]) for (const option of options) option.tabIndex = -1;
  if (options[next]) event.preventDefault();
  (_b = options[next] || self._input) == null ? undefined : _b.focus();
  if (key === "Escape") setExpanded(self, false);
};
var setExpanded = (self, open) => {
  self.hidden = !open;
  if (self.popover) self.togglePopover(open);
  if (self._input) setupInput(self, self._input, open);
  if (open) setupOptions(self);
};
var disconnectInput = (self) => {
  off(self._root || self, EVENTS, self);
  mutationObserver(self, false);
  setExpanded(self, false);
  self._input = null;
};
var getVisibleOptions = (self) => [...self.options].filter(
  (opt) => !opt.disabled && opt.offsetWidth && opt.offsetHeight
  // Checks disabled or visibility (since hidden attribute can be overwritten by display: block)
);
var isInteractiveOption = (option) => option instanceof HTMLOptionElement || option.getAttribute("role") === "option";
var setupInput = (self, input, open = false) => {
  attr(input, "popovertarget", useId(self));
  attr(input, "aria-autocomplete", "list");
  attr(input, "aria-controls", useId(self));
  attr(input, "aria-expanded", `${IS_SAFARI_MAC || open}`);
  attr(input, "autocomplete", "off");
  attr(input, "role", "combobox");
};
var sanitize = (str) => (str == null ? undefined : str.toLowerCase().trim()) || "";
var setupOptions = (self, event) => {
  var _a2;
  const value = sanitize((_a2 = self._input) == null ? undefined : _a2.value);
  const hasChange = (event == null ? undefined : event.type) === "mutation" || self._value !== value;
  if (!hasChange) return;
  const hidden = self.hidden;
  const isSingle = attr(self, SAFE_MULTISELECTABLE) !== "true";
  const isTyping = event instanceof InputEvent && !isDatalistClick(event);
  self.hidden = true;
  self._value = value;
  for (const opt of self.options) {
    const content = [opt.value, opt.label, opt.text].map(sanitize);
    opt.hidden = !content.some((str) => str.includes(value));
    if (isSingle && isTyping && isInteractiveOption(opt))
      opt.selected = content.includes(value);
  }
  self.hidden = hidden;
  const visible = getVisibleOptions(self);
  clearTimeout(LIVE_TIMER);
  LIVE_TIMER = setTimeout(() => {
    const { length } = visible.filter(isInteractiveOption);
    const liveSrFix = ++LIVE_SR_FIX % 2 ? "\xA0" : "";
    const countText = `${`${self._texts[length === 1 ? "singular" : "plural"]}`.replace("%d", `${length}`)}`;
    if (LIVE)
      LIVE.textContent = `${!length && self.innerText.trim() || countText}${liveSrFix}`;
  }, 1e3);
  if (IS_IOS)
    visible.map((opt, index, length) => {
      opt.title = `${index + 1}/${length}`;
    });
};
if (IS_BROWSER)
  Object.defineProperty(HTMLInputElement.prototype, "list", {
    configurable: true,
    enumerable: true,
    get() {
      return getRoot(this).getElementById(attr(this, "list") || "");
    }
  });
customElements.define("u-datalist", UHTMLDataListElement);
var SPLIT_CHAR = "\u2001".repeat(100);
var SPLIT_ATTR = IS_FIREFOX ? "label" : "value";
var FIREFOX_OPTION_CLICK = "insertReplacementText";
var getDatalistValue = ({
  value
}) => value.split(SPLIT_CHAR)[0];
function isDatalistClick(event) {
  var _a2;
  const isClick = event instanceof Event && event.type === "input" && event.target instanceof HTMLInputElement && (!event.inputType || event.inputType === FIREFOX_OPTION_CLICK);
  if (isClick) {
    const value = event.target.value;
    const ignored = Array.from(((_a2 = event.target.list) == null ? undefined : _a2.options) || []).some(
      (opt) => opt.value === value && !isInteractiveOption(opt)
    );
    event.target.value = value.split(SPLIT_CHAR)[ignored ? 1 : 0];
  }
  return isClick;
}
function syncDatalistState(input) {
  var _a2;
  for (const option of ((_a2 = input.list) == null ? undefined : _a2.children) || [])
    if (option instanceof HTMLOptionElement || option instanceof UHTMLOptionElement) {
      option[SPLIT_ATTR] = `${getDatalistValue(option)}${SPLIT_CHAR}${input.value}`;
    }
}

exports.UHTMLDataListElement = UHTMLDataListElement;
exports.getDatalistValue = getDatalistValue;
exports.isDatalistClick = isDatalistClick;
exports.syncDatalistState = syncDatalistState;
