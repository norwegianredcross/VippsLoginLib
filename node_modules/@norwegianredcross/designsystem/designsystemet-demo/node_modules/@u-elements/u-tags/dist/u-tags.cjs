'use strict';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// ../utils.ts
var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.navigator !== "undefined";
var IS_ANDROID = IS_BROWSER && /android/i.test(navigator.userAgent);
var IS_FIREFOX = IS_BROWSER && /firefox/i.test(navigator.userAgent);
var IS_IOS = IS_BROWSER && /iPad|iPhone|iPod/.test(navigator.userAgent);
var IS_SAFARI = IS_BROWSER && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var _a;
var IS_MAC = IS_BROWSER && // @ts-expect-error Typescript has not implemented userAgentData yet https://stackoverflow.com/a/71392474
/^Mac/i.test(((_a = navigator.userAgentData) == null ? undefined : _a.platform) || navigator.platform);
var SAFE_LABELLEDBY = `${IS_ANDROID ? "data" : "aria"}-labelledby`;
var SAFE_MULTISELECTABLE = `${IS_SAFARI ? "aria" : "data"}-multiselectable`;
var DISPLAY_BLOCK = ":host(:not([hidden])) { display: block }";
var FOCUS_OUTLINE = "outline: 1px dotted; outline: 5px auto Highlight; outline: 5px auto -webkit-focus-ring-color";
var UHTMLElement = typeof HTMLElement === "undefined" ? class {
} : HTMLElement;
function attr(el, name, value) {
  var _a2;
  if (value === undefined) return (_a2 = el.getAttribute(name)) != null ? _a2 : null;
  if (value === null) el.removeAttribute(name);
  else if (el.getAttribute(name) !== value) el.setAttribute(name, value);
  return null;
}
var events = (action, element, rest) => {
  for (const type of rest[0].split(",")) {
    rest[0] = type;
    Element.prototype[`${action}EventListener`].apply(element, rest);
  }
};
var on = (element, ...rest) => events("add", element, rest);
var off = (element, ...rest) => events("remove", element, rest);
var attachStyle = (element, css) => element.attachShadow({ mode: "open" }).append(
  createElement("slot"),
  // Unnamed slot does automatically render all top element nodes
  createElement("style", css)
);
var observers = /* @__PURE__ */ new WeakMap();
var mutationObserver = (element, options) => {
  if (options === undefined) return observers.get(element);
  try {
    observers.get(element).disconnect();
    observers.delete(element);
  } catch (err) {
  }
  if (options) {
    const observer = new MutationObserver(
      (detail) => element.handleEvent({ type: "mutation", detail })
    );
    observer.observe(element, options);
    observers.set(element, observer);
  }
};
var asButton = (event) => {
  const isClick = "key" in event && (event.key === " " || event.key === "Enter");
  if (isClick) event.preventDefault();
  if (isClick && event.target instanceof HTMLElement) event.target.click();
  return isClick;
};
var getRoot = (node) => {
  var _a2;
  const root = ((_a2 = node.getRootNode) == null ? undefined : _a2.call(node)) || node.ownerDocument;
  return root instanceof Document || root instanceof ShadowRoot ? root : document;
};
var id = 0;
var useId = (el) => {
  if (!el) return "";
  if (!el.id) el.id = `:${el.nodeName.toLowerCase()}${(++id).toString(32)}`;
  return el.id;
};
var createElement = (tagName, text, attrs) => {
  const el = document.createElement(tagName);
  if (text) el.textContent = text;
  if (attrs) for (const [key, val] of Object.entries(attrs)) attr(el, key, val);
  return el;
};
var customElements = {
  define: (name, instance) => !IS_BROWSER || window.customElements.get(name) || window.customElements.define(name, instance)
};
var createAriaLive = (mode) => {
  if (!IS_BROWSER) return null;
  const live = createElement("div");
  live.style.cssText = "position:fixed;overflow:hidden;width:1px;white-space:nowrap";
  attr(live, "aria-live", mode);
  return document.body.appendChild(live);
};
function attributeTexts(texts, prop, value) {
  if (!prop) return Object.keys(texts).map((key2) => `data-sr-${key2}`);
  const key = (prop == null ? undefined : prop.startsWith("data-sr-")) && prop.slice(8);
  if (key && value && texts[key]) texts[key] = value;
  return [];
}

// ../u-datalist/u-option.ts
var DISABLED = "disabled";
var SELECTED = "selected";
var UHTMLOptionElement = class extends UHTMLElement {
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return [DISABLED, SELECTED];
  }
  constructor() {
    super();
    attachStyle(
      this,
      `${DISPLAY_BLOCK}:host(:focus){${FOCUS_OUTLINE}}:host{ cursor: pointer }`
    );
  }
  connectedCallback() {
    if (!IS_IOS) this.tabIndex = -1;
    if (!attr(this, "role")) attr(this, "role", "option");
    this.attributeChangedCallback();
  }
  attributeChangedCallback() {
    attr(this, "aria-disabled", `${this.disabled}`);
    attr(this, "aria-selected", `${this.selected}`);
  }
  /** Sets or retrieves whether the option in the list box is the default item. */
  get defaultSelected() {
    return this[SELECTED];
  }
  set defaultSelected(value) {
    this[SELECTED] = value;
  }
  get disabled() {
    return attr(this, DISABLED) !== null;
  }
  set disabled(value) {
    attr(this, DISABLED, value ? "" : null);
  }
  /** Retrieves a reference to the form that the object is embedded in. */
  get form() {
    return this.closest("form");
  }
  /** Sets or retrieves the ordinal position of an option in a list box. */
  get index() {
    var _a2;
    const options = (_a2 = this.closest("u-datalist")) == null ? undefined : _a2.getElementsByTagName("u-option");
    return Array.from(options || [this]).indexOf(this);
  }
  /** Sets or retrieves a value that you can use to implement your own label functionality for the object. */
  get label() {
    return attr(this, "label") || this.text;
  }
  set label(value) {
    attr(this, "label", value);
  }
  get selected() {
    return attr(this, SELECTED) !== null;
  }
  set selected(value) {
    attr(this, SELECTED, value ? "" : null);
  }
  /** Sets or retrieves the text string specified by the option tag. */
  get text() {
    var _a2;
    return ((_a2 = this.textContent) == null ? undefined : _a2.trim()) || "";
  }
  set text(text) {
    this.textContent = text;
  }
  /** Sets or retrieves the value which is returned to the server when the form control is submitted. */
  get value() {
    return attr(this, "value") || this.text;
  }
  set value(value) {
    attr(this, "value", value);
  }
};
customElements.define("u-option", UHTMLOptionElement);

// ../u-datalist/u-datalist.ts
var IS_PRESS = false;
var LIVE_TIMER;
var LIVE_SR_FIX = 0;
var LIVE = createAriaLive("assertive");
var IS_SAFARI_MAC = IS_SAFARI && !IS_IOS;
var EVENTS = "click,focusout,input,keydown,mousedown,mouseup";
var TEXTS = {
  singular: "%d hit",
  plural: "%d hits"
};
var UHTMLDataListElement = class extends UHTMLElement {
  constructor() {
    super();
    // Using underscore instead of private fields for backwards compatibility
    // _announceCount = 0;
    // _announceTimer: ReturnType<typeof setTimeout> | number = 0;
    this._blurTimer = 0;
    this._input = null;
    this._root = null;
    this._value = "";
    // Store sanitized value to speed up option filtering
    this._texts = __spreadValues({}, TEXTS);
    attachStyle(
      this,
      `${DISPLAY_BLOCK}::slotted(u-option[disabled]) { display: none !important }`
      // Hide disabled options
    );
  }
  // Speed up translated texts
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return ["id", ...attributeTexts(TEXTS)];
  }
  connectedCallback() {
    this.hidden = true;
    this._root = getRoot(this);
    if (LIVE && !LIVE.isConnected) document.body.append(LIVE);
    attr(this, "role", "listbox");
    on(this._root, "focusin", this);
    on(this._root, "focus", this, true);
    setTimeout(() => this.attributeChangedCallback());
  }
  disconnectedCallback() {
    off(this._root || this, "focus", this, true);
    off(this._root || this, "focusin", this);
    disconnectInput(this);
    this._root = null;
  }
  attributeChangedCallback(prop, _prev, next) {
    var _a2;
    attributeTexts(this._texts, prop, next);
    const inputs = (_a2 = this._root) == null ? undefined : _a2.querySelectorAll(`input[list="${this.id}"]`);
    for (const input of inputs || []) setupInput(this, input);
  }
  handleEvent(event) {
    const { type } = event;
    if (event.defaultPrevented) return;
    if (type === "click") onClick(this, event);
    if (type === "focus" || type === "focusin") onFocusIn(this, event);
    if (type === "focusout") onFocusOut(this);
    if (type === "keydown") onKeyDown(this, event);
    if (type === "mutation" || type === "input") setupOptions(this, event);
    if (type === "mouseup") IS_PRESS = false;
    if (type === "mousedown") IS_PRESS = this.contains(event.target);
  }
  get options() {
    return this.getElementsByTagName("u-option");
  }
};
var onFocusIn = (self, { target }) => {
  var _a2;
  const isInput = self._input === target;
  const isInside = isInput || self.contains(target);
  if (isInside) return clearTimeout(self._blurTimer);
  if (!isInput && target instanceof HTMLInputElement && attr(target, "list") === self.id) {
    if (self._input) disconnectInput(self);
    self._input = target;
    attr(self, SAFE_LABELLEDBY, useId((_a2 = self._input.labels) == null ? undefined : _a2[0]));
    on(self._root || self, EVENTS, self);
    mutationObserver(self, {
      attributeFilter: ["value"],
      // Listen for value changes to show u-options
      attributes: true,
      childList: true,
      subtree: true
    });
    setExpanded(self, true);
  }
};
var onFocusOut = (self) => {
  if (!IS_PRESS) self._blurTimer = setTimeout(() => disconnectInput(self));
};
var onClick = (self, { target }) => {
  var _a2, _b, _c, _d, _e;
  const isSingle = attr(self, SAFE_MULTISELECTABLE) !== "true";
  const option = [...self.options].find((opt) => opt.contains(target));
  if (self._input === target) {
    setExpanded(self, true);
  } else if (option && isInteractiveOption(option)) {
    for (const opt of self.options) {
      if (opt === option) opt.selected = true;
      else if (isSingle) opt.selected = false;
    }
    (_b = (_a2 = Object.getOwnPropertyDescriptor(
      HTMLInputElement.prototype,
      "value"
    )) == null ? undefined : _a2.set) == null ? undefined : _b.call(self._input, option.value);
    if (isSingle) {
      (_c = self._input) == null ? undefined : _c.focus();
      setExpanded(self, false);
    }
    (_d = self._input) == null ? undefined : _d.dispatchEvent(
      new Event("input", { bubbles: true, composed: true })
    );
    (_e = self._input) == null ? undefined : _e.dispatchEvent(new Event("change", { bubbles: true }));
  }
};
var onKeyDown = (self, event) => {
  var _a2, _b;
  if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return;
  if (event.key !== "Escape") setExpanded(self, true);
  const { key } = event;
  const active = (_a2 = self._root) == null ? undefined : _a2.activeElement;
  const options = getVisibleOptions(self);
  const index = options.indexOf(active);
  let next = -1;
  if (key === "ArrowDown") next = (index + 1) % options.length;
  if (key === "ArrowUp") next = (~index ? index : options.length) - 1;
  if (~index) {
    if (key === "Home" || key === "PageUp") next = 0;
    if (key === "End" || key === "PageDown") next = options.length - 1;
    if (key === "Enter") {
      options[index].click();
      return event.preventDefault();
    }
  }
  if (options[next]) for (const option of options) option.tabIndex = -1;
  if (options[next]) event.preventDefault();
  (_b = options[next] || self._input) == null ? undefined : _b.focus();
  if (key === "Escape") setExpanded(self, false);
};
var setExpanded = (self, open) => {
  self.hidden = !open;
  if (self.popover) self.togglePopover(open);
  if (self._input) setupInput(self, self._input, open);
  if (open) setupOptions(self);
};
var disconnectInput = (self) => {
  off(self._root || self, EVENTS, self);
  mutationObserver(self, false);
  setExpanded(self, false);
  self._input = null;
};
var getVisibleOptions = (self) => [...self.options].filter(
  (opt) => !opt.disabled && opt.offsetWidth && opt.offsetHeight
  // Checks disabled or visibility (since hidden attribute can be overwritten by display: block)
);
var isInteractiveOption = (option) => option instanceof HTMLOptionElement || option.getAttribute("role") === "option";
var setupInput = (self, input, open = false) => {
  attr(input, "popovertarget", useId(self));
  attr(input, "aria-autocomplete", "list");
  attr(input, "aria-controls", useId(self));
  attr(input, "aria-expanded", `${IS_SAFARI_MAC || open}`);
  attr(input, "autocomplete", "off");
  attr(input, "role", "combobox");
};
var sanitize = (str) => (str == null ? undefined : str.toLowerCase().trim()) || "";
var setupOptions = (self, event) => {
  var _a2;
  const value = sanitize((_a2 = self._input) == null ? undefined : _a2.value);
  const hasChange = (event == null ? undefined : event.type) === "mutation" || self._value !== value;
  if (!hasChange) return;
  const hidden = self.hidden;
  const isSingle = attr(self, SAFE_MULTISELECTABLE) !== "true";
  const isTyping = event instanceof InputEvent && !isDatalistClick(event);
  self.hidden = true;
  self._value = value;
  for (const opt of self.options) {
    const content = [opt.value, opt.label, opt.text].map(sanitize);
    opt.hidden = !content.some((str) => str.includes(value));
    if (isSingle && isTyping && isInteractiveOption(opt))
      opt.selected = content.includes(value);
  }
  self.hidden = hidden;
  const visible = getVisibleOptions(self);
  clearTimeout(LIVE_TIMER);
  LIVE_TIMER = setTimeout(() => {
    const { length } = visible.filter(isInteractiveOption);
    const liveSrFix = ++LIVE_SR_FIX % 2 ? "\xA0" : "";
    const countText = `${`${self._texts[length === 1 ? "singular" : "plural"]}`.replace("%d", `${length}`)}`;
    if (LIVE)
      LIVE.textContent = `${!length && self.innerText.trim() || countText}${liveSrFix}`;
  }, 1e3);
  if (IS_IOS)
    visible.map((opt, index, length) => {
      opt.title = `${index + 1}/${length}`;
    });
};
if (IS_BROWSER)
  Object.defineProperty(HTMLInputElement.prototype, "list", {
    configurable: true,
    enumerable: true,
    get() {
      return getRoot(this).getElementById(attr(this, "list") || "");
    }
  });
customElements.define("u-datalist", UHTMLDataListElement);
var SPLIT_CHAR = "\u2001".repeat(100);
var FIREFOX_OPTION_CLICK = "insertReplacementText";
var getDatalistValue = ({
  value
}) => value.split(SPLIT_CHAR)[0];
function isDatalistClick(event) {
  var _a2;
  const isClick = event instanceof Event && event.type === "input" && event.target instanceof HTMLInputElement && (!event.inputType || event.inputType === FIREFOX_OPTION_CLICK);
  if (isClick) {
    const value = event.target.value;
    const ignored = Array.from(((_a2 = event.target.list) == null ? undefined : _a2.options) || []).some(
      (opt) => opt.value === value && !isInteractiveOption(opt)
    );
    event.target.value = value.split(SPLIT_CHAR)[ignored ? 1 : 0];
  }
  return isClick;
}

// u-tags.ts
var IS_MOBILE = IS_ANDROID || IS_IOS;
var IS_FIREFOX_MAC = IS_FIREFOX || IS_MAC;
var LIVE2 = createAriaLive("polite");
var EVENTS2 = "input,focusin,focusout,keydown";
var TEXTS2 = {
  added: "Added",
  remove: "Press to remove",
  removed: "Removed",
  empty: "No selected",
  found: "Navigate left to find %d selected",
  of: "of"
};
var UHTMLTagsElement = class extends UHTMLElement {
  constructor() {
    super();
    // Using underscore instead of private fields for backwards compatibility
    this._blurAnnounceReset = false;
    this._blurTimer = 0;
    this._focusIndex = null;
    this._root = null;
    this._texts = __spreadValues({}, TEXTS2);
    this.attachShadow({ mode: "open" }).append(
      createElement("slot"),
      // Content slot
      createElement(
        "style",
        `:host(:not([hidden])){ display: inline-block }
        ::slotted(data) { cursor: pointer; display: inline-block; outline: none; pointer-events: none }
        ::slotted(data)::after { content: '\\00D7'; content: '\\00D7' / ''; padding-inline: .5ch; pointer-events: auto }
        ::slotted(data:focus)::after { ${FOCUS_OUTLINE} }`
        // Show focus outline around ::after only
      )
    );
  }
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return attributeTexts(TEXTS2);
  }
  connectedCallback() {
    this._root = getRoot(this);
    if (LIVE2 && !LIVE2.isConnected) document.body.append(LIVE2);
    mutationObserver(this, { childList: true });
    on(this._root, "click", this);
    on(this, EVENTS2, this);
    setTimeout(() => render(this));
  }
  attributeChangedCallback(prop, _prev, next) {
    attributeTexts(this._texts, prop, next);
  }
  disconnectedCallback() {
    mutationObserver(this, false);
    off(this._root || this, "click", this);
    off(this, EVENTS2, this);
    this._root = null;
  }
  handleEvent(event) {
    if (event.defaultPrevented) return;
    if (event.type === "click") onClick2(this, event);
    if (event.type === "focusin") onFocusIn2(this, event);
    if (event.type === "focusout") onFocusOut2(this);
    if (event.type === "input") onInputOptionClick(this, event);
    if (event.type === "keydown") onKeyDown2(this, event);
    if (event.type === "mutation") render(this, event);
  }
  get items() {
    return this.querySelectorAll("data");
  }
  get control() {
    return this.querySelector("input");
  }
};
var dispatchChange = (self, item) => {
  return self.dispatchEvent(
    new CustomEvent("tags", {
      bubbles: true,
      cancelable: true,
      detail: { item, action: item.isConnected ? "remove" : "add" }
    })
  );
};
var render = (self, event) => {
  var _a2, _b, _c, _d, _e;
  const texts = self._texts;
  const change = Number.isNaN(self._focusIndex) ? null : event == null ? undefined : event.detail[0];
  const changeItem = (change == null ? undefined : change.addedNodes[0]) || (change == null ? undefined : change.removedNodes[0]);
  const changeText = `${changeItem ? `${changeItem.isConnected ? texts.added : texts.removed} ${changeItem.textContent}, ` : ""}`;
  const label = ((_c = (_b = (_a2 = self.control) == null ? undefined : _a2.labels) == null ? undefined : _b[0]) == null ? undefined : _c.textContent) || "";
  const values = [];
  attr(self, "role", "group");
  attr(self, "aria-label", label);
  self.items.forEach((item, index, { length }) => {
    var _a3;
    const label2 = `${changeText}${item.textContent}, ${texts.remove}, ${index + 1} ${texts.of} ${length}`;
    attr(item, "aria-label", label2);
    attr(item, "role", "button");
    item.tabIndex = -1;
    item.value = item.value || ((_a3 = item.textContent) == null ? undefined : _a3.trim()) || "";
    values.push(item.value);
  });
  const control = self.control;
  const controlLabel = `${changeText}${label}, ${values.length ? texts.found.replace("%d", `${values.length}`) : texts.empty}`;
  const list = control && document.getElementById(attr(control, "list") || "");
  const options = list == null ? undefined : list.children;
  if (control) attr(control, "aria-label", controlLabel);
  if (list) attr(list, SAFE_MULTISELECTABLE, "true");
  for (const option of options || [])
    option.selected = values.includes(getDatalistValue(option));
  if (changeText) {
    const nextFocus = self.items[(self._focusIndex || 1) - 1] || control;
    const sameFocus = nextFocus === ((_d = getRoot(self)) == null ? undefined : _d.activeElement);
    const tmpFocus = options || self.items;
    self._blurAnnounceReset = false;
    if (nextFocus === control) {
      if (sameFocus) {
        if (IS_MOBILE && LIVE2) LIVE2.textContent = changeText;
        else (_e = tmpFocus[0]) == null ? undefined : _e.focus();
      }
      setTimeout(() => nextFocus == null ? undefined : nextFocus.focus(), 100);
    } else nextFocus == null ? undefined : nextFocus.focus();
    setTimeout(() => {
      if (!IS_FIREFOX_MAC) return render(self);
      self._blurAnnounceReset = true;
    }, 500);
  }
};
var onFocusIn2 = (self, { target }) => {
  clearTimeout(self._blurTimer);
  self._focusIndex = [...self.items].indexOf(target);
};
var onFocusOut2 = (self) => {
  if (self._blurAnnounceReset) render(self);
  self._blurTimer = setTimeout(() => {
    self._focusIndex = null;
  });
};
var onClick2 = (self, { target, clientX: x, clientY: y }) => {
  var _a2;
  const items = self.contains(target) ? [...self.items] : null;
  const itemRemove = items == null ? undefined : items.find((item) => item.contains(target));
  const itemClicked = items == null ? undefined : items.find((item) => {
    const { top, right, bottom, left } = item.getBoundingClientRect();
    return y >= top && y <= bottom && x >= left && x <= right;
  });
  if (itemRemove) dispatchChange(self, itemRemove) && itemRemove.remove();
  else if (itemClicked) itemClicked.focus();
  else if (target === self) (_a2 = self.control) == null ? undefined : _a2.focus();
};
var onInputOptionClick = (self, event) => {
  var _a2;
  const input = event.target;
  if (!isDatalistClick(event) || !(input == null ? undefined : input.value.trim())) return;
  const value = getDatalistValue(input);
  const items = [...self.items];
  const options = [...((_a2 = input == null ? undefined : input.list) == null ? undefined : _a2.children) || []];
  const optionClicked = options.find((opt) => getDatalistValue(opt) === value);
  const itemRemove = items.find((item) => item.value === value);
  const itemAdd = createElement("data", (optionClicked == null ? undefined : optionClicked.text) || value, {
    value
  });
  input.value = "";
  if (!dispatchChange(self, itemRemove || itemAdd)) return;
  if (itemRemove) return itemRemove.remove();
  if (!items[0]) return self.prepend(itemAdd);
  items[items.length - 1].insertAdjacentElement("afterend", itemAdd);
};
var onKeyDown2 = (self, event) => {
  var _a2, _b;
  const { key, repeat, target } = event;
  const input = self.control === target ? self.control : null;
  const isCaretInside = input == null ? undefined : input.selectionEnd;
  let index = input ? self.items.length : (_a2 = self._focusIndex) != null ? _a2 : -1;
  if (index === -1 || !input && asButton(event)) return;
  if (key === "ArrowRight" && !input) index += 1;
  else if (key === "ArrowLeft" && !isCaretInside) index -= 1;
  else if (key === "Enter" && input) {
    event.preventDefault();
    return input.dispatchEvent(new Event("input", { bubbles: true }));
  } else if ((key === "Backspace" || key === "Delete") && !isCaretInside) {
    const remove = !repeat && self.items[index];
    event.preventDefault();
    if (remove) return dispatchChange(self, remove) && remove.remove();
    if (input) index -= 1;
  } else return;
  event.preventDefault();
  (_b = self.items[Math.max(0, index)] || self.control) == null ? undefined : _b.focus();
};
customElements.define("u-tags", UHTMLTagsElement);

exports.UHTMLTagsElement = UHTMLTagsElement;
