'use client';
'use strict';

var jsxRuntime = require('react/jsx-runtime');
var react$1 = require('@floating-ui/react');
var reactSlot = require('@radix-ui/react-slot');
var cl = require('clsx/lite');
var react = require('react');
var DialogTriggerContext = require('./DialogTriggerContext.js');
var Button = require('../Button/Button.js');

/**
 * Dialog component, used to display a dialog dialog.
 *
 * @example with TriggerContext
 * <Dialog.TriggerContext>
 *   <Dialog.Trigger>Open Dialog</Dialog.Trigger>
 *   <Dialog>
 *     <Dialog.Block>
 *       Content
 *     </Dialog.Block>
 *   </Dialog>
 * </Dialog.TriggerContext>
 *
 * @example without TriggerContext
 * const dialogRef = useRef<HTMLDialogElement>(null);
 *
 * ...
 *
 * <Button onClick={() => dialogRef.current?.showModal()}>Open Dialog</Button>
 * <Dialog ref={dialogRef}>
 *   Content
 * </Dialog>
 */
const Dialog = react.forwardRef(function Dialog({ asChild, children, className, closeButton = 'Lukk dialogvindu', closedby = 'closerequest', modal = true, onClose, open, ...rest }, ref) {
    const contextRef = react.useContext(DialogTriggerContext.Context);
    const dialogRef = react.useRef(null); // This local ref is used to make sure the dialog works without a DialogTriggerContext
    const Component = asChild ? reactSlot.Slot : 'dialog';
    const mergedRefs = react$1.useMergeRefs([contextRef, ref, dialogRef]);
    const showProp = modal ? 'showModal' : 'show';
    react.useEffect(() => dialogRef.current?.[open ? showProp : 'close'](), [open]); // Toggle open based on prop
    react.useEffect(() => {
        const dialog = dialogRef.current;
        const handleClosedby = (event) => {
            const { clientY: y, clientX: x, target } = event;
            if (event instanceof KeyboardEvent)
                return (closedby === 'none' &&
                    event.key === 'Escape' &&
                    event.preventDefault()); // Skip ESC-key if closedby="none"
            if (window.getSelection()?.toString())
                return; // Fix bug where if you select text spanning two divs it thinks you clicked outside
            if (dialog && target === dialog && closedby === 'any') {
                const { top, left, right, bottom } = dialog.getBoundingClientRect();
                const isInDialog = top <= y && y <= bottom && left <= x && x <= right;
                if (!isInDialog)
                    dialog?.close(); // Both <dialog> and ::backdrop is considered same event.target
            }
        };
        const handleAutoFocus = () => {
            const autofocus = dialog?.querySelector('[autofocus]');
            if (document.activeElement !== autofocus)
                autofocus?.focus();
        };
        dialog?.addEventListener('animationend', handleAutoFocus);
        dialog?.addEventListener('click', handleClosedby);
        dialog?.addEventListener('keydown', handleClosedby);
        return () => {
            dialog?.removeEventListener('animationend', handleAutoFocus);
            dialog?.removeEventListener('click', handleClosedby);
            dialog?.removeEventListener('keydown', handleClosedby);
        };
    }, [closedby]);
    /* handle closing */
    react.useEffect(() => {
        const handleClose = (event) => onClose?.(event);
        dialogRef.current?.addEventListener('close', handleClose);
        return () => dialogRef.current?.removeEventListener('close', handleClose);
    }, [onClose]);
    return (jsxRuntime.jsxs(Component, { className: cl('ds-dialog', className), ref: mergedRefs, "data-modal": modal, ...rest, children: [closeButton !== false && (jsxRuntime.jsx("form", { method: 'dialog', children: jsxRuntime.jsx(Button.Button, { "aria-label": closeButton, autoFocus: true, "data-color": 'neutral', icon: true, name: 'close', type: 'submit', variant: 'tertiary' }) })), children] }));
});

exports.Dialog = Dialog;
