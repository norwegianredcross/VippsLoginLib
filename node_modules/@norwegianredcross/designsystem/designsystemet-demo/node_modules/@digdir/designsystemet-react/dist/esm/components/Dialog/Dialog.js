'use client';
import { jsxs, jsx } from 'react/jsx-runtime';
import { useMergeRefs } from '@floating-ui/react';
import { Slot } from '@radix-ui/react-slot';
import cl from 'clsx/lite';
import { forwardRef, useContext, useRef, useEffect } from 'react';
import { Context } from './DialogTriggerContext.js';
import { Button } from '../Button/Button.js';

/**
 * Dialog component, used to display a dialog dialog.
 *
 * @example with TriggerContext
 * <Dialog.TriggerContext>
 *   <Dialog.Trigger>Open Dialog</Dialog.Trigger>
 *   <Dialog>
 *     <Dialog.Block>
 *       Content
 *     </Dialog.Block>
 *   </Dialog>
 * </Dialog.TriggerContext>
 *
 * @example without TriggerContext
 * const dialogRef = useRef<HTMLDialogElement>(null);
 *
 * ...
 *
 * <Button onClick={() => dialogRef.current?.showModal()}>Open Dialog</Button>
 * <Dialog ref={dialogRef}>
 *   Content
 * </Dialog>
 */
const Dialog = forwardRef(function Dialog({ asChild, children, className, closeButton = 'Lukk dialogvindu', closedby = 'closerequest', modal = true, onClose, open, ...rest }, ref) {
    const contextRef = useContext(Context);
    const dialogRef = useRef(null); // This local ref is used to make sure the dialog works without a DialogTriggerContext
    const Component = asChild ? Slot : 'dialog';
    const mergedRefs = useMergeRefs([contextRef, ref, dialogRef]);
    const showProp = modal ? 'showModal' : 'show';
    useEffect(() => dialogRef.current?.[open ? showProp : 'close'](), [open]); // Toggle open based on prop
    useEffect(() => {
        const dialog = dialogRef.current;
        const handleClosedby = (event) => {
            const { clientY: y, clientX: x, target } = event;
            if (event instanceof KeyboardEvent)
                return (closedby === 'none' &&
                    event.key === 'Escape' &&
                    event.preventDefault()); // Skip ESC-key if closedby="none"
            if (window.getSelection()?.toString())
                return; // Fix bug where if you select text spanning two divs it thinks you clicked outside
            if (dialog && target === dialog && closedby === 'any') {
                const { top, left, right, bottom } = dialog.getBoundingClientRect();
                const isInDialog = top <= y && y <= bottom && left <= x && x <= right;
                if (!isInDialog)
                    dialog?.close(); // Both <dialog> and ::backdrop is considered same event.target
            }
        };
        const handleAutoFocus = () => {
            const autofocus = dialog?.querySelector('[autofocus]');
            if (document.activeElement !== autofocus)
                autofocus?.focus();
        };
        dialog?.addEventListener('animationend', handleAutoFocus);
        dialog?.addEventListener('click', handleClosedby);
        dialog?.addEventListener('keydown', handleClosedby);
        return () => {
            dialog?.removeEventListener('animationend', handleAutoFocus);
            dialog?.removeEventListener('click', handleClosedby);
            dialog?.removeEventListener('keydown', handleClosedby);
        };
    }, [closedby]);
    /* handle closing */
    useEffect(() => {
        const handleClose = (event) => onClose?.(event);
        dialogRef.current?.addEventListener('close', handleClose);
        return () => dialogRef.current?.removeEventListener('close', handleClose);
    }, [onClose]);
    return (jsxs(Component, { className: cl('ds-dialog', className), ref: mergedRefs, "data-modal": modal, ...rest, children: [closeButton !== false && (jsx("form", { method: 'dialog', children: jsx(Button, { "aria-label": closeButton, autoFocus: true, "data-color": 'neutral', icon: true, name: 'close', type: 'submit', variant: 'tertiary' }) })), children] }));
});

export { Dialog };
