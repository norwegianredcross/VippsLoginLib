'use client';
'use strict';

var jsxRuntime = require('react/jsx-runtime');
var react$1 = require('@floating-ui/react');
var reactVirtual = require('@tanstack/react-virtual');
var cl = require('clsx/lite');
var react = require('react');
var useFormField = require('./useFormField/useFormField.js');
var ComboboxContext = require('./ComboboxContext.js');
var ComboboxIdContext = require('./ComboboxIdContext.js');
var Custom = require('./Custom.js');
var ComboboxError = require('./internal/ComboboxError.js');
var ComboboxInput = require('./internal/ComboboxInput.js');
var ComboboxLabel = require('./internal/ComboboxLabel.js');
var ComboboxNative = require('./internal/ComboboxNative.js');
var useCombobox = require('./useCombobox.js');
var useComboboxKeyboard = require('./useComboboxKeyboard.js');
var useFloatingCombobox = require('./useFloatingCombobox.js');
var utilities = require('./utilities.js');
var Spinner = require('../Spinner/Spinner.js');
var useDebounceCallback = require('../../utilities/hooks/useDebounceCallback/useDebounceCallback.js');
var omit = require('../../utilities/omit/omit.js');

/**
 * @deprecated Use `Suggestion` instead
 */
const ComboboxComponent = react.forwardRef(({ value, initialValue = [], onValueChange, label, hideLabel = false, description, multiple = false, disabled = false, readOnly = false, hideChips = false, clearButtonLabel = 'Fjern alt', hideClearButton = false, error, errorId, id, name, portal = true, htmlSize = 0, virtual = false, children, style, size = 'md', loading, loadingLabel = 'Laster...', filter, chipSrLabel = (option) => 'Slett ' + option.label, className, ...rest }, forwareddRef) => {
    const inputRef = react.useRef(null);
    const portalRef = react.useRef(null);
    const listRef = react.useRef([]);
    const [inputValue, setInputValue] = react.useState(rest.inputValue || '');
    react.useEffect(() => {
        if (typeof rest.inputValue === 'string') {
            setInputValue(rest.inputValue);
        }
    }, [rest.inputValue]);
    const { selectedOptions, options, restChildren, interactiveChildren, customIds, filteredOptionsChildren, filteredOptions, setSelectedOptions, } = useCombobox.useCombobox({
        children,
        inputValue,
        filter,
        multiple,
        initialValue,
    });
    const { open, setOpen, refs, floatingStyles, context, getReferenceProps, getFloatingProps, getItemProps, } = useFloatingCombobox.useFloatingCombobox({
        listRef,
    });
    const formFieldProps = useFormField.useFormField({
        disabled,
        error,
        errorId,
        size,
        description,
        id,
    }, 'combobox');
    // if value is set, set input value to the label of the value
    react.useEffect(() => {
        if (value && value.length > 0 && !multiple) {
            const option = options[utilities.prefix(value[0])];
            inputRef.current &&
                utilities.setReactInputValue(inputRef.current, option?.label || '');
        }
    }, [multiple, value, options]);
    react.useEffect(() => {
        if (value && Object.keys(options).length >= 0) {
            const updatedSelectedOptions = value.map((option) => {
                const value = options[utilities.prefix(option)];
                return value;
            });
            setSelectedOptions(updatedSelectedOptions.reduce((acc, value) => {
                acc[utilities.prefix(value.value)] = value;
                return acc;
            }, {}));
        }
    }, [multiple, value, options, setSelectedOptions]);
    // handle click on option, either select or deselect - Handles single or multiple
    const handleSelectOption = (args) => {
        const { option, clear, remove } = args;
        if (clear) {
            setSelectedOptions({});
            inputRef.current && utilities.setReactInputValue(inputRef.current, '');
            onValueChange?.([]);
            return;
        }
        if (!option)
            return;
        if (remove) {
            const newSelectedOptions = { ...selectedOptions };
            delete newSelectedOptions[utilities.prefix(option.value)];
            setSelectedOptions(newSelectedOptions);
            onValueChange?.(Object.keys(newSelectedOptions).map((key) => utilities.removePrefix(key)));
            return;
        }
        const newSelectedOptions = { ...selectedOptions };
        if (multiple) {
            if (newSelectedOptions[utilities.prefix(option.value)]) {
                delete newSelectedOptions[utilities.prefix(option.value)];
            }
            else {
                newSelectedOptions[utilities.prefix(option.value)] = option;
            }
            inputRef.current && utilities.setReactInputValue(inputRef.current, '');
            inputRef.current?.focus();
        }
        else {
            /* clear newSelectedOptions */
            for (const key of Object.keys(newSelectedOptions)) {
                delete newSelectedOptions[key];
            }
            newSelectedOptions[utilities.prefix(option.value)] = option;
            inputRef.current &&
                utilities.setReactInputValue(inputRef.current, option?.label || '');
            // move cursor to the end of the input
            setTimeout(() => {
                inputRef.current?.setSelectionRange(option?.label?.length || 0, option?.label?.length || 0);
            }, 0);
        }
        setSelectedOptions(newSelectedOptions);
        onValueChange?.(Object.keys(newSelectedOptions).map((key) => utilities.removePrefix(key)));
        !multiple && setOpen(false);
        refs.domReference.current?.focus();
    };
    const debouncedHandleSelectOption = useDebounceCallback.useDebounceCallback(handleSelectOption, 50);
    const handleKeyDown = useComboboxKeyboard.useComboboxKeyboard({
        filteredOptions,
        selectedOptions,
        readOnly: formFieldProps.readOnly || false,
        disabled: disabled,
        multiple,
        inputValue,
        options,
        open,
        interactiveChildren,
        setOpen,
        handleSelectOption: debouncedHandleSelectOption,
    });
    const rowVirtualizer = reactVirtual.useVirtualizer({
        count: Object.keys(filteredOptionsChildren).length,
        getScrollElement: () => (virtual ? refs.floating.current : null),
        estimateSize: () => 70,
        measureElement: (elem) => {
            return elem.getBoundingClientRect().height;
        },
        overscan: 7,
    });
    return (jsxRuntime.jsxs(ComboboxContext.ComboboxContext.Provider, { value: {
            size,
            options,
            selectedOptions,
            multiple,
            disabled,
            readOnly,
            open,
            inputRef,
            refs,
            inputValue,
            formFieldProps,
            htmlSize,
            clearButtonLabel,
            customIds,
            filteredOptions,
            setInputValue,
            setOpen,
            getReferenceProps,
            getItemProps,
            /* Recieves the value of the option, and searches for it in our values lookup */
            onOptionClick: (value) => {
                if (readOnly)
                    return;
                if (disabled)
                    return;
                const option = options[utilities.prefix(value)];
                debouncedHandleSelectOption({ option: option });
            },
            handleSelectOption: debouncedHandleSelectOption,
            chipSrLabel,
            listRef,
            forwareddRef,
            setListRef: (index, node) => {
                listRef.current[index] = node;
            },
        }, children: [jsxRuntime.jsxs("div", { className: cl('ds-combobox', `ds-combobox--${size}`, disabled && 'ds-combobox__disabled', className), style: style, ref: portalRef, children: [name && (jsxRuntime.jsx(ComboboxNative, { name: name, selectedOptions: selectedOptions, multiple: multiple })), jsxRuntime.jsx(ComboboxLabel, { label: label, description: description, size: size, readOnly: readOnly, hideLabel: hideLabel, formFieldProps: formFieldProps }), jsxRuntime.jsx(ComboboxInput, { ...omit.omit(['inputValue'], rest), hideClearButton: hideClearButton, listId: context.floatingId || '', error: error, hideChips: hideChips, handleKeyDown: handleKeyDown, "aria-busy": loading }), jsxRuntime.jsx(ComboboxError, { size: size, error: error, formFieldProps: formFieldProps })] }), open && (jsxRuntime.jsx(react$1.FloatingPortal, { root: portal ? null : portalRef, children: jsxRuntime.jsx(react$1.FloatingFocusManager, { context: context, initialFocus: -1, visuallyHiddenDismiss: true, children: jsxRuntime.jsxs("div", { "aria-labelledby": formFieldProps.inputProps.id, "aria-autocomplete": 'list', tabIndex: -1, ...getFloatingProps({
                            ref: refs.setFloating,
                            style: {
                                ...floatingStyles,
                            },
                        }), className: cl('ds-combobox__options-wrapper', `ds-combobox--${size}`), children: [virtual && (jsxRuntime.jsx("div", { style: {
                                    height: `${rowVirtualizer.getTotalSize()}px`,
                                    width: '100%',
                                    position: 'relative',
                                }, children: rowVirtualizer.getVirtualItems().map((virtualRow) => (jsxRuntime.jsx("div", { ref: rowVirtualizer.measureElement, "data-index": virtualRow.index, style: {
                                        position: 'absolute',
                                        top: 0,
                                        left: 0,
                                        width: '100%',
                                        transform: `translateY(${virtualRow.start}px)`,
                                    }, children: filteredOptionsChildren[virtualRow.index] }, virtualRow.index))) })), loading ? (jsxRuntime.jsxs(Custom.ComboboxCustom, { className: 'ds-combobox__loading', children: [jsxRuntime.jsx(Spinner.Spinner, { "aria-label": 'Laster', "data-size": 'sm' }), loadingLabel] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [restChildren, !virtual && filteredOptionsChildren] }))] }) }) }))] }));
});
const Combobox = react.forwardRef((props, ref) => (jsxRuntime.jsx(ComboboxIdContext.ComboboxIdProvider, { children: jsxRuntime.jsx(ComboboxComponent, { ...props, ref: ref }) })));
Combobox.displayName = 'Combobox';

exports.Combobox = Combobox;
exports.ComboboxComponent = ComboboxComponent;
