'use client';
import { jsx } from 'react/jsx-runtime';
import { useMergeRefs } from '@floating-ui/react';
import { Slot } from '@radix-ui/react-slot';
import { forwardRef } from 'react';
import { useRovingFocus } from './useRovingFocus.js';

/** Get the next focusable RovingFocusItem */
function getNextFocusableValue(items, value) {
    const currIndex = items.findIndex((item) => item.value === value);
    return items.at(currIndex === items.length - 1 ? 0 : currIndex + 1);
}
/** Get the previous focusable RovingFocusItem */
function getPrevFocusableValue(items, value) {
    const currIndex = items.findIndex((item) => item.value === value);
    return items.at(currIndex === 0 ? -1 : currIndex - 1);
}
const RovingFocusItem = forwardRef(({ value, asChild, ...rest }, ref) => {
    const Component = asChild ? Slot : 'div';
    const focusValue = value ?? (typeof rest.children === 'string' ? rest.children : '');
    const { getOrderedItems, getRovingProps, orientation } = useRovingFocus(focusValue);
    const rovingProps = getRovingProps({
        onKeyDown: (e) => {
            rest?.onKeyDown?.(e);
            const items = getOrderedItems();
            let nextItem;
            switch (orientation) {
                case 'horizontal':
                    if (e.key === 'ArrowRight') {
                        nextItem = getNextFocusableValue(items, focusValue);
                    }
                    if (e.key === 'ArrowLeft') {
                        nextItem = getPrevFocusableValue(items, focusValue);
                    }
                    break;
                case 'vertical':
                    if (e.key === 'ArrowDown') {
                        nextItem = getNextFocusableValue(items, focusValue);
                    }
                    if (e.key === 'ArrowUp') {
                        nextItem = getPrevFocusableValue(items, focusValue);
                    }
                    break;
                case 'ambiguous':
                    if (['ArrowRight', 'ArrowDown'].includes(e.key)) {
                        nextItem = getNextFocusableValue(items, focusValue);
                    }
                    if (['ArrowLeft', 'ArrowUp'].includes(e.key)) {
                        nextItem = getPrevFocusableValue(items, focusValue);
                    }
            }
            if (e.key === 'Home') {
                nextItem = items[0];
            }
            if (e.key === 'End') {
                nextItem = items[items.length - 1];
            }
            if (nextItem) {
                e.preventDefault();
                nextItem.element.focus();
            }
        },
    });
    const mergedRefs = useMergeRefs([ref, rovingProps.ref]);
    return (jsx(Component, { ...rest, ...rovingProps, ref: mergedRefs, children: rest.children }));
});

export { RovingFocusItem, getNextFocusableValue, getPrevFocusableValue };
