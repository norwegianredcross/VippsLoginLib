"use client";
import {
  require_jsx_runtime
} from "./chunk-LH2JL3P5.js";
import {
  require_react_dom
} from "./chunk-XHCDW3LY.js";
import {
  Checkmark_default,
  ChevronDown_default,
  ChevronUp_default,
  PadlockLockedFill_default,
  XMark_default
} from "./chunk-JZ7LLSBB.js";
import {
  __toESM,
  require_react
} from "./chunk-AMZ7Q62Q.js";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Avatar/Avatar.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var Slot = React2.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React2.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React2.Children.count(newElement) > 1)
          return React2.Children.only(null);
        return React2.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React2.isValidElement(newElement) ? React2.cloneElement(newElement, void 0, newChildren) : null });
  }
  return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React2.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React2.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    const props2 = mergeProps(slotProps, children.props);
    if (children.type !== React2.Fragment) {
      props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
    }
    return React2.cloneElement(children, props2);
  }
  return React2.Children.count(children) > 1 ? React2.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
};
function isSlottable(child) {
  return React2.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a4, _b;
  let getter = (_a4 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a4.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/clsx/dist/lite.mjs
function clsx() {
  for (var t, r = 0, e = "", n = arguments.length; r < n; r++)
    (t = arguments[r]) && "string" == typeof t && (e += (e && " ") + t);
  return e;
}
var lite_default = clsx;

// node_modules/@digdir/designsystemet-react/dist/esm/components/Avatar/Avatar.js
var import_react = __toESM(require_react(), 1);
var Avatar = (0, import_react.forwardRef)(function Avatar2({ "aria-label": ariaLabel, variant = "circle", className, children, initials, ...rest }, ref) {
  const useSlot = children && typeof children !== "string";
  const Component = useSlot ? Slot : import_react.Fragment;
  return (0, import_jsx_runtime2.jsx)("span", { ref, className: lite_default("ds-avatar", className), "data-variant": variant, "data-initials": initials, role: "img", "aria-label": ariaLabel, ...rest, children: (0, import_jsx_runtime2.jsx)(Component, { ...useSlot ? { "aria-hidden": true } : {}, children }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Button/Button.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Spinner/Spinner.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var React4 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  while (((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version: version3
      } = _ref;
      return brand + "/" + version3;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  if (isAndroid() && event.pointerType) {
    return event.type === "click" && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  if (isJSDOM())
    return false;
  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333â€¢ for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re = /android/i;
  return re.test(getPlatform()) || re.test(getUserAgent());
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function isEventTargetWithin(event, node) {
  if (node == null) {
    return false;
  }
  if ("composedPath" in event) {
    return event.composedPath().includes(node);
  }
  const e = event;
  return e.target != null && node.contains(e.target);
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
var TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function isTypeableCombobox(element) {
  if (!element)
    return false;
  return element.getAttribute("role") === "combobox" && isTypeableElement(element);
}

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var ReactDOM2 = __toESM(require_react_dom(), 1);

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId2;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId2);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId2 = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React3 = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var index = typeof document !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React3.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React3.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React3.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React3.useState(null);
  const [_floating, _setFloating] = React3.useState(null);
  const setReference = React3.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React3.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React3.useRef(null);
  const floatingRef = React3.useRef(null);
  const dataRef = React3.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React3.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React3.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React3.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React3.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React3.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React3.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
function useMergeRefs(refs) {
  return React4.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
var SafeReact = {
  ...React4
};
var useInsertionEffect = SafeReact.useInsertionEffect;
var useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React4.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React4.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
function isDifferentRow(index3, cols, prevRow) {
  return Math.floor(index3 / cols) !== prevRow;
}
function isIndexOutOfBounds(listRef, index3) {
  return index3 < 0 || index3 >= listRef.current.length;
}
function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}
function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list = listRef.current;
  let index3 = startingIndex;
  do {
    index3 += decrement ? -amount : amount;
  } while (index3 >= 0 && index3 <= list.length - 1 && isDisabled(list, index3, disabledIndices));
  return index3;
}
function getGridNavigatedIndex(elementsRef, _ref) {
  let {
    event,
    orientation,
    loop,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset4 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset4 : offset4 - cols;
        }
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === ARROW_RIGHT) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === ARROW_LEFT) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function buildCellMap(sizes, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes.forEach((_ref2, index3) => {
    let {
      width,
      height
    } = _ref2;
    if (width > cols) {
      if (true) {
        throw new Error("[Floating UI]: Invalid grid - item width at index " + index3 + " is greater than grid columns");
      }
    }
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i = 0; i < width; i++) {
        for (let j = 0; j < height; j++) {
          targetCells.push(startIndex + i + j * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index3;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getCellIndexOfCorner(index3, sizes, cellMap, cols, corner) {
  if (index3 === -1)
    return -1;
  const firstCellIndex = cellMap.indexOf(index3);
  const sizeItem = sizes[index3];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index3);
  }
}
function getCellIndices(indices, cellMap) {
  return cellMap.flatMap((index3, cellIndex) => indices.includes(index3) ? [cellIndex] : []);
}
function isDisabled(list, index3, disabledIndices) {
  if (disabledIndices) {
    return disabledIndices.includes(index3);
  }
  const element = list[index3];
  return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}
var rafId = 0;
function enqueueFocus(el, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    preventScroll = false,
    cancelPrevious = true,
    sync = false
  } = options;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el == null ? void 0 : el.focus({
    preventScroll
  });
  if (sync) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}
var index2 = typeof document !== "undefined" ? import_react3.useLayoutEffect : import_react3.useEffect;
function sortByDocumentPosition(a, b) {
  const position = a.compareDocumentPosition(b);
  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
function areMapsEqual(map1, map2) {
  if (map1.size !== map2.size) {
    return false;
  }
  for (const [key, value] of map1.entries()) {
    if (value !== map2.get(key)) {
      return false;
    }
  }
  return true;
}
var FloatingListContext = React4.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function FloatingList(props) {
  const {
    children,
    elementsRef,
    labelsRef
  } = props;
  const [map, setMap] = React4.useState(() => /* @__PURE__ */ new Map());
  const register = React4.useCallback((node) => {
    setMap((prevMap) => new Map(prevMap).set(node, null));
  }, []);
  const unregister = React4.useCallback((node) => {
    setMap((prevMap) => {
      const map2 = new Map(prevMap);
      map2.delete(node);
      return map2;
    });
  }, []);
  index2(() => {
    const newMap = new Map(map);
    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);
    nodes.forEach((node, index3) => {
      newMap.set(node, index3);
    });
    if (!areMapsEqual(map, newMap)) {
      setMap(newMap);
    }
  }, [map]);
  return React4.createElement(FloatingListContext.Provider, {
    value: React4.useMemo(() => ({
      register,
      unregister,
      map,
      elementsRef,
      labelsRef
    }), [register, unregister, map, elementsRef, labelsRef])
  }, children);
}
function useListItem(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    label: label2
  } = props;
  const {
    register,
    unregister,
    map,
    elementsRef,
    labelsRef
  } = React4.useContext(FloatingListContext);
  const [index$1, setIndex] = React4.useState(null);
  const componentRef = React4.useRef(null);
  const ref = React4.useCallback((node) => {
    componentRef.current = node;
    if (index$1 !== null) {
      elementsRef.current[index$1] = node;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label2 !== void 0;
        labelsRef.current[index$1] = isLabelDefined ? label2 : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index$1, elementsRef, labelsRef, label2]);
  index2(() => {
    const node = componentRef.current;
    if (node) {
      register(node);
      return () => {
        unregister(node);
      };
    }
  }, [register, unregister]);
  index2(() => {
    const index3 = componentRef.current ? map.get(componentRef.current) : null;
    if (index3 != null) {
      setIndex(index3);
    }
  }, [map]);
  return React4.useMemo(() => ({
    ref,
    index: index$1 == null ? -1 : index$1
  }), [index$1, ref]);
}
function renderJsx(render3, computedProps) {
  if (typeof render3 === "function") {
    return render3(computedProps);
  }
  if (render3) {
    return React4.cloneElement(render3, computedProps);
  }
  return React4.createElement("div", computedProps);
}
var CompositeContext = React4.createContext({
  activeIndex: 0,
  onNavigate: () => {
  }
});
var horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
var verticalKeys = [ARROW_UP, ARROW_DOWN];
var allKeys = [...horizontalKeys, ...verticalKeys];
var Composite = React4.forwardRef(function Composite2(props, forwardedRef) {
  const {
    render: render3,
    orientation = "both",
    loop = true,
    cols = 1,
    disabledIndices,
    activeIndex: externalActiveIndex,
    onNavigate: externalSetActiveIndex,
    itemSizes,
    dense = false,
    ...domProps
  } = props;
  const [internalActiveIndex, internalSetActiveIndex] = React4.useState(0);
  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
  const elementsRef = React4.useRef([]);
  const renderElementProps = render3 && typeof render3 !== "function" ? render3.props : {};
  const contextValue = React4.useMemo(() => ({
    activeIndex,
    onNavigate
  }), [activeIndex, onNavigate]);
  const isGrid = cols > 1;
  function handleKeyDown(event) {
    if (!allKeys.includes(event.key))
      return;
    let nextIndex = activeIndex;
    const minIndex = getMinIndex(elementsRef, disabledIndices);
    const maxIndex = getMaxIndex(elementsRef, disabledIndices);
    if (isGrid) {
      const sizes = itemSizes || Array.from({
        length: elementsRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = buildCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index3) => index3 != null && !isDisabled(elementsRef.current, index3, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index3, cellIndex) => index3 != null && !isDisabled(elementsRef.current, index3, disabledIndices) ? cellIndex : foundIndex, -1);
      const maybeNextIndex = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getCellIndices([...disabledIndices || elementsRef.current.map((_, index3) => isDisabled(elementsRef.current, index3) ? index3 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getCellIndexOfCorner(
          activeIndex > maxIndex ? minIndex : activeIndex,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction we're
          // moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN ? "bl" : event.key === ARROW_RIGHT ? "tr" : "tl"
        )
      })];
      if (maybeNextIndex != null) {
        nextIndex = maybeNextIndex;
      }
    }
    const toEndKeys = {
      horizontal: [ARROW_RIGHT],
      vertical: [ARROW_DOWN],
      both: [ARROW_RIGHT, ARROW_DOWN]
    }[orientation];
    const toStartKeys = {
      horizontal: [ARROW_LEFT],
      vertical: [ARROW_UP],
      both: [ARROW_LEFT, ARROW_UP]
    }[orientation];
    const preventedKeys = isGrid ? allKeys : {
      horizontal: horizontalKeys,
      vertical: verticalKeys,
      both: allKeys
    }[orientation];
    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
        nextIndex = minIndex;
      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: nextIndex,
          decrement: toStartKeys.includes(event.key),
          disabledIndices
        });
      }
    }
    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {
      event.stopPropagation();
      if (preventedKeys.includes(event.key)) {
        event.preventDefault();
      }
      onNavigate(nextIndex);
      queueMicrotask(() => {
        enqueueFocus(elementsRef.current[nextIndex]);
      });
    }
  }
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: forwardedRef,
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    onKeyDown(e) {
      domProps.onKeyDown == null || domProps.onKeyDown(e);
      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);
      handleKeyDown(e);
    }
  };
  return React4.createElement(CompositeContext.Provider, {
    value: contextValue
  }, React4.createElement(FloatingList, {
    elementsRef
  }, renderJsx(render3, computedProps)));
});
var CompositeItem = React4.forwardRef(function CompositeItem2(props, forwardedRef) {
  const {
    render: render3,
    ...domProps
  } = props;
  const renderElementProps = render3 && typeof render3 !== "function" ? render3.props : {};
  const {
    activeIndex,
    onNavigate
  } = React4.useContext(CompositeContext);
  const {
    ref,
    index: index3
  } = useListItem();
  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
  const isActive = activeIndex === index3;
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: mergedRef,
    tabIndex: isActive ? 0 : -1,
    "data-active": isActive ? "" : void 0,
    onFocus(e) {
      domProps.onFocus == null || domProps.onFocus(e);
      renderElementProps.onFocus == null || renderElementProps.onFocus(e);
      onNavigate(index3);
    }
  };
  return renderJsx(render3, computedProps);
});
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var serverHandoffComplete = false;
var count = 0;
var genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id3, setId] = React4.useState(() => serverHandoffComplete ? genId() : void 0);
  index2(() => {
    if (id3 == null) {
      setId(genId());
    }
  }, []);
  React4.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id3;
}
var useReactId = SafeReact.useId;
var useId = useReactId || useFloatingId;
var devMessageSet;
if (true) {
  devMessageSet = /* @__PURE__ */ new Set();
}
function warn() {
  var _devMessageSet;
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
    console.warn(message);
  }
}
function error() {
  var _devMessageSet3;
  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    messages[_key2] = arguments[_key2];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
    console.error(message);
  }
}
var FloatingArrow = React4.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow4,
        shift: shift4
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d,
    style: {
      transform,
      ...restStyle
    } = {},
    ...rest
  } = props;
  if (true) {
    if (!ref) {
      warn("The `ref` prop is required for `FloatingArrow`.");
    }
  }
  const clipPathId = useId();
  const [isRTL2, setIsRTL] = React4.useState(false);
  index2(() => {
    if (!floating)
      return;
    const isRTL3 = getComputedStyle2(floating).direction === "rtl";
    if (isRTL3) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift4 != null && shift4.x || !isVerticalSide && shift4 != null && shift4.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow4 == null ? void 0 : arrow4.x) != null ? computedStaticOffset || arrow4.x : "";
  const arrowY = (arrow4 == null ? void 0 : arrow4.y) != null ? computedStaticOffset || arrow4.y : "";
  const dValue = d || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return React4.createElement("svg", _extends({}, rest, {
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: "" + rotation + (transform != null ? transform : ""),
      ...restStyle
    }
  }), computedStrokeWidth > 0 && React4.createElement("path", {
    clipPath: "url(#" + clipPathId + ")",
    fill: "none",
    stroke,
    strokeWidth: computedStrokeWidth + (d ? 0 : 1),
    d: dValue
  }), React4.createElement("path", {
    stroke: computedStrokeWidth && !d ? rest.fill : "none",
    d: dValue
  }), React4.createElement("clipPath", {
    id: clipPathId
  }, React4.createElement("rect", {
    x: -halfStrokeWidth,
    y: halfStrokeWidth * (isCustomShape ? -1 : 1),
    width: width + computedStrokeWidth,
    height: width
  })));
});
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l) => l !== listener)) || []);
    }
  };
}
var FloatingNodeContext = React4.createContext(null);
var FloatingTreeContext = React4.createContext(null);
var useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React4.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
var useFloatingTree = () => React4.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function useLatestRef2(value) {
  const ref = (0, import_react3.useRef)(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
var safePolygonIdentifier = createAttribute("safe-polygon");
var NOOP = () => {
};
var FloatingDelayGroupContext = React4.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: false
});
function getAncestors(nodes, id3) {
  var _nodes$find;
  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find((node) => node.id === id3)) == null ? void 0 : _nodes$find.parentId;
  while (currentParentId) {
    const currentNode = nodes.find((node) => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}
function getChildren(nodes, id3) {
  let allChildren = nodes.filter((node) => {
    var _node$context;
    return node.parentId === id3 && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  });
  let currentChildren = allChildren;
  while (currentChildren.length) {
    currentChildren = nodes.filter((node) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n) => {
        var _node$context2;
        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    });
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}
function getDeepestNode(nodes, id3) {
  let deepestNodeId;
  let maxDepth = -1;
  function findDeepest(nodeId, depth) {
    if (depth > maxDepth) {
      deepestNodeId = nodeId;
      maxDepth = depth;
    }
    const children = getChildren(nodes, nodeId);
    children.forEach((child) => {
      findDeepest(child.id, depth + 1);
    });
  }
  findDeepest(id3, 0);
  return nodes.find((node) => node.id === deepestNodeId);
}
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
var markerMap = {};
var lockCount = 0;
var supportsInert = () => typeof HTMLElement !== "undefined" && "inert" in HTMLElement.prototype;
var unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
var correctElements = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) {
    return target;
  }
  const correctedTarget = unwrapHost(target);
  if (parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  return null;
}).filter((x) => x != null);
function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
  const markerName = "data-floating-ui-inert";
  const controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null;
  const avoidElements = correctElements(body, uncorrectedAvoidElements);
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(avoidElements);
  const hiddenElements = [];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  avoidElements.forEach(keep);
  deep(body);
  elementsToKeep.clear();
  function keep(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    el.parentNode && keep(el.parentNode);
  }
  function deep(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    [].forEach.call(parent.children, (node) => {
      if (getNodeName(node) === "script")
        return;
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        const attr5 = controlAttribute ? node.getAttribute(controlAttribute) : null;
        const alreadyHidden = attr5 !== null && attr5 !== "false";
        const counterValue = (counterMap.get(node) || 0) + 1;
        const markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenElements.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledElementsSet.add(node);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "");
        }
        if (!alreadyHidden && controlAttribute) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  }
  lockCount++;
  return () => {
    hiddenElements.forEach((element) => {
      const counterValue = (counterMap.get(element) || 0) - 1;
      const markerValue = (markerCounter.get(element) || 0) - 1;
      counterMap.set(element, counterValue);
      markerCounter.set(element, markerValue);
      if (!counterValue) {
        if (!uncontrolledElementsSet.has(element) && controlAttribute) {
          element.removeAttribute(controlAttribute);
        }
        uncontrolledElementsSet.delete(element);
      }
      if (!markerValue) {
        element.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
      markerMap = {};
    }
  };
}
function markOthers(avoidElements, ariaHidden, inert) {
  if (ariaHidden === void 0) {
    ariaHidden = false;
  }
  if (inert === void 0) {
    inert = false;
  }
  const body = getDocument(avoidElements[0]).body;
  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll("[aria-live]"))), body, ariaHidden, inert);
}
var getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container, direction) {
  const allTabbable = tabbable(container, getTabbableOptions());
  if (direction === "prev") {
    allTabbable.reverse();
  }
  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getNextTabbable() {
  return getTabbableIn(document.body, "next");
}
function getPreviousTabbable() {
  return getTabbableIn(document.body, "prev");
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  const tabbableElements = tabbable(container, getTabbableOptions());
  tabbableElements.forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "";
    element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container) {
  const elements = container.querySelectorAll("[data-tabindex]");
  elements.forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  });
}
function getClosestTabbableElement(tabbableElements, element, floating) {
  const elementIndex = tabbableElements.indexOf(element);
  function traverseTabbableElements(next2) {
    const attr5 = createAttribute("focus-guard");
    let index3 = elementIndex + (next2 ? 1 : 0);
    let currentElement = tabbableElements[index3];
    while (currentElement && (!currentElement.isConnected || currentElement.hasAttribute(attr5) || contains(floating, currentElement))) {
      if (next2) {
        index3++;
      } else {
        index3--;
      }
      currentElement = tabbableElements[index3];
    }
    return currentElement;
  }
  const next = traverseTabbableElements(true);
  if (next) {
    return next;
  }
  return traverseTabbableElements(false);
}
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var timeoutId;
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    event.target;
    clearTimeout(timeoutId);
  }
}
var FocusGuard = React4.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = React4.useState();
  index2(() => {
    if (isSafari()) {
      setRole("button");
    }
    document.addEventListener("keydown", setActiveElementOnTab);
    return () => {
      document.removeEventListener("keydown", setActiveElementOnTab);
    };
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return React4.createElement("span", _extends({}, props, restProps));
});
var PortalContext = React4.createContext(null);
var attr = createAttribute("portal");
function useFloatingPortalNode(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    id: id3,
    root
  } = props;
  const uniqueId = useId();
  const portalContext = usePortalContext();
  const [portalNode, setPortalNode] = React4.useState(null);
  const portalNodeRef = React4.useRef(null);
  index2(() => {
    return () => {
      portalNode == null || portalNode.remove();
      queueMicrotask(() => {
        portalNodeRef.current = null;
      });
    };
  }, [portalNode]);
  index2(() => {
    if (!uniqueId)
      return;
    if (portalNodeRef.current)
      return;
    const existingIdRoot = id3 ? document.getElementById(id3) : null;
    if (!existingIdRoot)
      return;
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    existingIdRoot.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id3, uniqueId]);
  index2(() => {
    if (!uniqueId)
      return;
    if (portalNodeRef.current)
      return;
    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
    if (container && !isElement(container))
      container = container.current;
    container = container || document.body;
    let idWrapper = null;
    if (id3) {
      idWrapper = document.createElement("div");
      idWrapper.id = id3;
      container.appendChild(idWrapper);
    }
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    container = idWrapper || container;
    container.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id3, root, uniqueId, portalContext]);
  return portalNode;
}
function FloatingPortal(props) {
  const {
    children,
    id: id3,
    root = null,
    preserveTabOrder = true
  } = props;
  const portalNode = useFloatingPortalNode({
    id: id3,
    root
  });
  const [focusManagerState, setFocusManagerState] = React4.useState(null);
  const beforeOutsideRef = React4.useRef(null);
  const afterOutsideRef = React4.useRef(null);
  const beforeInsideRef = React4.useRef(null);
  const afterInsideRef = React4.useRef(null);
  const modal = focusManagerState == null ? void 0 : focusManagerState.modal;
  const open = focusManagerState == null ? void 0 : focusManagerState.open;
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root || portalNode)
  );
  React4.useEffect(() => {
    if (!portalNode || !preserveTabOrder || modal) {
      return;
    }
    function onFocus(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus, true);
    portalNode.addEventListener("focusout", onFocus, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus, true);
      portalNode.removeEventListener("focusout", onFocus, true);
    };
  }, [portalNode, preserveTabOrder, modal]);
  React4.useEffect(() => {
    if (!portalNode)
      return;
    if (open)
      return;
    enableFocusInside(portalNode);
  }, [open, portalNode]);
  return React4.createElement(PortalContext.Provider, {
    value: React4.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode])
  }, shouldRenderGuards && portalNode && React4.createElement(FocusGuard, {
    "data-type": "outside",
    ref: beforeOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _beforeInsideRef$curr;
        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();
      } else {
        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        prevTabbable == null || prevTabbable.focus();
      }
    }
  }), shouldRenderGuards && portalNode && React4.createElement("span", {
    "aria-owns": portalNode.id,
    style: HIDDEN_STYLES
  }), portalNode && ReactDOM2.createPortal(children, portalNode), shouldRenderGuards && portalNode && React4.createElement(FocusGuard, {
    "data-type": "outside",
    ref: afterOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _afterInsideRef$curre;
        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();
      } else {
        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        nextTabbable == null || nextTabbable.focus();
        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, "focus-out"));
      }
    }
  }));
}
var usePortalContext = () => React4.useContext(PortalContext);
var FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function getFloatingFocusElement(floatingElement) {
  if (!floatingElement) {
    return null;
  }
  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE + "]") || floatingElement;
}
var LIST_LIMIT = 20;
var previouslyFocusedElements = [];
function addPreviouslyFocusedElement(element) {
  previouslyFocusedElements = previouslyFocusedElements.filter((el) => el.isConnected);
  let tabbableEl = element;
  if (!tabbableEl || getNodeName(tabbableEl) === "body")
    return;
  if (!isTabbable(tabbableEl, getTabbableOptions())) {
    const tabbableChild = tabbable(tabbableEl, getTabbableOptions())[0];
    if (tabbableChild) {
      tabbableEl = tabbableChild;
    }
  }
  previouslyFocusedElements.push(tabbableEl);
  if (previouslyFocusedElements.length > LIST_LIMIT) {
    previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
  }
}
function getPreviouslyFocusedElement() {
  return previouslyFocusedElements.slice().reverse().find((el) => el.isConnected);
}
var VisuallyHiddenDismiss = React4.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return React4.createElement("button", _extends({}, props, {
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
function FloatingFocusManager(props) {
  const {
    context,
    children,
    disabled = false,
    order = ["content"],
    guards: _guards = true,
    initialFocus = 0,
    returnFocus = true,
    restoreFocus = false,
    modal = true,
    visuallyHiddenDismiss = false,
    closeOnFocusOut = true
  } = props;
  const {
    open,
    refs,
    nodeId,
    onOpenChange,
    events: events4,
    dataRef,
    floatingId,
    elements: {
      domReference,
      floating
    }
  } = context;
  const ignoreInitialFocus = typeof initialFocus === "number" && initialFocus < 0;
  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;
  const guards = supportsInert() ? _guards : true;
  const orderRef = useLatestRef2(order);
  const initialFocusRef = useLatestRef2(initialFocus);
  const returnFocusRef = useLatestRef2(returnFocus);
  const tree = useFloatingTree();
  const portalContext = usePortalContext();
  const startDismissButtonRef = React4.useRef(null);
  const endDismissButtonRef = React4.useRef(null);
  const preventReturnFocusRef = React4.useRef(false);
  const isPointerDownRef = React4.useRef(false);
  const tabbableIndexRef = React4.useRef(-1);
  const isInsidePortal = portalContext != null;
  const floatingFocusElement = getFloatingFocusElement(floating);
  const getTabbableContent = useEffectEvent(function(container) {
    if (container === void 0) {
      container = floatingFocusElement;
    }
    return container ? tabbable(container, getTabbableOptions()) : [];
  });
  const getTabbableElements = useEffectEvent((container) => {
    const content = getTabbableContent(container);
    return orderRef.current.map((type) => {
      if (domReference && type === "reference") {
        return domReference;
      }
      if (floatingFocusElement && type === "floating") {
        return floatingFocusElement;
      }
      return content;
    }).filter(Boolean).flat();
  });
  React4.useEffect(() => {
    preventReturnFocusRef.current = false;
  }, [disabled]);
  React4.useEffect(() => {
    if (disabled)
      return;
    if (!modal)
      return;
    function onKeyDown3(event) {
      if (event.key === "Tab") {
        if (contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        const target = getTarget(event);
        if (orderRef.current[0] === "reference" && target === domReference) {
          stopEvent(event);
          if (event.shiftKey) {
            enqueueFocus(els[els.length - 1]);
          } else {
            enqueueFocus(els[1]);
          }
        }
        if (orderRef.current[1] === "floating" && target === floatingFocusElement && event.shiftKey) {
          stopEvent(event);
          enqueueFocus(els[0]);
        }
      }
    }
    const doc = getDocument(floatingFocusElement);
    doc.addEventListener("keydown", onKeyDown3);
    return () => {
      doc.removeEventListener("keydown", onKeyDown3);
    };
  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);
  React4.useEffect(() => {
    if (disabled)
      return;
    if (!floating)
      return;
    function handleFocusIn(event) {
      const target = getTarget(event);
      const tabbableContent = getTabbableContent();
      const tabbableIndex = tabbableContent.indexOf(target);
      if (tabbableIndex !== -1) {
        tabbableIndexRef.current = tabbableIndex;
      }
    }
    floating.addEventListener("focusin", handleFocusIn);
    return () => {
      floating.removeEventListener("focusin", handleFocusIn);
    };
  }, [disabled, floating, getTabbableContent]);
  React4.useEffect(() => {
    if (disabled)
      return;
    if (!closeOnFocusOut)
      return;
    function handlePointerDown() {
      isPointerDownRef.current = true;
      setTimeout(() => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      queueMicrotask(() => {
        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context, _node$context2;
          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
        }) || getAncestors(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context3, _node$context4;
          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;
        })));
        if (restoreFocus && movedToUnrelatedNode && activeElement(getDocument(floatingFocusElement)) === getDocument(floatingFocusElement).body) {
          if (isHTMLElement(floatingFocusElement)) {
            floatingFocusElement.focus();
          }
          const prevTabbableIndex = tabbableIndexRef.current;
          const tabbableContent = getTabbableContent();
          const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;
          if (isHTMLElement(nodeToFocus)) {
            nodeToFocus.focus();
          }
        }
        if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        relatedTarget !== getPreviouslyFocusedElement()) {
          preventReturnFocusRef.current = true;
          onOpenChange(false, event, "focus-out");
        }
      });
    }
    if (floating && isHTMLElement(domReference)) {
      domReference.addEventListener("focusout", handleFocusOutside);
      domReference.addEventListener("pointerdown", handlePointerDown);
      floating.addEventListener("focusout", handleFocusOutside);
      return () => {
        domReference.removeEventListener("focusout", handleFocusOutside);
        domReference.removeEventListener("pointerdown", handlePointerDown);
        floating.removeEventListener("focusout", handleFocusOutside);
      };
    }
  }, [disabled, domReference, floating, floatingFocusElement, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox]);
  React4.useEffect(() => {
    var _portalContext$portal;
    if (disabled)
      return;
    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
    if (floating) {
      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes("reference") || isUntrappedTypeableCombobox ? domReference : null].filter((x) => x != null);
      const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);
      return () => {
        cleanup();
      };
    }
  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);
  index2(() => {
    if (disabled || !isHTMLElement(floatingFocusElement))
      return;
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floatingFocusElement);
      const initialFocusValue = initialFocusRef.current;
      const elToFocus = (typeof initialFocusValue === "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;
      const focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);
      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {
        enqueueFocus(elToFocus, {
          preventScroll: elToFocus === floatingFocusElement
        });
      }
    });
  }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]);
  index2(() => {
    if (disabled || !floatingFocusElement)
      return;
    let preventReturnFocusScroll = false;
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    const contextData = dataRef.current;
    let openEvent = contextData.openEvent;
    const domReference2 = refs.domReference.current;
    addPreviouslyFocusedElement(previouslyFocusedElement);
    function onOpenChange2(_ref) {
      let {
        open: open2,
        reason,
        event,
        nested
      } = _ref;
      if (open2) {
        openEvent = event;
      }
      if (reason === "escape-key" && refs.domReference.current) {
        addPreviouslyFocusedElement(refs.domReference.current);
      }
      if (reason === "hover" && event.type === "mouseleave") {
        preventReturnFocusRef.current = true;
      }
      if (reason !== "outside-press")
        return;
      if (nested) {
        preventReturnFocusRef.current = false;
        preventReturnFocusScroll = true;
      } else {
        preventReturnFocusRef.current = !(isVirtualClick(event) || isVirtualPointerEvent(event));
      }
    }
    events4.on("openchange", onOpenChange2);
    return () => {
      events4.off("openchange", onOpenChange2);
      const activeEl = activeElement(doc);
      const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node) => {
        var _node$context5;
        return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);
      });
      const shouldFocusReference = isFocusInsideFloatingTree || openEvent && ["click", "mousedown"].includes(openEvent.type);
      if (shouldFocusReference && refs.domReference.current) {
        addPreviouslyFocusedElement(refs.domReference.current);
      }
      const returnContextElement = domReference2 || previouslyFocusedElement;
      const tabbableElements = tabbable(getDocument(returnContextElement).body, getTabbableOptions());
      queueMicrotask(() => {
        let returnElement = getPreviouslyFocusedElement();
        if (!returnElement && isHTMLElement(returnContextElement) && floating) {
          returnElement = getClosestTabbableElement(tabbableElements, returnContextElement, floating);
        }
        if (
          // eslint-disable-next-line react-hooks/exhaustive-deps
          returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && // If the focus moved somewhere else after mount, avoid returning focus
          // since it likely entered a different element which should be
          // respected: https://github.com/floating-ui/floating-ui/issues/2607
          (returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)
        ) {
          returnElement.focus({
            preventScroll: preventReturnFocusScroll
          });
        }
      });
    };
  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, refs, events4, tree, nodeId]);
  index2(() => {
    if (disabled)
      return;
    if (!portalContext)
      return;
    portalContext.setFocusManagerState({
      modal,
      closeOnFocusOut,
      open,
      onOpenChange,
      refs
    });
    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);
  index2(() => {
    if (disabled)
      return;
    if (!floatingFocusElement)
      return;
    if (typeof MutationObserver !== "function")
      return;
    if (ignoreInitialFocus)
      return;
    const handleMutation = () => {
      const tabIndex = floatingFocusElement.getAttribute("tabindex");
      const tabbableContent = getTabbableContent();
      const activeEl = activeElement(getDocument(floating));
      const tabbableIndex = tabbableContent.indexOf(activeEl);
      if (tabbableIndex !== -1) {
        tabbableIndexRef.current = tabbableIndex;
      }
      if (orderRef.current.includes("floating") || activeEl !== refs.domReference.current && tabbableContent.length === 0) {
        if (tabIndex !== "0") {
          floatingFocusElement.setAttribute("tabindex", "0");
        }
      } else if (tabIndex !== "-1") {
        floatingFocusElement.setAttribute("tabindex", "-1");
      }
    };
    handleMutation();
    const observer = new MutationObserver(handleMutation);
    observer.observe(floatingFocusElement, {
      childList: true,
      subtree: true,
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [disabled, floating, floatingFocusElement, refs, orderRef, getTabbableContent, ignoreInitialFocus]);
  function renderDismissButton(location) {
    if (disabled || !visuallyHiddenDismiss || !modal) {
      return null;
    }
    return React4.createElement(VisuallyHiddenDismiss, {
      ref: location === "start" ? startDismissButtonRef : endDismissButtonRef,
      onClick: (event) => onOpenChange(false, event.nativeEvent)
    }, typeof visuallyHiddenDismiss === "string" ? visuallyHiddenDismiss : "Dismiss");
  }
  const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);
  return React4.createElement(React4.Fragment, null, shouldRenderGuards && React4.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,
    onFocus: (event) => {
      if (modal) {
        const els = getTabbableElements();
        enqueueFocus(order[0] === "reference" ? els[0] : els[els.length - 1]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        preventReturnFocusRef.current = false;
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const nextTabbable = getNextTabbable() || domReference;
          nextTabbable == null || nextTabbable.focus();
        } else {
          var _portalContext$before;
          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();
        }
      }
    }
  }), !isUntrappedTypeableCombobox && renderDismissButton("start"), children, renderDismissButton("end"), shouldRenderGuards && React4.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,
    onFocus: (event) => {
      if (modal) {
        enqueueFocus(getTabbableElements()[0]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        if (closeOnFocusOut) {
          preventReturnFocusRef.current = true;
        }
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const prevTabbable = getPreviousTabbable() || domReference;
          prevTabbable == null || prevTabbable.focus();
        } else {
          var _portalContext$afterO;
          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();
        }
      }
    }
  }));
}
var activeLocks = /* @__PURE__ */ new Set();
var FloatingOverlay = React4.forwardRef(function FloatingOverlay2(props, ref) {
  const {
    lockScroll = false,
    ...rest
  } = props;
  const lockId = useId();
  index2(() => {
    if (!lockScroll)
      return;
    activeLocks.add(lockId);
    const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());
    const bodyStyle = document.body.style;
    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;
    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;
    bodyStyle.overflow = "hidden";
    if (scrollbarWidth) {
      bodyStyle[paddingProp] = scrollbarWidth + "px";
    }
    if (isIOS) {
      var _window$visualViewpor, _window$visualViewpor2;
      const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
      const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
      Object.assign(bodyStyle, {
        position: "fixed",
        top: -(scrollY - Math.floor(offsetTop)) + "px",
        left: -(scrollX - Math.floor(offsetLeft)) + "px",
        right: "0"
      });
    }
    return () => {
      activeLocks.delete(lockId);
      if (activeLocks.size === 0) {
        Object.assign(bodyStyle, {
          overflow: "",
          [paddingProp]: ""
        });
        if (isIOS) {
          Object.assign(bodyStyle, {
            position: "",
            top: "",
            left: "",
            right: ""
          });
          window.scrollTo(scrollX, scrollY);
        }
      }
    };
  }, [lockId, lockScroll]);
  return React4.createElement("div", _extends({
    ref
  }, rest, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});
var bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
};
var captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
};
var normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
    outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true
  };
};
function useDismiss(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context;
  const {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = "pointerdown",
    referencePress = false,
    referencePressEvent = "pointerdown",
    ancestorScroll = false,
    bubbles,
    capture
  } = props;
  const tree = useFloatingTree();
  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
  const insideReactTreeRef = React4.useRef(false);
  const endedOrStartedInsideRef = React4.useRef(false);
  const {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles);
  const {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture);
  const closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape") {
      return;
    }
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      event.stopPropagation();
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context;
          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  });
  const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event);
      (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  });
  const closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = false;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    endedOrStartedInsideRef.current = false;
    if (outsidePressEvent === "click" && endedOrStartedInside) {
      return;
    }
    if (insideReactTree) {
      return;
    }
    if (typeof outsidePress === "function" && !outsidePress(event)) {
      return;
    }
    const target = getTarget(event);
    const inertSelector = "[" + createAttribute("inert") + "]";
    const markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {
        break;
      }
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker))) {
      return;
    }
    if (isHTMLElement(target) && floating) {
      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      let xCond = canScrollY && event.offsetX > target.clientWidth;
      if (canScrollY) {
        const isRTL2 = getComputedStyle2(target).direction === "rtl";
        if (isRTL2) {
          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
        }
      }
      if (xCond || canScrollX && event.offsetY > target.clientHeight) {
        return;
      }
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) {
      return;
    }
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = false;
          return;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    onOpenChange(false, event, "outside-press");
  });
  const closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event);
      (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React4.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    function onScroll(event) {
      onOpenChange(false, event, "ancestor-scroll");
    }
    const doc = getDocument(elements.floating);
    escapeKey && doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement(elements.domReference)) {
        ancestors = getOverflowAncestors(elements.domReference);
      }
      if (isElement(elements.floating)) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.floating));
      }
      if (!isElement(elements.reference) && elements.reference && elements.reference.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    return () => {
      escapeKey && doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
      ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      });
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
  React4.useEffect(() => {
    insideReactTreeRef.current = false;
  }, [outsidePress, outsidePressEvent]);
  const reference = React4.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    [bubbleHandlerKeys[referencePressEvent]]: (event) => {
      if (referencePress) {
        onOpenChange(false, event.nativeEvent, "reference-press");
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);
  const floating = React4.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = true;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = true;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      insideReactTreeRef.current = true;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent]);
  return React4.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = React4.useRef({});
  const [events4] = React4.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  if (true) {
    const optionDomReference = elementsProp.reference;
    if (optionDomReference && !isElement(optionDomReference)) {
      error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    }
  }
  const [positionReference, setPositionReference] = React4.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events4.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = React4.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React4.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React4.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events: events4,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events4, floatingId, refs]);
}
function useFloating2(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React4.useState(null);
  const [positionReference, _setPositionReference] = React4.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.reference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React4.useRef(null);
  const tree = useFloatingTree();
  index2(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React4.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = React4.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React4.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React4.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = React4.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index2(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return React4.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
var ACTIVE_KEY = "active";
var SELECTED_KEY = "selected";
function mergeProps2(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = React4.useCallback(
    (userProps) => mergeProps2(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = React4.useCallback(
    (userProps) => mergeProps2(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = React4.useCallback(
    (userProps) => mergeProps2(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React4.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
var isPreventScrollSupported = false;
function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case "vertical":
      return vertical;
    case "horizontal":
      return horizontal;
    default:
      return vertical || horizontal;
  }
}
function isMainOrientationKey(key, orientation) {
  const vertical = key === ARROW_UP || key === ARROW_DOWN;
  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal);
}
function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical = key === ARROW_DOWN;
  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal) || key === "Enter" || key === " " || key === "";
}
function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  const horizontal = key === ARROW_DOWN;
  return doSwitch(orientation, vertical, horizontal);
}
function isCrossOrientationCloseKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;
  const horizontal = key === ARROW_UP;
  return doSwitch(orientation, vertical, horizontal);
}
function useListNavigation(context, props) {
  const {
    open,
    onOpenChange,
    elements
  } = context;
  const {
    listRef,
    activeIndex,
    onNavigate: unstable_onNavigate = () => {
    },
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loop = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = "auto",
    focusItemOnHover = true,
    openOnArrowKeyDown = true,
    disabledIndices = void 0,
    orientation = "vertical",
    cols = 1,
    scrollItemIntoView = true,
    virtualItemRef,
    itemSizes,
    dense = false
  } = props;
  if (true) {
    if (allowEscape) {
      if (!loop) {
        warn("`useListNavigation` looping must be enabled to allow escaping.");
      }
      if (!virtual) {
        warn("`useListNavigation` must be virtual to allow escaping.");
      }
    }
    if (orientation === "vertical" && cols > 1) {
      warn("In grid list navigation mode (`cols` > 1), the `orientation` should", 'be either "horizontal" or "both".');
    }
  }
  const floatingFocusElement = getFloatingFocusElement(elements.floating);
  const floatingFocusElementRef = useLatestRef2(floatingFocusElement);
  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree();
  const onNavigate = useEffectEvent(unstable_onNavigate);
  const focusItemOnOpenRef = React4.useRef(focusItemOnOpen);
  const indexRef = React4.useRef(selectedIndex != null ? selectedIndex : -1);
  const keyRef = React4.useRef(null);
  const isPointerModalityRef = React4.useRef(true);
  const previousOnNavigateRef = React4.useRef(onNavigate);
  const previousMountedRef = React4.useRef(!!elements.floating);
  const previousOpenRef = React4.useRef(open);
  const forceSyncFocus = React4.useRef(false);
  const forceScrollIntoViewRef = React4.useRef(false);
  const disabledIndicesRef = useLatestRef2(disabledIndices);
  const latestOpenRef = useLatestRef2(open);
  const scrollItemIntoViewRef = useLatestRef2(scrollItemIntoView);
  const selectedIndexRef = useLatestRef2(selectedIndex);
  const [activeId, setActiveId] = React4.useState();
  const [virtualId, setVirtualId] = React4.useState();
  const focusItem = useEffectEvent(function(listRef2, indexRef2, forceScrollIntoView) {
    if (forceScrollIntoView === void 0) {
      forceScrollIntoView = false;
    }
    function runFocus(item2) {
      if (virtual) {
        setActiveId(item2.id);
        tree == null || tree.events.emit("virtualfocus", item2);
        if (virtualItemRef) {
          virtualItemRef.current = item2;
        }
      } else {
        enqueueFocus(item2, {
          preventScroll: true,
          // Mac Safari does not move the virtual cursor unless the focus call
          // is sync. However, for the very first focus call, we need to wait
          // for the position to be ready in order to prevent unwanted
          // scrolling. This means the virtual cursor will not move to the first
          // item when first opening the floating element, but will on
          // subsequent calls. `preventScroll` is supported in modern Safari,
          // so we can use that instead.
          // iOS Safari must be async or the first item will not be focused.
          sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false
        });
      }
    }
    const initialItem = listRef2.current[indexRef2.current];
    if (initialItem) {
      runFocus(initialItem);
    }
    requestAnimationFrame(() => {
      const waitedItem = listRef2.current[indexRef2.current] || initialItem;
      if (!waitedItem)
        return;
      if (!initialItem) {
        runFocus(waitedItem);
      }
      const scrollIntoViewOptions = scrollItemIntoViewRef.current;
      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);
      if (shouldScrollIntoView) {
        waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === "boolean" ? {
          block: "nearest",
          inline: "nearest"
        } : scrollIntoViewOptions);
      }
    });
  });
  index2(() => {
    document.createElement("div").focus({
      get preventScroll() {
        isPreventScrollSupported = true;
        return false;
      }
    });
  }, []);
  index2(() => {
    if (!enabled)
      return;
    if (open && elements.floating) {
      if (focusItemOnOpenRef.current && selectedIndex != null) {
        forceScrollIntoViewRef.current = true;
        indexRef.current = selectedIndex;
        onNavigate(selectedIndex);
      }
    } else if (previousMountedRef.current) {
      indexRef.current = -1;
      previousOnNavigateRef.current(null);
    }
  }, [enabled, open, elements.floating, selectedIndex, onNavigate]);
  index2(() => {
    if (!enabled)
      return;
    if (open && elements.floating) {
      if (activeIndex == null) {
        forceSyncFocus.current = false;
        if (selectedIndexRef.current != null) {
          return;
        }
        if (previousMountedRef.current) {
          indexRef.current = -1;
          focusItem(listRef, indexRef);
        }
        if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {
          let runs = 0;
          const waitForListPopulated = () => {
            if (listRef.current[0] == null) {
              if (runs < 2) {
                const scheduler = runs ? requestAnimationFrame : queueMicrotask;
                scheduler(waitForListPopulated);
              }
              runs++;
            } else {
              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);
              keyRef.current = null;
              onNavigate(indexRef.current);
            }
          };
          waitForListPopulated();
        }
      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {
        indexRef.current = activeIndex;
        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);
        forceScrollIntoViewRef.current = false;
      }
    }
  }, [enabled, open, elements.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
  index2(() => {
    var _nodes$find;
    if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {
      return;
    }
    const nodes = tree.nodesRef.current;
    const parent = (_nodes$find = nodes.find((node) => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;
    const activeEl = activeElement(getDocument(elements.floating));
    const treeContainsActiveEl = nodes.some((node) => node.context && contains(node.context.elements.floating, activeEl));
    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {
      parent.focus({
        preventScroll: true
      });
    }
  }, [enabled, elements.floating, tree, parentId, virtual]);
  index2(() => {
    if (!enabled)
      return;
    if (!tree)
      return;
    if (!virtual)
      return;
    if (parentId)
      return;
    function handleVirtualFocus(item2) {
      setVirtualId(item2.id);
      if (virtualItemRef) {
        virtualItemRef.current = item2;
      }
    }
    tree.events.on("virtualfocus", handleVirtualFocus);
    return () => {
      tree.events.off("virtualfocus", handleVirtualFocus);
    };
  }, [enabled, tree, virtual, parentId, virtualItemRef]);
  index2(() => {
    previousOnNavigateRef.current = onNavigate;
    previousMountedRef.current = !!elements.floating;
  });
  index2(() => {
    if (!open) {
      keyRef.current = null;
    }
  }, [open]);
  index2(() => {
    previousOpenRef.current = open;
  }, [open]);
  const hasActiveIndex = activeIndex != null;
  const item = React4.useMemo(() => {
    function syncCurrentTarget(currentTarget) {
      if (!open)
        return;
      const index3 = listRef.current.indexOf(currentTarget);
      if (index3 !== -1) {
        onNavigate(index3);
      }
    }
    const props2 = {
      onFocus(_ref) {
        let {
          currentTarget
        } = _ref;
        syncCurrentTarget(currentTarget);
      },
      onClick: (_ref2) => {
        let {
          currentTarget
        } = _ref2;
        return currentTarget.focus({
          preventScroll: true
        });
      },
      // Safari
      ...focusItemOnHover && {
        onMouseMove(_ref3) {
          let {
            currentTarget
          } = _ref3;
          syncCurrentTarget(currentTarget);
        },
        onPointerLeave(_ref4) {
          let {
            pointerType
          } = _ref4;
          if (!isPointerModalityRef.current || pointerType === "touch") {
            return;
          }
          indexRef.current = -1;
          focusItem(listRef, indexRef);
          onNavigate(null);
          if (!virtual) {
            enqueueFocus(floatingFocusElementRef.current, {
              preventScroll: true
            });
          }
        }
      }
    };
    return props2;
  }, [open, floatingFocusElementRef, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
  const commonOnKeyDown = useEffectEvent((event) => {
    isPointerModalityRef.current = false;
    forceSyncFocus.current = true;
    if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {
      return;
    }
    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
      stopEvent(event);
      onOpenChange(false, event.nativeEvent, "list-navigation");
      if (isHTMLElement(elements.domReference) && !virtual) {
        elements.domReference.focus();
      }
      return;
    }
    const currentIndex = indexRef.current;
    const minIndex = getMinIndex(listRef, disabledIndices);
    const maxIndex = getMaxIndex(listRef, disabledIndices);
    if (event.key === "Home") {
      stopEvent(event);
      indexRef.current = minIndex;
      onNavigate(indexRef.current);
    }
    if (event.key === "End") {
      stopEvent(event);
      indexRef.current = maxIndex;
      onNavigate(indexRef.current);
    }
    if (cols > 1) {
      const sizes = itemSizes || Array.from({
        length: listRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = buildCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index4) => index4 != null && !isDisabled(listRef.current, index4, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index4, cellIndex) => index4 != null && !isDisabled(listRef.current, index4, disabledIndices) ? cellIndex : foundIndex, -1);
      const index3 = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex != null ? listRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getCellIndices([...disabledIndices || listRef.current.map((_, index4) => isDisabled(listRef.current, index4) ? index4 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getCellIndexOfCorner(
          indexRef.current > maxIndex ? minIndex : indexRef.current,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction
          // we're moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN ? "bl" : event.key === ARROW_RIGHT ? "tr" : "tl"
        ),
        stopEvent: true
      })];
      if (index3 != null) {
        indexRef.current = index3;
        onNavigate(indexRef.current);
      }
      if (orientation === "both") {
        return;
      }
    }
    if (isMainOrientationKey(event.key, orientation)) {
      stopEvent(event);
      if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {
        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
        onNavigate(indexRef.current);
        return;
      }
      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
        if (loop) {
          indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            disabledIndices
          });
        } else {
          indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            disabledIndices
          }));
        }
      } else {
        if (loop) {
          indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices
          });
        } else {
          indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices
          }));
        }
      }
      if (isIndexOutOfBounds(listRef, indexRef.current)) {
        onNavigate(null);
      } else {
        onNavigate(indexRef.current);
      }
    }
  });
  const ariaActiveDescendantProp = React4.useMemo(() => {
    return virtual && open && hasActiveIndex && {
      "aria-activedescendant": virtualId || activeId
    };
  }, [virtual, open, hasActiveIndex, virtualId, activeId]);
  const floating = React4.useMemo(() => {
    return {
      "aria-orientation": orientation === "both" ? void 0 : orientation,
      ...!isTypeableCombobox(elements.domReference) && ariaActiveDescendantProp,
      onKeyDown: commonOnKeyDown,
      onPointerMove() {
        isPointerModalityRef.current = true;
      }
    };
  }, [ariaActiveDescendantProp, commonOnKeyDown, elements.domReference, orientation]);
  const reference = React4.useMemo(() => {
    function checkVirtualMouse(event) {
      if (focusItemOnOpen === "auto" && isVirtualClick(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    function checkVirtualPointer(event) {
      focusItemOnOpenRef.current = focusItemOnOpen;
      if (focusItemOnOpen === "auto" && isVirtualPointerEvent(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    return {
      ...ariaActiveDescendantProp,
      onKeyDown(event) {
        isPointerModalityRef.current = false;
        const isArrowKey = event.key.indexOf("Arrow") === 0;
        const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);
        const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);
        const isMainKey = isMainOrientationKey(event.key, orientation);
        const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === "Enter" || event.key.trim() === "";
        if (virtual && open) {
          const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node) => node.parentId == null);
          const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;
          if (isArrowKey && deepestNode && virtualItemRef) {
            const eventObject = new KeyboardEvent("keydown", {
              key: event.key,
              bubbles: true
            });
            if (isCrossOpenKey || isCrossCloseKey) {
              var _deepestNode$context, _deepestNode$context2;
              const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;
              const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? listRef.current.find((item2) => (item2 == null ? void 0 : item2.id) === activeId) : null;
              if (dispatchItem) {
                stopEvent(event);
                dispatchItem.dispatchEvent(eventObject);
                setVirtualId(void 0);
              }
            }
            if (isMainKey && deepestNode.context) {
              if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {
                var _deepestNode$context$;
                stopEvent(event);
                (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);
                return;
              }
            }
          }
          return commonOnKeyDown(event);
        }
        if (!open && !openOnArrowKeyDown && isArrowKey) {
          return;
        }
        if (isNavigationKey) {
          keyRef.current = nested && isMainKey ? null : event.key;
        }
        if (nested) {
          if (isCrossOpenKey) {
            stopEvent(event);
            if (open) {
              indexRef.current = getMinIndex(listRef, disabledIndicesRef.current);
              onNavigate(indexRef.current);
            } else {
              onOpenChange(true, event.nativeEvent, "list-navigation");
            }
          }
          return;
        }
        if (isMainKey) {
          if (selectedIndex != null) {
            indexRef.current = selectedIndex;
          }
          stopEvent(event);
          if (!open && openOnArrowKeyDown) {
            onOpenChange(true, event.nativeEvent, "list-navigation");
          } else {
            commonOnKeyDown(event);
          }
          if (open) {
            onNavigate(indexRef.current);
          }
        }
      },
      onFocus() {
        if (open && !virtual) {
          onNavigate(null);
        }
      },
      onPointerDown: checkVirtualPointer,
      onMouseDown: checkVirtualMouse,
      onClick: checkVirtualMouse
    };
  }, [activeId, ariaActiveDescendantProp, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open, openOnArrowKeyDown, orientation, rtl, selectedIndex, tree, virtual, virtualItemRef]);
  return React4.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
var componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", false]]);
function useRole(context, props) {
  var _componentRoleToAriaR;
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    floatingId
  } = context;
  const {
    enabled = true,
    role = "dialog"
  } = props;
  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;
  const referenceId = useId();
  const parentId = useFloatingParentNodeId();
  const isNested = parentId != null;
  const reference = React4.useMemo(() => {
    if (ariaRole === "tooltip" || role === "label") {
      return {
        ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
      };
    }
    return {
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
      "aria-controls": open ? floatingId : void 0,
      ...ariaRole === "listbox" && {
        role: "combobox"
      },
      ...ariaRole === "menu" && {
        id: referenceId
      },
      ...ariaRole === "menu" && isNested && {
        role: "menuitem"
      },
      ...role === "select" && {
        "aria-autocomplete": "none"
      },
      ...role === "combobox" && {
        "aria-autocomplete": "list"
      }
    };
  }, [ariaRole, floatingId, isNested, open, referenceId, role]);
  const floating = React4.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    if (ariaRole === "tooltip" || role === "label") {
      return floatingProps;
    }
    return {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]);
  const item = React4.useCallback((_ref) => {
    let {
      active,
      selected
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-option"
      }
    };
    switch (role) {
      case "select":
        return {
          ...commonProps,
          "aria-selected": active && selected
        };
      case "combobox": {
        return {
          ...commonProps,
          ...active && {
            "aria-selected": true
          }
        };
      }
    }
    return {};
  }, [floatingId, role]);
  return React4.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}

// node_modules/@digdir/designsystemet-react/dist/esm/components/Spinner/Spinner.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/hooks/useSynchronizedAnimation/useSynchronizedAnimation.js
var import_react5 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/hooks/useIsomorphicLayoutEffect/useIsomorphicLayoutEffect.js
var import_react4 = __toESM(require_react(), 1);
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react4.useLayoutEffect : import_react4.useEffect;

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/hooks/useSynchronizedAnimation/useSynchronizedAnimation.js
function useSynchronizedAnimation(animationName) {
  const ref = (0, import_react5.useRef)(null);
  useIsomorphicLayoutEffect(() => {
    const animations = document.getAnimations().filter((animation) => "animationName" in animation && animation.animationName === animationName);
    const firstOfType = animations.find((animation) => "animationName" in animation && animation.animationName === animationName);
    const myAnimation = animations.find((animation) => {
      var _a4;
      return ((_a4 = animation.effect) == null ? void 0 : _a4.target) === ref.current;
    });
    if (myAnimation && myAnimation === firstOfType) {
      myAnimation.currentTime = 0;
    }
    if (myAnimation && (firstOfType == null ? void 0 : firstOfType.currentTime) && myAnimation !== firstOfType) {
      myAnimation.currentTime = firstOfType.currentTime;
    }
    return () => {
      if (myAnimation && (firstOfType == null ? void 0 : firstOfType.currentTime)) {
        myAnimation.currentTime = firstOfType.currentTime;
      }
    };
  }, [animationName]);
  return ref;
}

// node_modules/@digdir/designsystemet-react/dist/esm/components/Spinner/Spinner.js
var Spinner = (0, import_react7.forwardRef)(function Spinner2({ "aria-label": ariaLabel, className, ...rest }, ref) {
  const svgRef = useSynchronizedAnimation("ds-spinner-rotate-animation");
  const strokeRef = useSynchronizedAnimation("ds-spinner-stroke-animation");
  const mergedRefs = useMergeRefs([svgRef, ref]);
  return (0, import_jsx_runtime3.jsxs)("svg", { "aria-label": ariaLabel, className: lite_default("ds-spinner", className), ref: mergedRefs, role: "img", viewBox: "0 0 50 50", ...rest, children: [(0, import_jsx_runtime3.jsx)("circle", { className: lite_default("ds-spinner__background"), cx: "25", cy: "25", r: "20", fill: "none", strokeWidth: "5" }), (0, import_jsx_runtime3.jsx)("circle", { className: lite_default(`ds-spinner__circle`), cx: "25", cy: "25", r: "20", fill: "none", strokeWidth: "5", ref: strokeRef })] });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Button/Button.js
var Button = (0, import_react8.forwardRef)(function Button2({ asChild, className, children, icon = false, loading = false, variant = "primary", ...rest }, ref) {
  const Component = asChild ? Slot : "button";
  return (0, import_jsx_runtime4.jsxs)(Component, {
    "aria-busy": Boolean(loading) || void 0,
    "aria-disabled": Boolean(loading) || void 0,
    className: lite_default("ds-button", className),
    "data-icon": icon || void 0,
    "data-variant": variant,
    ref,
    /* don't set type when we use `asChild` */
    type: asChild ? void 0 : "button",
    ...rest,
    children: [loading === true ? (0, import_jsx_runtime4.jsx)(Spinner, { "aria-hidden": "true" }) : loading, (0, import_jsx_runtime4.jsx)(Slottable, { children })]
  });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Badge/Badge.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var Badge = (0, import_react9.forwardRef)(function Badge2({ className, count: count2, maxCount, variant = "base", ...rest }, ref) {
  return (0, import_jsx_runtime5.jsx)("span", { className: lite_default("ds-badge", className), "data-count": count2 && maxCount && count2 > maxCount ? `${maxCount}+` : count2, "data-variant": variant, ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Badge/BadgePosition.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var BadgePosition = (0, import_react10.forwardRef)(function BadgePlacement({ className, overlap = "rectangle", placement = "top-right", ...rest }, ref) {
  return (0, import_jsx_runtime6.jsx)("span", { className: lite_default("ds-badge--position", className), "data-overlap": overlap, "data-placement": placement, ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Badge/index.js
var Badge3 = Object.assign(Badge, { Position: BadgePosition });
Badge3.Position.displayName = "Badge.Position";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Breadcrumbs/Breadcrumbs.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
var Breadcrumbs = (0, import_react11.forwardRef)(({ "aria-label": ariaLabel = "Du er her:", className, ...rest }, ref) => (0, import_jsx_runtime7.jsx)("nav", { "aria-label": ariaLabel, className: lite_default("ds-breadcrumbs", className), ref, ...rest }));

// node_modules/@digdir/designsystemet-react/dist/esm/components/Breadcrumbs/BreadcrumbsItem.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var BreadcrumbsItem = (0, import_react12.forwardRef)(function BreadcrumbsItem2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime8.jsx)("li", { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Breadcrumbs/BreadcrumbsLink.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Link/Link.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var Link = (0, import_react13.forwardRef)(({ asChild, className, ...rest }, ref) => {
  const Component = asChild ? Slot : "a";
  return (0, import_jsx_runtime9.jsx)(Component, { className: lite_default("ds-link", className), ref, ...rest });
});
Link.displayName = "Link";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Breadcrumbs/BreadcrumbsLink.js
var BreadcrumbsLink = (0, import_react14.forwardRef)(function BreadcrumbsLink2(rest, ref) {
  return (0, import_jsx_runtime10.jsx)(Link, { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Breadcrumbs/BreadcrumbsList.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
var BreadcrumbsList = (0, import_react16.forwardRef)(function BreadcrumbsList2(rest, ref) {
  const innerRef = (0, import_react16.useRef)(null);
  const mergedRefs = useMergeRefs([innerRef, ref]);
  (0, import_react16.useEffect)(() => {
    var _a4;
    const links = ((_a4 = innerRef.current) == null ? void 0 : _a4.querySelectorAll(":scope > * > *")) || [];
    const lastLink = links[(links == null ? void 0 : links.length) - 1];
    lastLink == null ? void 0 : lastLink.setAttribute("aria-current", "page");
    return () => lastLink == null ? void 0 : lastLink.removeAttribute("aria-current");
  });
  return (0, import_jsx_runtime11.jsx)("ol", { ref: mergedRefs, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Breadcrumbs/index.js
var Breadcrumbs2 = Object.assign(Breadcrumbs, {
  List: BreadcrumbsList,
  Item: BreadcrumbsItem,
  Link: BreadcrumbsLink
});
Breadcrumbs2.List.displayName = "Breadcrumbs.List";
Breadcrumbs2.Item.displayName = "Breadcrumbs.Item";
Breadcrumbs2.Link.displayName = "Breadcrumbs.Link";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Skeleton/Skeleton.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
var Skeleton = (0, import_react18.forwardRef)(function Skeleton2({ asChild, className, height, style, variant = "rectangle", width, ...rest }, ref) {
  const Component = asChild ? Slot : "span";
  const isText = variant === "text";
  const animationRef = useSynchronizedAnimation("ds-skeleton-opacity-fade");
  const mergedRefs = useMergeRefs([animationRef, ref]);
  return (0, import_jsx_runtime12.jsx)(Component, { "aria-hidden": "true", className: lite_default("ds-skeleton", className), "data-text": isText ? "-".repeat(Number(width) || 1) : void 0, "data-variant": variant, ref: mergedRefs, style: isText ? style : { width, height, ...style }, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/List/ListItem.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
var ListItem = (0, import_react19.forwardRef)(function ListItem2({ asChild, ...rest }, ref) {
  const Component = asChild ? Slot : "li";
  return (0, import_jsx_runtime13.jsx)(Component, { ...rest, ref });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/List/Lists.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);
var render = (tagName, { asChild, className, ...rest }, ref) => {
  const Component = asChild ? Slot : tagName;
  return (0, import_jsx_runtime14.jsx)(Component, { className: lite_default(`ds-list`, className), ref, ...rest });
};
var ListUnordered = (0, import_react20.forwardRef)(function ListUnordered2(props, ref) {
  return render("ul", props, ref);
});
var ListOrdered = (0, import_react20.forwardRef)(function ListOrdered2(props, ref) {
  return render("ol", props, ref);
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/List/index.js
var List = {
  Item: ListItem,
  Ordered: ListOrdered,
  Unordered: ListUnordered
};
List.Item.displayName = "List.Item";
List.Ordered.displayName = "List.Ordered";
List.Unordered.displayName = "List.Unordered";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Label/Label.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);
var Label = (0, import_react21.forwardRef)(function Label2({ className, weight = "medium", asChild, ...rest }, ref) {
  const Component = asChild ? Slot : "label";
  return (0, import_jsx_runtime15.jsx)(Component, { ref, className: lite_default("ds-label", className), "data-weight": weight, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Heading/Heading.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);
var Heading = (0, import_react22.forwardRef)(function Heading2({ level = 2, className, asChild, ...rest }, ref) {
  const Component = asChild ? Slot : `h${level}`;
  return (0, import_jsx_runtime16.jsx)(Component, { className: lite_default(`ds-heading`, className), ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Paragraph/Paragraph.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);
var Paragraph = (0, import_react23.forwardRef)(function Paragraph2({ className, asChild, variant = "default", ...rest }, ref) {
  const Component = asChild ? Slot : "p";
  return (0, import_jsx_runtime17.jsx)(Component, { ref, className: lite_default(`ds-paragraph`, className), "data-variant": variant, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/ValidationMessage/ValidationMessage.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react24 = __toESM(require_react(), 1);
var ValidationMessage = (0, import_react24.forwardRef)(function ValidationMessage2({ className, asChild, ...rest }, ref) {
  const Component = asChild ? Slot : "p";
  return (0, import_jsx_runtime18.jsx)(Component, { className: lite_default("ds-validation-message", className), "data-field": "validation", ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Details/Details.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react26 = __toESM(require_react(), 1);

// node_modules/@u-elements/u-details/dist/u-details.js
var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.navigator !== "undefined";
var _a;
IS_BROWSER && // @ts-expect-error Typescript has not implemented userAgentData yet https://stackoverflow.com/a/71392474
/^Mac/i.test(((_a = navigator.userAgentData) == null ? void 0 : _a.platform) || navigator.platform);
var DISPLAY_BLOCK = ":host(:not([hidden])) { display: block }";
var UHTMLElement = typeof HTMLElement === "undefined" ? class {
} : HTMLElement;
function attr2(el, name, value) {
  var _a22;
  if (value === void 0)
    return (_a22 = el.getAttribute(name)) != null ? _a22 : null;
  if (value === null)
    el.removeAttribute(name);
  else if (el.getAttribute(name) !== value)
    el.setAttribute(name, value);
  return null;
}
var events = (action, element, rest) => {
  for (const type of rest[0].split(",")) {
    rest[0] = type;
    Element.prototype[`${action}EventListener`].apply(element, rest);
  }
};
var on = (element, ...rest) => events("add", element, rest);
var off = (element, ...rest) => events("remove", element, rest);
var asButton = (event) => {
  const isClick = "key" in event && (event.key === " " || event.key === "Enter");
  if (isClick)
    event.preventDefault();
  if (isClick && event.target instanceof HTMLElement)
    event.target.click();
  return isClick;
};
var getRoot = (node) => {
  var _a22;
  const root = ((_a22 = node.getRootNode) == null ? void 0 : _a22.call(node)) || node.ownerDocument;
  return root instanceof Document || root instanceof ShadowRoot ? root : document;
};
var createElement2 = (tagName, text, attrs) => {
  const el = document.createElement(tagName);
  if (text)
    el.textContent = text;
  if (attrs)
    for (const [key, val] of Object.entries(attrs))
      attr2(el, key, val);
  return el;
};
var customElements = {
  define: (name, instance) => !IS_BROWSER || window.customElements.get(name) || window.customElements.define(name, instance)
};
var UHTMLDetailsElement = class extends UHTMLElement {
  constructor() {
    super();
    this._content = null;
    this.attachShadow({ mode: "open" }).append(
      createElement2("slot", null, { name: "summary" }),
      createElement2("slot", null, { part: "details-content" }),
      createElement2(
        "style",
        `${DISPLAY_BLOCK}
        ::slotted(u-summary) { cursor: pointer; display: list-item; counter-increment: list-item 0; list-style: disclosure-closed inside }
        ::slotted(u-summary[aria-expanded="true"]) { list-style-type: disclosure-open }
				:host > [part="details-content"]:not([hidden=""]) { display: block }`
      )
    );
  }
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return ["open"];
  }
  connectedCallback() {
    var _a22;
    this._content = (_a22 = this.shadowRoot) == null ? void 0 : _a22.children[1];
    on(this._content, "beforematch", this);
    on(this, "click,keydown", this);
    this.attributeChangedCallback();
  }
  disconnectedCallback() {
    if (this._content)
      off(this._content, "beforematch", this);
    off(this, "click,keydown", this);
    this._content = null;
  }
  attributeChangedCallback(prop, prev, next) {
    const hide4 = "onbeforematch" in this ? "until-found" : true;
    const open = this.open;
    for (const el of this.children)
      if (el.nodeName === "U-SUMMARY")
        attr2(el, "aria-expanded", `${open}`);
    if (this._content) {
      attr2(this._content, "aria-hidden", `${!open}`);
      this._content.hidden = open ? false : hide4;
    }
    if (open && this.name) {
      const uDetailsList = getRoot(this).querySelectorAll(
        `${this.nodeName}[name="${this.name}"]`
      );
      for (const uDetails of uDetailsList)
        if (uDetails !== this)
          uDetails.open = false;
    }
    if (prop === "open" && prev === null !== (next === null))
      this.dispatchEvent(new Event("toggle"));
  }
  handleEvent(event) {
    const summary = this.querySelector(":scope > u-summary");
    const isSummary = summary == null ? void 0 : summary.contains(event.target);
    if (event.defaultPrevented)
      return;
    if (event.type === "beforematch")
      this.open = true;
    if (isSummary && event.type === "keydown")
      asButton(event);
    if (isSummary && event.type === "click")
      this.open = !this.open;
  }
  get open() {
    return this.hasAttribute("open");
  }
  set open(value) {
    attr2(this, "open", value ? "" : null);
  }
  get name() {
    return attr2(this, "name") || "";
  }
  set name(value) {
    attr2(this, "name", value);
  }
};
var UHTMLSummaryElement = class extends UHTMLElement {
  connectedCallback() {
    attr2(this, "role", "button");
    this.slot = "summary";
    this.tabIndex = 0;
  }
};
customElements.define("u-details", UHTMLDetailsElement);
customElements.define("u-summary", UHTMLSummaryElement);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Details/Details.js
var Details = (0, import_react26.forwardRef)(function Details2({ className, open, defaultOpen = false, variant = "default", onToggle, ...rest }, ref) {
  const detailsRef = (0, import_react26.useRef)(null);
  const initialOpen = (0, import_react26.useRef)(defaultOpen);
  const mergedRefs = useMergeRefs([detailsRef, ref]);
  const onToggleRef = (0, import_react26.useRef)(onToggle);
  const openRef = (0, import_react26.useRef)(open);
  onToggleRef.current = onToggle;
  openRef.current = open;
  (0, import_react26.useEffect)(() => {
    const details = detailsRef.current;
    const handleToggle = (event) => {
      var _a4;
      if (!details || (details == null ? void 0 : details.open) === openRef.current)
        return;
      (_a4 = onToggleRef.current) == null ? void 0 : _a4.call(onToggleRef, event);
      if (openRef.current !== void 0)
        details.open = openRef.current;
    };
    details == null ? void 0 : details.addEventListener("toggle", handleToggle, true);
    return () => details == null ? void 0 : details.removeEventListener("toggle", handleToggle, true);
  }, []);
  return (0, import_jsx_runtime19.jsx)("u-details", { class: lite_default("ds-details", className), open: (open ?? initialOpen.current) || void 0, "data-variant": variant, ref: mergedRefs, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Details/DetailsContent.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react27 = __toESM(require_react(), 1);
var DetailsContent = (0, import_react27.forwardRef)(function DetailsContent2(rest, ref) {
  return (0, import_jsx_runtime20.jsx)("div", { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Details/DetailsSummary.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react28 = __toESM(require_react(), 1);
var DetailsSummary = (0, import_react28.forwardRef)(function DetailsSummary2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime21.jsx)("u-summary", { ref, class: className, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Details/index.js
var Details3 = Object.assign(Details, {
  Summary: DetailsSummary,
  Content: DetailsContent
});
Details3.Summary.displayName = "Details.Summary";
Details3.Content.displayName = "Details.Content";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Select/Select.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react29 = __toESM(require_react(), 1);
var Select = (0, import_react29.forwardRef)(function Select2({ className, onKeyDown: onKeyDown3, onMouseDown, width, ...rest }, ref) {
  return (0, import_jsx_runtime22.jsx)("select", { className: lite_default("ds-input", className), "data-width": width, ref, onKeyDown: (event) => {
    if (event.key === "Tab")
      return;
    if (rest.readOnly)
      event.preventDefault();
    onKeyDown3 == null ? void 0 : onKeyDown3(event);
  }, onMouseDown: (event) => {
    if (rest.readOnly)
      event.preventDefault();
    onMouseDown == null ? void 0 : onMouseDown(event);
  }, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Select/SelectOptgroup.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);
var SelectOptgroup = (0, import_react30.forwardRef)(function SelectOptgroup2({ asChild, ...rest }, ref) {
  const Component = asChild ? Slot : "optgroup";
  return (0, import_jsx_runtime23.jsx)(Component, { ...rest, ref });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Select/SelectOption.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react31 = __toESM(require_react(), 1);
var SelectOption = (0, import_react31.forwardRef)(function SelectOption2({ asChild, ...rest }, ref) {
  const Component = asChild ? Slot : "option";
  return (0, import_jsx_runtime24.jsx)(Component, { ...rest, ref });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Select/index.js
var Select3 = Object.assign(Select, {
  Option: SelectOption,
  Optgroup: SelectOptgroup
});
Select3.Option.displayName = "Select.Option";
Select3.Optgroup.displayName = "Select.Optgroup";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Alert/Alert.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react32 = __toESM(require_react(), 1);
var Alert = (0, import_react32.forwardRef)(function Alert2({ "data-color": color = "info", className, ...rest }, ref) {
  return (0, import_jsx_runtime25.jsx)("div", { className: lite_default("ds-alert", className), "data-color": color, ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Tag/Tag.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_react33 = __toESM(require_react(), 1);
var Tag = (0, import_react33.forwardRef)(function Tag2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime26.jsx)("span", { className: lite_default("ds-tag", className), ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Chip/Chips.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react35 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Input/Input.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_react34 = __toESM(require_react(), 1);
var Input = (0, import_react34.forwardRef)(function Input2({ type = "text", className, onChange, onClick: onClick3, ...rest }, ref) {
  return (0, import_jsx_runtime27.jsx)("input", { className: lite_default(`ds-input`, className), ref, type, onChange: (event) => rest.readOnly || (onChange == null ? void 0 : onChange(event)), onClick: (event) => {
    if (rest.readOnly)
      event.preventDefault();
    onClick3 == null ? void 0 : onClick3(event);
  }, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Chip/Chips.js
var ChipButton = (0, import_react35.forwardRef)(function ChipButton2({ asChild, className, ...rest }, ref) {
  const Component = asChild ? Slot : "button";
  return (0, import_jsx_runtime28.jsx)(Component, { className: lite_default("ds-chip", className), type: asChild ? void 0 : "button", ref, ...rest });
});
var ChipRemovable = (0, import_react35.forwardRef)(function ChipRemovable2(props, ref) {
  return (0, import_jsx_runtime28.jsx)(ChipButton, { "data-removable": true, ref, ...props });
});
var ChipCheckbox = (0, import_react35.forwardRef)(function ChipCheckbox2({ asChild, children, className, "data-size": size4, "data-color": color, ...rest }, ref) {
  const inputType = rest.type ?? "checkbox";
  const Component = asChild ? Slot : "label";
  return (0, import_jsx_runtime28.jsxs)(Component, { className: lite_default("ds-chip", className), "data-size": size4, "data-color": color, ref, children: [(0, import_jsx_runtime28.jsx)(Input, { ...rest, type: inputType }), (0, import_jsx_runtime28.jsx)(Slottable, { children })] });
});
var ChipRadio = (0, import_react35.forwardRef)(function ChipRadio2(props, ref) {
  return (0, import_jsx_runtime28.jsx)(ChipCheckbox, { ref, type: "radio", ...props });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Chip/index.js
var Chip = {
  Button: ChipButton,
  Checkbox: ChipCheckbox,
  Radio: ChipRadio,
  Removable: ChipRemovable
};
Chip.Button.displayName = "Chip.Button";
Chip.Checkbox.displayName = "Chip.Checkbox";
Chip.Radio.displayName = "Chip.Radio";
Chip.Removable.displayName = "Chip.Removable";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Pagination/Pagination.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);
var Pagination = (0, import_react36.forwardRef)(function Pagination2({ "aria-label": ariaLabel = "Sidenavigering", asChild, className, ...rest }, ref) {
  const Component = asChild ? Slot : "nav";
  return (0, import_jsx_runtime29.jsx)(Component, { "aria-label": ariaLabel, className: lite_default("ds-pagination", className), ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Pagination/PaginationButton.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react37 = __toESM(require_react(), 1);
var PaginationButton = (0, import_react37.forwardRef)(function PaginationButton2(rest, ref) {
  return (0, import_jsx_runtime30.jsx)(Button, { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Pagination/PaginationItem.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react38 = __toESM(require_react(), 1);
var PaginationItem = (0, import_react38.forwardRef)(function PaginationItem2({ asChild, className, ...rest }, ref) {
  const Component = asChild ? Slot : "li";
  return (0, import_jsx_runtime31.jsx)(Component, { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Pagination/PaginationList.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react39 = __toESM(require_react(), 1);
var PaginationList = (0, import_react39.forwardRef)(function PaginationList2({ asChild, ...rest }, ref) {
  const Component = asChild ? Slot : "ul";
  return (0, import_jsx_runtime32.jsx)(Component, { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Pagination/index.js
var Pagination3 = Object.assign(Pagination, {
  List: PaginationList,
  Item: PaginationItem,
  Button: PaginationButton
});
Pagination3.List.displayName = "Pagination.List";
Pagination3.Item.displayName = "Pagination.Item";
Pagination3.Button.displayName = "Pagination.Button";

// node_modules/@digdir/designsystemet-react/dist/esm/components/SkipLink/SkipLink.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react40 = __toESM(require_react(), 1);
var SkipLink = (0, import_react40.forwardRef)(function SkipLink2({ children, className, ...rest }, ref) {
  return (0, import_jsx_runtime33.jsx)("a", { className: lite_default("ds-skiplink", className), ...rest, ref, children });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Tooltip/Tooltip.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react41 = __toESM(require_react(), 1);
var Tooltip = (0, import_react41.forwardRef)(function Tooltip2({ id: id3, children, content, placement = "top", open, className, ...rest }, ref) {
  const randomTooltipId = (0, import_react41.useId)();
  const [internalOpen, setInternalOpen] = (0, import_react41.useState)(false);
  const triggerRef = (0, import_react41.useRef)(null);
  const tooltipRef = (0, import_react41.useRef)(null);
  const mergedRefs = useMergeRefs([tooltipRef, ref]);
  const controlledOpen = open ?? internalOpen;
  const setOpen = () => {
    setInternalOpen(true);
  };
  const setClose = () => {
    setInternalOpen(false);
  };
  (0, import_react41.useEffect)(() => {
    var _a4;
    const tooltip = tooltipRef.current;
    const trigger = triggerRef.current;
    (_a4 = tooltip == null ? void 0 : tooltip.togglePopover) == null ? void 0 : _a4.call(tooltip, controlledOpen);
    if (tooltip)
      tooltip.style.opacity = controlledOpen ? "1" : "0";
    if (tooltip && trigger && controlledOpen) {
      return autoUpdate(trigger, tooltip, () => {
        computePosition2(trigger, tooltip, {
          placement,
          strategy: "fixed",
          middleware: [
            offset2((data) => {
              const styles = getComputedStyle(data.elements.floating, "::before");
              return parseFloat(styles.height);
            }),
            flip2({
              fallbackAxisSideDirection: "start"
            }),
            shift2(),
            arrowPseudoElement
          ]
        }).then(({ x, y }) => {
          tooltip.style.translate = `${x}px ${y}px`;
        });
      });
    }
  }, [controlledOpen, placement]);
  (0, import_react41.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        setInternalOpen(false);
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  const ChildContainer = typeof children === "string" ? "span" : Slot;
  if (typeof children !== "string" && children.type === import_react41.Fragment) {
    console.error("<Tooltip> children needs to be a single ReactElement that can receive a ref and not: <Fragment/> | <></>");
    return null;
  }
  const popoverProps = {
    [import_react41.version.startsWith("19") ? "popoverTarget" : "popovertarget"]: id3 ?? randomTooltipId,
    [import_react41.version.startsWith("19") ? "popoverTargetAction" : "popovertargetaction"]: "show"
  };
  return (0, import_jsx_runtime34.jsxs)(import_jsx_runtime34.Fragment, { children: [(0, import_jsx_runtime34.jsx)(ChildContainer, { ref: triggerRef, ...popoverProps, onMouseEnter: setOpen, onMouseLeave: setClose, onFocus: setOpen, onBlur: setClose, children }), (0, import_jsx_runtime34.jsx)("div", {
    ref: mergedRefs,
    role: "tooltip",
    className: lite_default("ds-tooltip", className),
    id: id3 ?? randomTooltipId,
    // @ts-ignore @types/react-dom does not understand popover yet
    popover: "manual",
    ...rest,
    children: content
  })] });
});
var arrowPseudoElement = {
  name: "ArrowPseudoElement",
  fn(data) {
    const { elements, rects, placement } = data;
    let arrowX = `${Math.round(rects.reference.width / 2 + rects.reference.x - data.x)}px`;
    let arrowY = `${Math.round(rects.reference.height / 2 + rects.reference.y - data.y)}px`;
    switch (placement) {
      case "top":
        arrowY = "100%";
        break;
      case "right":
        arrowX = "0";
        break;
      case "bottom":
        arrowY = "0";
        break;
      case "left":
        arrowX = "100%";
        break;
    }
    elements.floating.style.setProperty("--dsc-tooltip-arrow-x", arrowX);
    elements.floating.style.setProperty("--dsc-tooltip-arrow-y", arrowY);
    return data;
  }
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/Field/Field.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Field/fieldObserver.js
function fieldObserver(fieldElement) {
  if (!fieldElement)
    return;
  const elements = /* @__PURE__ */ new Map();
  const uuid = `:${Date.now().toString(36)}${Math.random().toString(36).slice(2, 5)}`;
  let input = null;
  let describedby = "";
  const process2 = (mutations) => {
    const changed = [];
    const removed = [];
    for (const mutation of mutations) {
      if (mutation.attributeName)
        changed.push(mutation.target ?? fieldElement);
      changed.push(...mutation.addedNodes || []);
      removed.push(...mutation.removedNodes || []);
    }
    for (const el of changed) {
      if (!isElement2(el))
        continue;
      if (isLabel(el))
        elements.set(el, el.htmlFor);
      else if (el.hasAttribute("data-field"))
        elements.set(el, el.id);
      else if (isInputLike(el)) {
        input = el;
        describedby = el.getAttribute("aria-describedby") || "";
      }
    }
    for (const el of removed) {
      if (!isElement2(el))
        continue;
      if (input === el)
        input = null;
      if (elements.has(el)) {
        setAttr(el, "aria-disabled", null);
        setAttr(el, isLabel(el) ? "for" : "id", elements.get(el));
        elements.delete(el);
      }
    }
    const describedbyIds = [describedby];
    const inputId = (input == null ? void 0 : input.id) || uuid;
    const isDisabled2 = (input == null ? void 0 : input.hasAttribute("disabled")) || (input == null ? void 0 : input.getAttribute("aria-disabled")) === "true";
    for (const [el, value] of elements) {
      const descriptionType = el.getAttribute("data-field");
      const id3 = descriptionType ? `${inputId}:${descriptionType}` : inputId;
      setAttr(el, "aria-disabled", isDisabled2 ? "true" : null);
      if (!value)
        setAttr(el, isLabel(el) ? "for" : "id", id3);
      if (descriptionType === "validation")
        describedbyIds.unshift(el.id);
      else if (descriptionType)
        describedbyIds.push(el.id);
    }
    setAttr(input, "id", inputId);
    setAttr(input, "aria-describedby", describedbyIds.join(" ").trim());
  };
  const observer = createOptimizedMutationObserver(process2);
  observer.observe(fieldElement, {
    attributeFilter: ["id", "for", "aria-describedby"],
    attributes: true,
    childList: true,
    subtree: true
  });
  process2([{ addedNodes: fieldElement.querySelectorAll("*") }]);
  observer.takeRecords();
  return () => observer.disconnect();
}
var isElement2 = (node) => node instanceof Element;
var isLabel = (node) => node instanceof HTMLLabelElement;
var isInputLike = (node) => node instanceof HTMLElement && "validity" in node && !(node instanceof HTMLButtonElement);
var setAttr = (el, name, value) => value ? el == null ? void 0 : el.setAttribute(name, value) : el == null ? void 0 : el.removeAttribute(name);
function createOptimizedMutationObserver(callback) {
  const queue = [];
  const observer = new MutationObserver((mutations) => {
    if (!queue.length)
      requestAnimationFrame(process2);
    queue.push(...mutations);
  });
  const process2 = () => {
    callback(queue, observer);
    queue.length = 0;
    observer.takeRecords();
  };
  return observer;
}

// node_modules/@digdir/designsystemet-react/dist/esm/components/Field/Field.js
var Field = (0, import_react44.forwardRef)(function Field2({ className, position, ...rest }, ref) {
  const fieldRef = (0, import_react44.useRef)(null);
  const mergedRefs = useMergeRefs([fieldRef, ref]);
  (0, import_react44.useEffect)(() => fieldObserver(fieldRef.current), []);
  return (0, import_jsx_runtime35.jsx)("div", { className: lite_default("ds-field", className), "data-position": position, ref: mergedRefs, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Field/FieldAffix.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react45 = __toESM(require_react(), 1);
var FieldAffixes = (0, import_react45.forwardRef)(function FieldAffixes2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime36.jsx)("div", { className: lite_default("ds-field-affixes", className), ref, ...rest });
});
var FieldAffix = (0, import_react45.forwardRef)(function FieldAffix2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime36.jsx)("span", { className: lite_default("ds-field-affix", className), "aria-hidden": "true", ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Field/FieldCounter.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);
var label = (text, count2) => text.replace("%d", Math.abs(count2).toString());
var FieldCounter = (0, import_react46.forwardRef)(function FieldCounter2({ limit, under = "%d tegn igjen", over = "%d tegn for mye", ...rest }, ref) {
  const [count2, setCount] = (0, import_react46.useState)(0);
  const counterRef = (0, import_react46.useRef)(null);
  const hasExceededLimit = count2 > limit;
  const remainder = limit - count2;
  (0, import_react46.useEffect)(() => {
    var _a4;
    const field = (_a4 = counterRef.current) == null ? void 0 : _a4.closest(".ds-field");
    const input = Array.from((field == null ? void 0 : field.getElementsByTagName("*")) || []).find(isInputLike);
    const onInput = ({ target }) => {
      if (isInputLike(target))
        setCount(target.value.length);
    };
    if (input)
      onInput({ target: input });
    field == null ? void 0 : field.addEventListener("input", onInput);
    return () => field == null ? void 0 : field.removeEventListener("input", onInput);
  }, [setCount]);
  return (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [(0, import_jsx_runtime37.jsx)("div", { "data-field": "description", className: "ds-sr-only", "aria-live": "polite", ref: counterRef, children: hasExceededLimit && label(over, remainder) }), hasExceededLimit ? (0, import_jsx_runtime37.jsx)(ValidationMessage, { ref, ...rest, children: label(over, remainder) }) : (0, import_jsx_runtime37.jsx)(Paragraph, { ref, ...rest, "data-field": "validation", children: label(under, remainder) })] });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Field/FieldDescription.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react47 = __toESM(require_react(), 1);
var FieldDescription = (0, import_react47.forwardRef)(function FieldDescription2(rest, ref) {
  return (0, import_jsx_runtime38.jsx)("div", { "data-field": "description", ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Field/index.js
var Field3 = Object.assign(Field, {
  Description: FieldDescription,
  Affixes: FieldAffixes,
  Affix: FieldAffix,
  Counter: FieldCounter
});
Field3.Description.displayName = "Field.Description";
Field3.Affixes.displayName = "Field.Affixes";
Field3.Affix.displayName = "Field.Affix";
Field3.Counter.displayName = "Field.Counter";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Checkbox/Checkbox.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);
var Checkbox = (0, import_react48.forwardRef)(function Checkbox2({ "data-size": size4, className, style, children, label: label2, description, error: error2, ...rest }, ref) {
  return (0, import_jsx_runtime39.jsxs)(Field3, { "data-size": size4, className, style, children: [(0, import_jsx_runtime39.jsx)(Input, { type: "checkbox", ref, ...rest }), !!label2 && (0, import_jsx_runtime39.jsx)(Label, { weight: "regular", children: label2 }), !!description && (0, import_jsx_runtime39.jsx)("div", { "data-field": "description", children: description }), !!error2 && (0, import_jsx_runtime39.jsx)(ValidationMessage, { children: error2 })] });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Radio/Radio.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react49 = __toESM(require_react(), 1);
var Radio = (0, import_react49.forwardRef)(function Radio2({ "data-size": size4, className, style, children, label: label2, description, error: error2, ...rest }, ref) {
  return (0, import_jsx_runtime40.jsxs)(Field3, { "data-size": size4, className, style, children: [(0, import_jsx_runtime40.jsx)(Input, { type: "radio", ref, ...rest }), !!label2 && (0, import_jsx_runtime40.jsx)(Label, { weight: "regular", children: label2 }), !!description && (0, import_jsx_runtime40.jsx)("div", { "data-field": "description", children: description }), !!error2 && (0, import_jsx_runtime40.jsx)(ValidationMessage, { children: error2 })] });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Fieldset/Fieldset.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react50 = __toESM(require_react(), 1);
var Fieldset = (0, import_react50.forwardRef)(function Fieldset2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime41.jsx)("fieldset", { className: lite_default("ds-fieldset", className), ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Fieldset/FieldsetDescription.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react51 = __toESM(require_react(), 1);
var FieldsetDescription = (0, import_react51.forwardRef)(function FieldsetDescription2(rest, ref) {
  return (0, import_jsx_runtime42.jsx)(Paragraph, { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Fieldset/FieldsetLegend.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react52 = __toESM(require_react(), 1);
var FieldsetLegend = (0, import_react52.forwardRef)(function FieldsetLegend2(rest, ref) {
  return (0, import_jsx_runtime43.jsx)(Label, { asChild: true, children: (0, import_jsx_runtime43.jsx)("legend", { ref, ...rest }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Fieldset/index.js
var Fieldset3 = Object.assign(Fieldset, {
  Legend: FieldsetLegend,
  Description: FieldsetDescription
});
Fieldset3.Legend.displayName = "Fieldset.Legend";
Fieldset3.Description.displayName = "Fieldset.Description";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Switch/Switch.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var Switch = (0, import_react53.forwardRef)(function Switch2({ "data-size": size4, children, className, description, label: label2, position, style, ...rest }, ref) {
  return (0, import_jsx_runtime44.jsxs)(Field3, { className, "data-position": position, "data-size": size4, style, children: [(0, import_jsx_runtime44.jsx)(Input, { type: "checkbox", role: "switch", ref, ...rest }), !!label2 && (0, import_jsx_runtime44.jsx)(Label, { weight: "regular", children: label2 }), !!description && (0, import_jsx_runtime44.jsx)("div", { "data-field": "description", children: description })] });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Textfield/Textfield.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react55 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Textarea/Textarea.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);
var Textarea = (0, import_react54.forwardRef)(function Textarea2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime45.jsx)("textarea", { className: lite_default("ds-input", className), ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Textfield/Textfield.js
var Textfield = (0, import_react55.forwardRef)(function Textfield2({ label: label2, description, error: error2, multiline, prefix: prefix2, suffix, "data-size": size4, counter, style, className, ...rest }, ref) {
  return (0, import_jsx_runtime46.jsxs)(Field3, { className, "data-size": size4, style, children: [!!label2 && (0, import_jsx_runtime46.jsx)(Label, { children: label2 }), !!description && (0, import_jsx_runtime46.jsx)(FieldDescription, { children: description }), (0, import_jsx_runtime46.jsxs)(FieldAffixes, { children: [prefix2 === void 0 || (0, import_jsx_runtime46.jsx)(FieldAffix, { children: prefix2 }), multiline === true ? (0, import_jsx_runtime46.jsx)(Textarea, { ref, "aria-invalid": Boolean(error2) || void 0, ...rest }) : (0, import_jsx_runtime46.jsx)(Input, { ref, "aria-invalid": Boolean(error2) || void 0, ...rest }), suffix === void 0 || (0, import_jsx_runtime46.jsx)(FieldAffix, { children: suffix })] }), !!error2 && (0, import_jsx_runtime46.jsx)(ValidationMessage, { children: error2 }), !!counter && (0, import_jsx_runtime46.jsx)(Field3.Counter, { ...typeof counter === "number" ? { limit: counter } : counter })] });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Tabs/Tabs.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_react56 = __toESM(require_react(), 1);
var Context = (0, import_react56.createContext)({});
var Tabs = (0, import_react56.forwardRef)(function Tabs2({ value, defaultValue, className, onChange, ...rest }, ref) {
  const isControlled = value !== void 0;
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react56.useState)(defaultValue);
  let onValueChange = onChange;
  if (!isControlled) {
    onValueChange = (newValue) => {
      setUncontrolledValue(newValue);
      onChange == null ? void 0 : onChange(newValue);
    };
    value = uncontrolledValue;
  }
  return (0, import_jsx_runtime47.jsx)(Context.Provider, { value: {
    value,
    defaultValue,
    onChange: onValueChange
  }, children: (0, import_jsx_runtime47.jsx)("div", { className: lite_default("ds-tabs", className), ref, ...rest }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Tabs/TabsList.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react59 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/RovingFocus/RovingFocusRoot.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react58 = __toESM(require_react(), 1);
var RovingFocusContext = (0, import_react58.createContext)({
  elements: { current: /* @__PURE__ */ new Map() },
  getOrderedItems: () => [],
  setFocusableValue: () => {
  },
  onShiftTab: () => {
  },
  focusableValue: null,
  orientation: "horizontal"
});
var RovingFocusRoot = (0, import_react58.forwardRef)(({ activeValue, asChild, orientation = "horizontal", onBlur, onFocus, ...rest }, ref) => {
  const Component = asChild ? Slot : "div";
  const [focusableValue, setFocusableValue] = (0, import_react58.useState)(null);
  const [isShiftTabbing, setIsShiftTabbing] = (0, import_react58.useState)(false);
  const elements = (0, import_react58.useRef)(/* @__PURE__ */ new Map());
  const myRef = (0, import_react58.useRef)(null);
  const refs = useMergeRefs([ref, myRef]);
  const getOrderedItems = () => {
    if (!myRef.current)
      return [];
    const elementsFromDOM = Array.from(myRef.current.querySelectorAll("[data-roving-tabindex-item]"));
    return Array.from(elements.current).sort((a, b) => elementsFromDOM.indexOf(a[1]) - elementsFromDOM.indexOf(b[1])).map(([value, element]) => ({ value, element }));
  };
  (0, import_react58.useEffect)(() => {
    setFocusableValue(activeValue ?? null);
  }, [activeValue]);
  return (0, import_jsx_runtime48.jsx)(RovingFocusContext.Provider, { value: {
    elements,
    getOrderedItems,
    focusableValue,
    setFocusableValue,
    onShiftTab: () => {
      setIsShiftTabbing(true);
    },
    orientation
  }, children: (0, import_jsx_runtime48.jsx)(Component, { ...rest, tabIndex: isShiftTabbing ? -1 : 0, onBlur: (e) => {
    onBlur == null ? void 0 : onBlur(e);
    setIsShiftTabbing(false);
    setFocusableValue(activeValue ?? null);
  }, onFocus: (e) => {
    var _a4, _b, _c;
    onFocus == null ? void 0 : onFocus(e);
    if (e.target !== e.currentTarget)
      return;
    const orderedItems = getOrderedItems();
    if (orderedItems.length === 0)
      return;
    if (focusableValue != null) {
      (_a4 = elements.current.get(focusableValue)) == null ? void 0 : _a4.focus();
    } else if (activeValue != null) {
      (_b = elements.current.get(activeValue)) == null ? void 0 : _b.focus();
    } else {
      (_c = orderedItems.at(0)) == null ? void 0 : _c.element.focus();
    }
  }, ref: refs }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Tabs/TabsList.js
var TabsList = (0, import_react59.forwardRef)(function TabsList2({ children, ...rest }, ref) {
  const { value } = (0, import_react59.useContext)(Context);
  return (0, import_jsx_runtime49.jsx)(RovingFocusRoot, { role: "tablist", activeValue: value, orientation: "ambiguous", ref, ...rest, children });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Tabs/TabsPanel.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_react60 = __toESM(require_react(), 1);
var TabsPanel = (0, import_react60.forwardRef)(function TabsPanel2({ children, value, ...rest }, ref) {
  const { value: tabsValue } = (0, import_react60.useContext)(Context);
  const active = value === tabsValue;
  const [hasTabbableElement, setHasTabbableElement] = (0, import_react60.useState)(false);
  const internalRef = (0, import_react60.useRef)(null);
  const mergedRef = useMergeRefs([ref, internalRef]);
  (0, import_react60.useEffect)(() => {
    if (!internalRef.current)
      return;
    const tabbableElements = internalRef.current.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    setHasTabbableElement(tabbableElements.length > 0);
  }, [children]);
  return (0, import_jsx_runtime50.jsx)(import_jsx_runtime50.Fragment, { children: active && (0, import_jsx_runtime50.jsx)("div", { ref: mergedRef, role: "tabpanel", tabIndex: hasTabbableElement ? void 0 : 0, ...rest, children }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Tabs/TabsTab.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/RovingFocus/RovingFocusItem.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react64 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/RovingFocus/useRovingFocus.js
var import_react62 = __toESM(require_react(), 1);
var useRovingFocus = (value) => {
  const { elements, getOrderedItems, setFocusableValue, focusableValue, onShiftTab, orientation } = (0, import_react62.useContext)(RovingFocusContext);
  return {
    getOrderedItems,
    isFocusable: focusableValue === value,
    orientation,
    getRovingProps: (props) => ({
      ...props,
      ref: (element) => {
        if (element) {
          elements.current.set(value, element);
        } else {
          elements.current.delete(value);
        }
      },
      onKeyDown: (e) => {
        var _a4;
        (_a4 = props == null ? void 0 : props.onKeyDown) == null ? void 0 : _a4.call(props, e);
        if (e.shiftKey && e.key === "Tab") {
          onShiftTab();
          return;
        }
      },
      onFocus: (e) => {
        var _a4;
        (_a4 = props == null ? void 0 : props.onFocus) == null ? void 0 : _a4.call(props, e);
        setFocusableValue(value);
      },
      "data-roving-tabindex-item": true,
      tabIndex: focusableValue === value ? 0 : -1
    })
  };
};

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/RovingFocus/RovingFocusItem.js
function getNextFocusableValue(items, value) {
  const currIndex = items.findIndex((item) => item.value === value);
  return items.at(currIndex === items.length - 1 ? 0 : currIndex + 1);
}
function getPrevFocusableValue(items, value) {
  const currIndex = items.findIndex((item) => item.value === value);
  return items.at(currIndex === 0 ? -1 : currIndex - 1);
}
var RovingFocusItem = (0, import_react64.forwardRef)(({ value, asChild, ...rest }, ref) => {
  const Component = asChild ? Slot : "div";
  const focusValue = value ?? (typeof rest.children === "string" ? rest.children : "");
  const { getOrderedItems, getRovingProps, orientation } = useRovingFocus(focusValue);
  const rovingProps = getRovingProps({
    onKeyDown: (e) => {
      var _a4;
      (_a4 = rest == null ? void 0 : rest.onKeyDown) == null ? void 0 : _a4.call(rest, e);
      const items = getOrderedItems();
      let nextItem;
      switch (orientation) {
        case "horizontal":
          if (e.key === "ArrowRight") {
            nextItem = getNextFocusableValue(items, focusValue);
          }
          if (e.key === "ArrowLeft") {
            nextItem = getPrevFocusableValue(items, focusValue);
          }
          break;
        case "vertical":
          if (e.key === "ArrowDown") {
            nextItem = getNextFocusableValue(items, focusValue);
          }
          if (e.key === "ArrowUp") {
            nextItem = getPrevFocusableValue(items, focusValue);
          }
          break;
        case "ambiguous":
          if (["ArrowRight", "ArrowDown"].includes(e.key)) {
            nextItem = getNextFocusableValue(items, focusValue);
          }
          if (["ArrowLeft", "ArrowUp"].includes(e.key)) {
            nextItem = getPrevFocusableValue(items, focusValue);
          }
      }
      if (e.key === "Home") {
        nextItem = items[0];
      }
      if (e.key === "End") {
        nextItem = items[items.length - 1];
      }
      if (nextItem) {
        e.preventDefault();
        nextItem.element.focus();
      }
    }
  });
  const mergedRefs = useMergeRefs([ref, rovingProps.ref]);
  return (0, import_jsx_runtime51.jsx)(Component, { ...rest, ...rovingProps, ref: mergedRefs, children: rest.children });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Tabs/TabsTab.js
var TabsTab = (0, import_react65.forwardRef)(function TabsTab2({ value, id: id3, ...rest }, ref) {
  const tabs = (0, import_react65.useContext)(Context);
  const buttonId = id3 ?? `tab-${(0, import_react65.useId)()}`;
  return (0, import_jsx_runtime52.jsx)(RovingFocusItem, { value, ...rest, asChild: true, children: (0, import_jsx_runtime52.jsx)("button", { ...rest, "aria-selected": tabs.value === value, id: buttonId, onClick: () => {
    var _a4;
    return (_a4 = tabs.onChange) == null ? void 0 : _a4.call(tabs, value);
  }, ref, role: "tab", type: "button" }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Tabs/index.js
var Tabs3 = Object.assign(Tabs, {
  List: TabsList,
  Tab: TabsTab,
  Panel: TabsPanel
});
Tabs3.Tab.displayName = "Tabs.Tab";
Tabs3.List.displayName = "Tabs.List";
Tabs3.Panel.displayName = "Tabs.Panel";

// node_modules/@digdir/designsystemet-react/dist/esm/components/ToggleGroup/ToggleGroup.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react66 = __toESM(require_react(), 1);
var ToggleGroupContext = (0, import_react66.createContext)({});
var ToggleGroup = (0, import_react66.forwardRef)(function ToggleGroup2({ children, value, defaultValue, onChange, name, className, ...rest }, ref) {
  const nameId = (0, import_react66.useId)();
  const isControlled = value !== void 0;
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react66.useState)(defaultValue);
  let onValueChange = onChange;
  if (!isControlled) {
    onValueChange = (newValue) => {
      setUncontrolledValue(newValue);
      onChange == null ? void 0 : onChange(newValue);
    };
    value = uncontrolledValue;
  }
  return (0, import_jsx_runtime53.jsx)(ToggleGroupContext.Provider, { value: {
    value,
    defaultValue,
    name: name ?? `togglegroup-name-${nameId}`,
    onChange: onValueChange
  }, children: (0, import_jsx_runtime53.jsx)(RovingFocusRoot, { asChild: true, activeValue: value, orientation: "ambiguous", children: (0, import_jsx_runtime53.jsxs)("div", { className: lite_default("ds-togglegroup", className), role: "radiogroup", ref, ...rest, children: [name && (0, import_jsx_runtime53.jsx)("input", { type: "hidden", name, value }), children] }) }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/ToggleGroup/ToggleGroupItem.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_react68 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/ToggleGroup/useToggleGroupitem.js
var import_react67 = __toESM(require_react(), 1);
var useToggleGroupItem = (props) => {
  const { ...rest } = props;
  const genValue = (0, import_react67.useId)();
  const toggleGroup = (0, import_react67.useContext)(ToggleGroupContext);
  const value = props.value ?? genValue;
  const active = toggleGroup.value === value;
  const buttonId = `togglegroup-item-${(0, import_react67.useId)()}`;
  return {
    ...rest,
    active,
    value,
    buttonProps: {
      id: buttonId,
      "aria-checked": active,
      "aria-current": active,
      role: "radio",
      name: toggleGroup.name,
      onClick: () => {
        var _a4;
        (_a4 = toggleGroup.onChange) == null ? void 0 : _a4.call(toggleGroup, value);
      }
    }
  };
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/ToggleGroup/ToggleGroupItem.js
var ToggleGroupItem = (0, import_react68.forwardRef)(function ToggleGroupItem2(rest, ref) {
  const { active, buttonProps, value } = useToggleGroupItem(rest);
  return (0, import_jsx_runtime54.jsx)(RovingFocusItem, { asChild: true, value, children: (0, import_jsx_runtime54.jsx)(Button, { variant: active ? "primary" : "tertiary", ref, ...rest, ...buttonProps }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/ToggleGroup/index.js
var ToggleGroup3 = Object.assign(ToggleGroup, {
  Item: ToggleGroupItem
});
ToggleGroup3.Item.displayName = "ToggleGroup.Item";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Popover/Popover.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_react71 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Popover/PopoverTriggerContext.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_react69 = __toESM(require_react(), 1);
var PopoverTriggerContext = ({ children }) => {
  const randomPopoverId = (0, import_react69.useId)();
  const [popoverId, setPopoverId] = (0, import_react69.useState)(randomPopoverId);
  return (0, import_jsx_runtime55.jsx)(Context2.Provider, { value: { popoverId, setPopoverId }, children });
};
PopoverTriggerContext.displayName = "PopoverTriggerContext";
var Context2 = (0, import_react69.createContext)({});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Popover/Popover.js
var Popover = (0, import_react71.forwardRef)(function Popover2({ id: id3, className, onClose, onOpen, open, variant = "default", placement = "top", autoPlacement: autoPlacement4 = true, asChild = false, ...rest }, ref) {
  const Component = asChild ? Slot : "div";
  const popoverRef = (0, import_react71.useRef)(null);
  const mergedRefs = useMergeRefs([popoverRef, ref]);
  const { popoverId, setPopoverId } = (0, import_react71.useContext)(Context2);
  const [internalOpen, setInternalOpen] = (0, import_react71.useState)(false);
  const controlledOpen = open ?? internalOpen;
  (0, import_react71.useEffect)(() => {
    var _a4;
    const popover = popoverRef.current;
    const handleClick = (event) => {
      var _a5;
      const el = event.target;
      const isTrigger = (_a5 = el == null ? void 0 : el.closest) == null ? void 0 : _a5.call(el, `[popovertarget="${popover == null ? void 0 : popover.id}"]`);
      const isOutside = !isTrigger && !(popover == null ? void 0 : popover.contains(el));
      if (isTrigger) {
        event.preventDefault();
        setInternalOpen((open2) => !open2);
        onOpen == null ? void 0 : onOpen();
      }
      if (isOutside) {
        setInternalOpen(false);
        onClose == null ? void 0 : onClose();
      }
    };
    const handleKeydown = (event) => {
      if (event.key !== "Escape" || !controlledOpen)
        return;
      event.preventDefault();
      setInternalOpen(false);
      onClose == null ? void 0 : onClose();
    };
    (_a4 = popover == null ? void 0 : popover.togglePopover) == null ? void 0 : _a4.call(popover, controlledOpen);
    document.addEventListener("click", handleClick, true);
    document.addEventListener("keydown", handleKeydown);
    return () => {
      document.removeEventListener("click", handleClick, true);
      document.removeEventListener("keydown", handleKeydown);
    };
  }, [controlledOpen]);
  (0, import_react71.useEffect)(() => {
    const popover = popoverRef.current;
    const trigger = document.querySelector(`[popovertarget="${popover == null ? void 0 : popover.id}"]`);
    if (popover && trigger && controlledOpen)
      return autoUpdate(trigger, popover, () => {
        computePosition2(trigger, popover, {
          placement,
          strategy: "fixed",
          middleware: [
            offset2((data) => {
              const styles = getComputedStyle(data.elements.floating, "::before");
              return parseFloat(styles.height);
            }),
            ...autoPlacement4 ? [flip2({ fallbackAxisSideDirection: "start" }), shift2()] : [],
            arrowPseudoElement2
          ]
        }).then(({ x, y }) => {
          popover.style.translate = `${x}px ${y}px`;
        });
      });
  }, [controlledOpen, placement, id3, autoPlacement4]);
  (0, import_react71.useEffect)(() => {
    if (id3)
      setPopoverId == null ? void 0 : setPopoverId(id3);
  }, [id3]);
  return (0, import_jsx_runtime56.jsx)(Component, {
    className: lite_default("ds-popover", className),
    id: id3 || popoverId,
    // @ts-ignore @types/react-dom does not understand popover yet
    popover: "manual",
    "data-variant": variant,
    ref: mergedRefs,
    ...rest
  });
});
var arrowPseudoElement2 = {
  name: "ArrowPseudoElement",
  fn(data) {
    const { elements, rects, placement } = data;
    let arrowX = `${Math.round(rects.reference.width / 2 + rects.reference.x - data.x)}px`;
    let arrowY = `${Math.round(rects.reference.height / 2 + rects.reference.y - data.y)}px`;
    if (rects.reference.width > rects.floating.width) {
      arrowX = `${Math.round(rects.floating.width / 2)}px`;
    }
    if (rects.reference.height > rects.floating.height) {
      arrowY = `${Math.round(rects.floating.height / 2)}px`;
    }
    switch (placement.split("-")[0]) {
      case "top":
        arrowY = "100%";
        break;
      case "right":
        arrowX = "0";
        break;
      case "bottom":
        arrowY = "0";
        break;
      case "left":
        arrowX = "100%";
        break;
    }
    elements.floating.setAttribute("data-placement", placement.split("-")[0]);
    elements.floating.style.setProperty("--ds-popover-arrow-x", arrowX);
    elements.floating.style.setProperty("--ds-popover-arrow-y", arrowY);
    return data;
  }
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/Popover/PopoverTrigger.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_react72 = __toESM(require_react(), 1);
var PopoverTrigger = (0, import_react72.forwardRef)(function PopoverTrigger2({ id: id3, inline: inline4, asChild, ...rest }, ref) {
  const { popoverId } = (0, import_react72.useContext)(Context2);
  const Component = asChild ? Slot : inline4 ? "button" : Button;
  const popoverProps = Object.assign({
    [import_react72.version.startsWith("19") ? "popoverTarget" : "popovertarget"]: popoverId,
    ...inline4 ? {
      "data-popover": "inline"
    } : {}
  }, rest);
  return (0, import_jsx_runtime57.jsx)(Component, { ref, ...popoverProps });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Popover/index.js
var Popover3 = Object.assign(Popover, {
  TriggerContext: PopoverTriggerContext,
  Trigger: PopoverTrigger
});
Popover3.TriggerContext.displayName = "Popover.TriggerContext";
Popover3.Trigger.displayName = "Popover.Trigger";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Divider/Divider.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_react73 = __toESM(require_react(), 1);
var Divider = (0, import_react73.forwardRef)(function Divider2({ className, ...rest }, ref) {
  return (
    // biome-ignore lint/a11y/noAriaHiddenOnFocusable: <hr> is not foucsable but biome thinks it is
    (0, import_jsx_runtime58.jsx)("hr", { "aria-hidden": "true", className: lite_default("ds-divider", className), ref, ...rest })
  );
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dialog/Dialog.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_react76 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dialog/DialogTriggerContext.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react74 = __toESM(require_react(), 1);
var Context3 = (0, import_react74.createContext)({
  current: null
});
var DialogTriggerContext = ({ children }) => {
  const contextRef = (0, import_react74.useRef)(null);
  return (0, import_jsx_runtime59.jsx)(Context3.Provider, { value: contextRef, children });
};
DialogTriggerContext.displayName = "DialogTriggerContext";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dialog/Dialog.js
var Dialog = (0, import_react76.forwardRef)(function Dialog2({ asChild, children, className, closeButton = "Lukk dialogvindu", closedby = "closerequest", modal = true, onClose, open, ...rest }, ref) {
  const contextRef = (0, import_react76.useContext)(Context3);
  const dialogRef = (0, import_react76.useRef)(null);
  const Component = asChild ? Slot : "dialog";
  const mergedRefs = useMergeRefs([contextRef, ref, dialogRef]);
  const showProp = modal ? "showModal" : "show";
  (0, import_react76.useEffect)(() => {
    var _a4;
    return (_a4 = dialogRef.current) == null ? void 0 : _a4[open ? showProp : "close"]();
  }, [open]);
  (0, import_react76.useEffect)(() => {
    const dialog = dialogRef.current;
    const handleClosedby = (event) => {
      var _a4;
      const { clientY: y, clientX: x, target } = event;
      if (event instanceof KeyboardEvent)
        return closedby === "none" && event.key === "Escape" && event.preventDefault();
      if ((_a4 = window.getSelection()) == null ? void 0 : _a4.toString())
        return;
      if (dialog && target === dialog && closedby === "any") {
        const { top, left, right, bottom } = dialog.getBoundingClientRect();
        const isInDialog = top <= y && y <= bottom && left <= x && x <= right;
        if (!isInDialog)
          dialog == null ? void 0 : dialog.close();
      }
    };
    const handleAutoFocus = () => {
      const autofocus = dialog == null ? void 0 : dialog.querySelector("[autofocus]");
      if (document.activeElement !== autofocus)
        autofocus == null ? void 0 : autofocus.focus();
    };
    dialog == null ? void 0 : dialog.addEventListener("animationend", handleAutoFocus);
    dialog == null ? void 0 : dialog.addEventListener("click", handleClosedby);
    dialog == null ? void 0 : dialog.addEventListener("keydown", handleClosedby);
    return () => {
      dialog == null ? void 0 : dialog.removeEventListener("animationend", handleAutoFocus);
      dialog == null ? void 0 : dialog.removeEventListener("click", handleClosedby);
      dialog == null ? void 0 : dialog.removeEventListener("keydown", handleClosedby);
    };
  }, [closedby]);
  (0, import_react76.useEffect)(() => {
    var _a4;
    const handleClose = (event) => onClose == null ? void 0 : onClose(event);
    (_a4 = dialogRef.current) == null ? void 0 : _a4.addEventListener("close", handleClose);
    return () => {
      var _a5;
      return (_a5 = dialogRef.current) == null ? void 0 : _a5.removeEventListener("close", handleClose);
    };
  }, [onClose]);
  return (0, import_jsx_runtime60.jsxs)(Component, { className: lite_default("ds-dialog", className), ref: mergedRefs, "data-modal": modal, ...rest, children: [closeButton !== false && (0, import_jsx_runtime60.jsx)("form", { method: "dialog", children: (0, import_jsx_runtime60.jsx)(Button, { "aria-label": closeButton, autoFocus: true, "data-color": "neutral", icon: true, name: "close", type: "submit", variant: "tertiary" }) }), children] });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dialog/DialogBlock.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var import_react77 = __toESM(require_react(), 1);
var DialogBlock = (0, import_react77.forwardRef)(function DialogBlock2({ asChild, className, ...rest }, ref) {
  const Component = asChild ? Slot : "div";
  return (0, import_jsx_runtime61.jsx)(Component, { className: lite_default("ds-dialog__block", className), ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dialog/DialogTrigger.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react78 = __toESM(require_react(), 1);
var DialogTrigger = (0, import_react78.forwardRef)(function DialogTrigger2({ asChild, ...rest }, ref) {
  const contextRef = (0, import_react78.useContext)(Context3);
  const Component = asChild ? Slot : Button;
  const openDialog = () => {
    var _a4, _b, _c;
    ((_a4 = contextRef.current) == null ? void 0 : _a4.getAttribute("data-modal")) === "true" ? (_b = contextRef.current) == null ? void 0 : _b.showModal() : (_c = contextRef.current) == null ? void 0 : _c.show();
  };
  return (0, import_jsx_runtime62.jsx)(Component, { "aria-haspopup": "dialog", onClick: openDialog, ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dialog/index.js
var Dialog3 = Object.assign(Dialog, {
  Block: DialogBlock,
  TriggerContext: DialogTriggerContext,
  Trigger: DialogTrigger
});
Dialog3.Block.displayName = "Dialog.Block";
Dialog3.TriggerContext.displayName = "Dialog.TriggerContext";
Dialog3.Trigger.displayName = "Dialog.Trigger";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dropdown/Dropdown.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_react79 = __toESM(require_react(), 1);
var Dropdown = (0, import_react79.forwardRef)(function DropdownContent({ placement = "bottom-end", className, ...rest }, ref) {
  return (0, import_jsx_runtime63.jsx)(Popover3, { className: lite_default("ds-dropdown", className), placement, ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dropdown/DropdownButton.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react80 = __toESM(require_react(), 1);
var DropdownButton = (0, import_react80.forwardRef)(function DropdownButton2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime64.jsx)(Button, { ref, variant: "tertiary", ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dropdown/DropdownHeading.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var import_react81 = __toESM(require_react(), 1);
var DropdownHeading = (0, import_react81.forwardRef)(function DropdownHeading2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime65.jsx)(Heading, { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dropdown/DropdownItem.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var import_react82 = __toESM(require_react(), 1);
var DropdownItem = (0, import_react82.forwardRef)(function DropdownItem2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime66.jsx)("li", { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dropdown/DropdownList.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react83 = __toESM(require_react(), 1);
var DropdownList = (0, import_react83.forwardRef)(function DropdownList2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime67.jsx)("ul", { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dropdown/DropdownTrigger.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var import_react84 = __toESM(require_react(), 1);
var DropdownTrigger = (0, import_react84.forwardRef)(function DropdownTrigger2({ asChild, ...rest }, ref) {
  return (0, import_jsx_runtime68.jsx)(PopoverTrigger, { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dropdown/DropdownTriggerContext.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var DropdownTriggerContext = ({ children }) => {
  return (0, import_jsx_runtime69.jsx)(PopoverTriggerContext, { children });
};
DropdownTriggerContext.displayName = "DropdownTriggerContext";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Dropdown/index.js
var Dropdown2 = Object.assign(Dropdown, {
  TriggerContext: DropdownTriggerContext,
  Heading: DropdownHeading,
  List: DropdownList,
  Item: DropdownItem,
  Button: DropdownButton,
  Trigger: DropdownTrigger
});
Dropdown2.TriggerContext.displayName = "Dropdown.TriggerContext";
Dropdown2.List.displayName = "Dropdown.List";
Dropdown2.Heading.displayName = "Dropdown.Heading";
Dropdown2.Item.displayName = "Dropdown.Item";
Dropdown2.Button.displayName = "Dropdown.Button";
Dropdown2.Trigger.displayName = "Dropdown.Trigger";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Search/SearchClear.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var import_react90 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/utilities.js
var import_react89 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Custom.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_react88 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/ComboboxContext.js
var import_react85 = __toESM(require_react(), 1);
var ComboboxContext = (0, import_react85.createContext)(void 0);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/ComboboxIdContext.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_react86 = __toESM(require_react(), 1);
var ComboboxIdContext = (0, import_react86.createContext)({
  activeIndex: 0
});
var ComboboxIdReducer = (state, action) => {
  switch (action.type) {
    case "SET_ACTIVE_INDEX":
      return {
        ...state,
        activeIndex: action.payload
      };
    default:
      return state;
  }
};
var ComboboxIdDispatch = (0, import_react86.createContext)(() => {
  throw new Error("ComboboxIdDispatch must be used within a provider");
});
var ComboboxIdProvider = ({ children }) => {
  const [state, dispatch] = (0, import_react86.useReducer)(ComboboxIdReducer, {
    activeIndex: 0
  });
  return (0, import_jsx_runtime70.jsx)(ComboboxIdContext.Provider, { value: state, children: (0, import_jsx_runtime70.jsx)(ComboboxIdDispatch.Provider, { value: dispatch, children }) });
};
function useComboboxIdDispatch() {
  return (0, import_react86.useContext)(ComboboxIdDispatch);
}
function useComboboxId() {
  return (0, import_react86.useContext)(ComboboxIdContext);
}

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/omit/omit.js
var omit = (names, obj) => {
  const result = {};
  const index3 = {};
  let idx = 0;
  const len = names.length;
  while (idx < len) {
    index3[names[idx]] = 1;
    idx += 1;
  }
  for (const prop in obj) {
    if (!Object.prototype.hasOwnProperty.call(index3, prop)) {
      result[prop] = obj[prop];
    }
  }
  return result;
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Custom.js
var ComboboxCustom = (0, import_react88.forwardRef)(({ asChild, interactive, id: id3, className, ...rest }, ref) => {
  if (interactive && !id3) {
    throw new Error("If ComboboxCustom is interactive, it must have an id");
  }
  const Component = asChild ? Slot : "div";
  const randomId = (0, import_react88.useId)();
  const { activeIndex } = useComboboxId();
  const context = (0, import_react88.useContext)(ComboboxContext);
  if (!context) {
    throw new Error("ComboboxCustom must be used within a Combobox");
  }
  const { customIds, setListRef, getItemProps, size: size4 } = context;
  const index3 = (0, import_react88.useMemo)(() => id3 && customIds.indexOf(id3) || 0, [id3, customIds]);
  const combinedRef = useMergeRefs([
    (node) => {
      setListRef(index3, node);
    },
    ref
  ]);
  return (0, import_jsx_runtime71.jsx)(Label, { "data-size": size4, asChild: true, children: (0, import_jsx_runtime71.jsx)(Component, { ref: combinedRef, tabIndex: -1, className: lite_default("ds-combobox__custom", className), id: id3 || randomId, role: "option", "aria-selected": activeIndex === index3, "data-active": activeIndex === index3, ...omit(["interactive"], rest), ...omit(["onClick", "onPointerLeave"], getItemProps()) }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/utilities.js
function isComboboxCustom(child) {
  return (0, import_react89.isValidElement)(child) && child.type === ComboboxCustom;
}
function isInteractiveComboboxCustom(child) {
  return isComboboxCustom(child) && child.props.interactive === true;
}
var INTERNAL_OPTION_PREFIX = "internal-option-";
var prefix = (value) => {
  return INTERNAL_OPTION_PREFIX + value;
};
var removePrefix = (value) => {
  return value.slice(INTERNAL_OPTION_PREFIX.length);
};
var setReactInputValue = (input, value) => {
  const previousValue = input.value;
  input.value = value;
  const tracker = input._valueTracker;
  if (typeof tracker !== "undefined") {
    tracker.setValue(previousValue);
  }
  input.dispatchEvent(new Event("change", { bubbles: true }));
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/Search/SearchClear.js
var SearchClear = (0, import_react90.forwardRef)(function SearchClear2({ "aria-label": label2 = "TÃ¸m", onClick: onClick3, ...rest }, ref) {
  const handleClear = (e) => {
    var _a4;
    const target = e.target;
    let input = null;
    if (target instanceof HTMLElement)
      input = (_a4 = target.closest(".ds-search")) == null ? void 0 : _a4.querySelector("input");
    if (!input)
      throw new Error("Input is missing");
    if (!(input instanceof HTMLInputElement))
      throw new Error("Input is not an input element");
    e.preventDefault();
    setReactInputValue(input, "");
    input.focus();
    onClick3 == null ? void 0 : onClick3(e);
  };
  return (0, import_jsx_runtime72.jsx)(Button, { ref, variant: "tertiary", type: "reset", "aria-label": label2, onClick: handleClear, icon: true, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Search/SearchButton.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var import_react91 = __toESM(require_react(), 1);
var SearchButton = (0, import_react91.forwardRef)(function SearchButton2({ children = "SÃ¸k", ...rest }, ref) {
  return (0, import_jsx_runtime73.jsx)(Button, { ref, type: "submit", ...rest, children });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Search/SearchInput.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var import_react92 = __toESM(require_react(), 1);
var SearchInput = (0, import_react92.forwardRef)(function SearchInput2({ ...rest }, ref) {
  return (0, import_jsx_runtime74.jsx)(Input, {
    ref,
    type: "search",
    /* We need an empty placeholder for the clear button to be able to show/hide */
    placeholder: "",
    ...rest
  });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Search/Search.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var import_react93 = __toESM(require_react(), 1);
var Search = (0, import_react93.forwardRef)(function Search2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime75.jsx)("div", { ref, className: lite_default("ds-search", className), ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Search/index.js
var Search3 = Object.assign(Search, {
  Clear: SearchClear,
  Button: SearchButton,
  Input: SearchInput
});
Search3.Clear.displayName = "Search.Clear";
Search3.Button.displayName = "Search.Button";
Search3.Input.displayName = "Search.Input";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Card/Card.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var import_react95 = __toESM(require_react(), 1);
var Card = (0, import_react95.forwardRef)(function Card2({ asChild = false, variant = "default", className, ...rest }, ref) {
  const Component = asChild ? Slot : "div";
  const cardRef = (0, import_react95.useRef)(null);
  const mergedRefs = useMergeRefs([cardRef, ref]);
  (0, import_react95.useEffect)(() => {
    const card = cardRef.current;
    const handleClick = ({ ctrlKey, metaKey, target }) => {
      const link = card == null ? void 0 : card.querySelector(":is(h1,h2,h3,h4,h5,h6) a");
      if (!link || (link == null ? void 0 : link.contains(target)))
        return;
      if (ctrlKey || metaKey)
        window.open(link.href, "", "noreferrer");
      else
        link.click();
    };
    card == null ? void 0 : card.addEventListener("click", handleClick);
    return () => card == null ? void 0 : card.removeEventListener("click", handleClick);
  }, []);
  return (0, import_jsx_runtime76.jsx)(Component, { className: lite_default(`ds-card`, className), "data-variant": variant, ref: mergedRefs, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Card/CardBlock.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_react96 = __toESM(require_react(), 1);
var CardBlock = (0, import_react96.forwardRef)(function CardBlock2({ asChild, className, ...rest }, ref) {
  const Component = asChild ? Slot : "div";
  return (0, import_jsx_runtime77.jsx)(Component, { className: lite_default(`ds-card__block`, className), ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Card/index.js
var Card3 = Object.assign(Card, {
  Block: CardBlock
});
Card3.Block.displayName = "Card.Block";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Combobox.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);

// node_modules/@tanstack/react-virtual/dist/esm/index.js
var React5 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// node_modules/@tanstack/virtual-core/dist/esm/utils.js
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  function memoizedFunction() {
    var _a4, _b, _c, _d;
    let depTime;
    if (opts.key && ((_a4 = opts.debug) == null ? void 0 : _a4.call(opts)))
      depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index3) => deps[index3] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts)))
      resultTime = Date.now();
    result = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);
    return result;
  }
  memoizedFunction.updateDeps = (newDeps) => {
    deps = newDeps;
  };
  return memoizedFunction;
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
  } else {
    return value;
  }
}
var approxEqual = (a, b) => Math.abs(a - b) < 1;
var debounce = (targetWindow, fn, ms) => {
  let timeoutId2;
  return function(...args) {
    targetWindow.clearTimeout(timeoutId2);
    timeoutId2 = targetWindow.setTimeout(() => fn.apply(this, args), ms);
  };
};

// node_modules/@tanstack/virtual-core/dist/esm/index.js
var defaultKeyExtractor = (index3) => index3;
var defaultRangeExtractor = (range) => {
  const start = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i = start; i <= end; i++) {
    arr.push(i);
  }
  return arr;
};
var observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(element.getBoundingClientRect());
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const run = () => {
      const entry = entries[0];
      if (entry == null ? void 0 : entry.borderBoxSize) {
        const box = entry.borderBoxSize[0];
        if (box) {
          handler({ width: box.inlineSize, height: box.blockSize });
          return;
        }
      }
      handler(element.getBoundingClientRect());
    };
    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
var addEventListenerOptions = {
  passive: true
};
var supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
var observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset4 = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset4, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset4 = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
    fallback();
    cb(offset4, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
var measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size4 = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size4;
    }
  }
  return Math.round(
    element.getBoundingClientRect()[instance.options.horizontal ? "width" : "height"]
  );
};
var elementScroll = (offset4, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a4, _b;
  const toOffset = offset4 + adjustments;
  (_b = (_a4 = instance.scrollElement) == null ? void 0 : _a4.scrollTo) == null ? void 0 : _b.call(_a4, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
var Virtualizer = class {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.scrollToIndexTimeoutId = null;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = (() => {
      let _ro = null;
      const get = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        });
      };
      return {
        disconnect: () => {
          var _a4;
          (_a4 = get()) == null ? void 0 : _a4.disconnect();
          _ro = null;
        },
        observe: (target) => {
          var _a4;
          return (_a4 = get()) == null ? void 0 : _a4.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a4;
          return (_a4 = get()) == null ? void 0 : _a4.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined")
          delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        useScrollendEvent: false,
        useAnimationFrameWithResizeObserver: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a4, _b;
      (_b = (_a4 = this.options).onChange) == null ? void 0 : _b.call(_a4, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key: "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d) => d());
      this.unsubs = [];
      this.observer.disconnect();
      this.scrollElement = null;
      this.targetWindow = null;
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a4;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a4 = this.scrollElement) == null ? void 0 : _a4.window) ?? null;
        }
        this.elementsCache.forEach((cached) => {
          this.observer.observe(cached);
        });
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset4, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset4 ? "forward" : "backward" : null;
            this.scrollOffset = offset4;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index3) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m = index3 - 1; m >= 0; m--) {
        const measurement = measurements[m];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {
        if (a.end === b.end) {
          return a.index - b.index;
        }
        return a.end - b.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (count2, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count: count2,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: count2, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          return [];
        }
        if (this.measurementsCache.length === 0) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min2 = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min2);
        for (let i = min2; i < count2; i++) {
          const key = getItemKey(i);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);
          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size4 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i);
          const end = start + size4;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;
          measurements[i] = {
            index: i,
            start,
            size: size4,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: "getMeasurements",
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (measurements, outerSize, scrollOffset, lanes) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset,
          lanes
        }) : null;
      },
      {
        key: "calculateRange",
        debug: () => this.options.debug
      }
    );
    this.getVirtualIndexes = memo(
      () => {
        let startIndex = null;
        let endIndex = null;
        const range = this.calculateRange();
        if (range) {
          startIndex = range.startIndex;
          endIndex = range.endIndex;
        }
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          startIndex,
          endIndex
        ];
      },
      (rangeExtractor, overscan, count2, startIndex, endIndex) => {
        return startIndex === null || endIndex === null ? [] : rangeExtractor({
          startIndex,
          endIndex,
          overscan,
          count: count2
        });
      },
      {
        key: "getVirtualIndexes",
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const index3 = this.indexFromElement(node);
      const item = this.measurementsCache[index3];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.elementsCache.set(key, node);
      }
      if (node.isConnected) {
        this.resizeItem(index3, this.options.measureElement(node, entry, this));
      }
    };
    this.resizeItem = (index3, size4) => {
      const item = this.measurementsCache[index3];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size4 - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          if (this.options.debug) {
            console.info("correction", delta);
          }
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size4));
        this.notify(false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k = 0, len = indexes.length; k < len; k++) {
          const i = indexes[k];
          const measurement = measurements[i];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: "getVirtualItems",
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset4) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index3) => notUndefined(measurements[index3]).start,
          offset4
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      const size4 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size4 ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size4) / 2;
      } else if (align === "end") {
        toOffset -= size4;
      }
      const scrollSizeProp = this.options.horizontal ? "scrollWidth" : "scrollHeight";
      const scrollSize = this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;
      const maxOffset = scrollSize - size4;
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index3, align = "auto") => {
      index3 = Math.max(0, Math.min(index3, this.options.count - 1));
      const item = this.measurementsCache[index3];
      if (!item) {
        return void 0;
      }
      const size4 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size4 - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(toOffset, align, item.size),
        align
      ];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.cancelScrollToIndex = () => {
      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {
        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);
        this.scrollToIndexTimeoutId = null;
      }
    };
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index3, { align: initialAlign = "auto", behavior } = {}) => {
      index3 = Math.max(0, Math.min(index3, this.options.count - 1));
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      const offsetAndAlign = this.getOffsetForIndex(index3, initialAlign);
      if (!offsetAndAlign)
        return;
      const [offset4, align] = offsetAndAlign;
      this._scrollToOffset(offset4, { adjustments: void 0, behavior });
      if (behavior !== "smooth" && this.isDynamicMode() && this.targetWindow) {
        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {
          this.scrollToIndexTimeoutId = null;
          const elementInDOM = this.elementsCache.has(
            this.options.getItemKey(index3)
          );
          if (elementInDOM) {
            const [latestOffset] = notUndefined(
              this.getOffsetForIndex(index3, align)
            );
            if (!approxEqual(latestOffset, this.getScrollOffset())) {
              this.scrollToIndex(index3, { align, behavior });
            }
          } else {
            this.scrollToIndex(index3, { align, behavior });
          }
        });
      }
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a4;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else if (this.options.lanes === 1) {
        end = ((_a4 = measurements[measurements.length - 1]) == null ? void 0 : _a4.end) ?? 0;
      } else {
        const endByLane = Array(this.options.lanes).fill(null);
        let endIndex = measurements.length - 1;
        while (endIndex > 0 && endByLane.some((val) => val === null)) {
          const item = measurements[endIndex];
          if (endByLane[item.lane] === null) {
            endByLane[item.lane] = item.end;
          }
          endIndex--;
        }
        end = Math.max(...endByLane.filter((val) => val !== null));
      }
      return Math.max(
        end - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    };
    this._scrollToOffset = (offset4, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset4, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
};
var findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset,
  lanes
}) {
  const lastIndex = measurements.length - 1;
  const getOffset = (index3) => measurements[index3].start;
  let startIndex = findNearestBinarySearch(
    0,
    lastIndex,
    getOffset,
    scrollOffset
  );
  let endIndex = startIndex;
  if (lanes === 1) {
    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {
      endIndex++;
    }
  } else if (lanes > 1) {
    const endPerLane = Array(lanes).fill(0);
    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
      const item = measurements[endIndex];
      endPerLane[item.lane] = item.end;
      endIndex++;
    }
    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
    while (startIndex > 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
      const item = measurements[startIndex];
      startPerLane[item.lane] = item.start;
      startIndex--;
    }
    startIndex = Math.max(0, startIndex - startIndex % lanes);
    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
  }
  return { startIndex, endIndex };
}

// node_modules/@tanstack/react-virtual/dist/esm/index.js
var useIsomorphicLayoutEffect2 = typeof document !== "undefined" ? React5.useLayoutEffect : React5.useEffect;
function useVirtualizerBase(options) {
  const rerender = React5.useReducer(() => ({}), {})[1];
  const resolvedOptions = {
    ...options,
    onChange: (instance2, sync) => {
      var _a4;
      if (sync) {
        (0, import_react_dom3.flushSync)(rerender);
      } else {
        rerender();
      }
      (_a4 = options.onChange) == null ? void 0 : _a4.call(options, instance2, sync);
    }
  };
  const [instance] = React5.useState(
    () => new Virtualizer(resolvedOptions)
  );
  instance.setOptions(resolvedOptions);
  useIsomorphicLayoutEffect2(() => {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect2(() => {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll,
    ...options
  });
}

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Combobox.js
var import_react112 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/useFormField/useFormField.js
var import_react98 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/useFormField/FieldsetContext.js
var import_react97 = __toESM(require_react(), 1);
var FieldsetContext = (0, import_react97.createContext)(null);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/useFormField/useFormField.js
var useFormField = (props, prefix2) => {
  const fieldset = (0, import_react98.useContext)(FieldsetContext);
  const randomId = (0, import_react98.useId)();
  const id3 = props.id ?? `${prefix2}-${randomId}`;
  const errorId = props.errorId ?? `${prefix2}-error-${randomId}`;
  const descriptionId = `${prefix2}-description-${randomId}`;
  const size4 = props.size ?? (fieldset == null ? void 0 : fieldset.size) ?? "md";
  const disabled = (fieldset == null ? void 0 : fieldset.disabled) || (props == null ? void 0 : props.disabled);
  const hasError = !disabled && !!(props.error || (fieldset == null ? void 0 : fieldset.error));
  return {
    hasError,
    errorId,
    descriptionId,
    size: size4,
    inputProps: {
      id: id3,
      disabled,
      "aria-invalid": hasError ? true : void 0,
      "aria-describedby": lite_default(props["aria-describedby"], !!(props == null ? void 0 : props.description) && typeof (props == null ? void 0 : props.description) === "string" && descriptionId, hasError && !(fieldset == null ? void 0 : fieldset.error) && errorId, hasError && !!(fieldset == null ? void 0 : fieldset.error) && (fieldset == null ? void 0 : fieldset.errorId)) || void 0
    }
  };
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/internal/ComboboxError.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var ComboboxError = ({ size: size4, error: error2, formFieldProps }) => {
  return (0, import_jsx_runtime78.jsx)("div", { className: "ds-combobox__error-message", id: formFieldProps.errorId, "aria-live": "polite", "aria-relevant": "additions removals", children: error2 && (0, import_jsx_runtime78.jsx)(ValidationMessage, { "data-size": size4, children: error2 }) });
};
ComboboxError.displayName = "ComboboxError";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/internal/ComboboxInput.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var import_react102 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/internal/ComboboxChips.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_react99 = __toESM(require_react(), 1);
var ComboboxChips = () => {
  const context = (0, import_react99.useContext)(ComboboxContext);
  if (!context) {
    throw new Error("ComboboxContext is missing");
  }
  const { size: size4, readOnly, disabled, selectedOptions, chipSrLabel, handleSelectOption, inputRef } = context;
  return (0, import_jsx_runtime79.jsx)(import_jsx_runtime79.Fragment, { children: Object.keys(selectedOptions).map((value) => {
    return (0, import_jsx_runtime79.jsx)(ChipRemovable, { "data-size": size4, disabled, onKeyDown: (e) => {
      var _a4;
      if (readOnly)
        return;
      if (disabled)
        return;
      if (e.key === "Enter") {
        e.stopPropagation();
        handleSelectOption({
          option: selectedOptions[value],
          remove: true
        });
        (_a4 = inputRef == null ? void 0 : inputRef.current) == null ? void 0 : _a4.focus();
      }
    }, onClick: () => {
      if (readOnly)
        return;
      if (disabled)
        return;
      handleSelectOption({
        option: selectedOptions[value],
        remove: true
      });
    }, "aria-label": chipSrLabel(selectedOptions[value]), children: selectedOptions[value].label }, value);
  }) });
};
ComboboxChips.displayName = "ComboboxChips";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/internal/ComboboxClearButton.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var import_react100 = __toESM(require_react(), 1);
var ComboboxClearButton = (0, import_react100.forwardRef)((props, ref) => {
  const context = (0, import_react100.useContext)(ComboboxContext);
  if (!context) {
    throw new Error("ComboboxContext is missing");
  }
  const { readOnly, disabled, clearButtonLabel, handleSelectOption } = context;
  return (0, import_jsx_runtime80.jsx)("button", { ...props, ref, disabled, className: lite_default("ds-combobox__clear-button", `ds-focus`), onClick: () => {
    if (readOnly)
      return;
    if (disabled)
      return;
    handleSelectOption({ option: null, clear: true });
  }, onKeyDown: (e) => {
    if (readOnly)
      return;
    if (disabled)
      return;
    if (e.key === "Enter") {
      e.stopPropagation();
      handleSelectOption({ option: null, clear: true });
    }
  }, type: "button", "aria-label": clearButtonLabel, children: (0, import_jsx_runtime80.jsx)(XMark_default, { fontSize: "1.5em", title: "Clear selection" }) });
});
ComboboxClearButton.displayName = "ComboboxClearButton";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/internal/ComboboxInput.js
var ComboboxInput = ({ hideClearButton, listId, error: error2, hideChips, handleKeyDown, ...rest }) => {
  const context = (0, import_react102.useContext)(ComboboxContext);
  const idDispatch = useComboboxIdDispatch();
  const clearButtonRef = (0, import_react102.useRef)(null);
  if (!context) {
    throw new Error("ComboboxContext is missing");
  }
  const setActiveIndex = (id3) => {
    idDispatch == null ? void 0 : idDispatch({ type: "SET_ACTIVE_INDEX", payload: id3 });
  };
  const { forwareddRef, readOnly, disabled, open, inputRef, refs, inputValue, multiple, selectedOptions, formFieldProps, htmlSize, options, setOpen, getReferenceProps, setInputValue, handleSelectOption, size: size4 } = context;
  const mergedRefs = useMergeRefs([forwareddRef, inputRef]);
  const onChange = (event) => {
    const value = event.target.value;
    setInputValue(value);
    setActiveIndex(0);
    for (const option of Object.values(options)) {
      if (option.label.toLowerCase() === value.toLowerCase()) {
        if (selectedOptions[prefix(option.value)])
          continue;
        handleSelectOption({ option });
      }
    }
  };
  const showClearButton = !hideClearButton && Object.keys(selectedOptions).length > 0;
  const props = getReferenceProps({
    ref: refs == null ? void 0 : refs.setReference,
    role: null,
    "aria-controls": null,
    "aria-expanded": null,
    "aria-haspopup": null,
    /* If we click the wrapper, toggle open, set index to first option, and focus the input */
    onClick(event) {
      var _a4, _b;
      if (disabled)
        return;
      if (readOnly)
        return;
      if ((_a4 = clearButtonRef.current) == null ? void 0 : _a4.contains(event.target))
        return;
      setOpen(!open);
      setActiveIndex(0);
      (_b = inputRef.current) == null ? void 0 : _b.focus();
    },
    /* Handles list navigation */
    onKeyDown: handleKeyDown,
    // preventDefault on keydown to avoid sending in form
    onKeyPress(event) {
      if (event.key === "Enter") {
        event.preventDefault();
      }
    }
  });
  return (0, import_jsx_runtime81.jsx)(Paragraph, { "data-size": size4, asChild: true, children: (0, import_jsx_runtime81.jsxs)("div", { ...props, "aria-disabled": disabled ? "true" : void 0, className: lite_default("ds-textfield__input", "ds-combobox__input__wrapper", readOnly && "ds-combobox--readonly", error2 && "ds-combobox--error"), children: [(0, import_jsx_runtime81.jsxs)("div", { className: "ds-combobox__chip-and-input", children: [multiple && !hideChips && (0, import_jsx_runtime81.jsx)(ComboboxChips, {}), (0, import_jsx_runtime81.jsx)(Paragraph, { "data-size": size4, asChild: true, children: (0, import_jsx_runtime81.jsx)("input", { ref: mergedRefs, "aria-activedescendant": props["aria-activedescendant"], readOnly, "aria-autocomplete": "list", role: "combobox", "aria-expanded": open, "aria-controls": open ? listId : void 0, autoComplete: "off", size: htmlSize, value: inputValue, ...omit(["style", "className"], rest), ...formFieldProps.inputProps, className: "ds-combobox__input", onChange: (e) => {
    var _a4;
    onChange(e);
    !open && setOpen(true);
    (_a4 = rest.onChange) == null ? void 0 : _a4.call(rest, e);
  } }) })] }), showClearButton && (0, import_jsx_runtime81.jsx)(ComboboxClearButton, { ref: clearButtonRef }), (0, import_jsx_runtime81.jsx)("div", { className: "ds-combobox__arrow", children: open ? (0, import_jsx_runtime81.jsx)(ChevronUp_default, { title: "arrow up", fontSize: "1.5em" }) : (0, import_jsx_runtime81.jsx)(ChevronDown_default, { title: "arrow down", fontSize: "1.5em" }) })] }) });
};
ComboboxInput.displayName = "ComboboxInput";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/internal/ComboboxLabel.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var ComboboxLabel = ({ label: label2, description, hideLabel, size: size4, readOnly, formFieldProps }) => {
  return (0, import_jsx_runtime82.jsxs)(import_jsx_runtime82.Fragment, { children: [label2 && (0, import_jsx_runtime82.jsxs)(Label, { "data-size": size4, htmlFor: formFieldProps.inputProps.id, className: lite_default("ds-combobox__label", hideLabel && `ds-sr-only`), children: [readOnly && (0, import_jsx_runtime82.jsx)(PadlockLockedFill_default, { "aria-hidden": true, className: "ds-combobox__readonly__icon" }), label2] }), description && (0, import_jsx_runtime82.jsx)(Paragraph, { asChild: true, "data-size": size4, children: (0, import_jsx_runtime82.jsx)("div", { id: formFieldProps.descriptionId, className: lite_default("ds-combobox__description", hideLabel && `ds-sr-only`), children: description }) })] });
};
ComboboxLabel.displayName = "ComboboxLabel";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/internal/ComboboxNative.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var ComboboxNative = ({ selectedOptions, multiple, name }) => {
  const VALUE = Object.keys(selectedOptions).map((key) => removePrefix(key));
  return (0, import_jsx_runtime83.jsx)("select", { name, multiple, style: { display: "none" }, value: multiple ? VALUE : VALUE[0], onChange: () => {
  }, children: VALUE.map((value) => (0, import_jsx_runtime83.jsx)("option", { value }, value)) });
};
ComboboxNative.displayName = "ComboboxNative";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/useCombobox.js
var import_react108 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Option/Option.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var import_react107 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Option/Description.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var import_react103 = __toESM(require_react(), 1);
var ComboboxOptionDescription = (0, import_react103.forwardRef)(({ children, className, ...rest }, ref) => {
  return (0, import_jsx_runtime84.jsx)("span", { className: lite_default("ds-combobox__option__description", className), ref, ...rest, children });
});
ComboboxOptionDescription.displayName = "ComboboxOptionDescription";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Option/SelectedIcon.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var SelectedIcon = ({ multiple, selected }) => {
  return (0, import_jsx_runtime85.jsx)("div", { className: lite_default(multiple && "ds-combobox__option__icon-wrapper", selected && "ds-combobox__option__icon-wrapper--selected"), children: selected && (0, import_jsx_runtime85.jsx)(Checkmark_default, { className: "ds-combobox__option__icon-wrapper__icon", "aria-hidden": true }) });
};
SelectedIcon.displayName = "SelectedIcon";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Option/useComboboxOption.js
var import_react106 = __toESM(require_react(), 1);

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/hooks/useDebounceCallback/useDebounceCallback.js
var import_react104 = __toESM(require_react(), 1);
function useDebounceCallback(callback, delay = 50) {
  const timeoutRef = (0, import_react104.useRef)(null);
  (0, import_react104.useEffect)(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);
  const debouncedCallback = (...args) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    timeoutRef.current = window.setTimeout(() => {
      callback(...args);
    }, delay);
  };
  return debouncedCallback;
}

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Option/useComboboxOption.js
var useComboboxOption = ({ id: id3, ref, value }) => {
  const generatedId = (0, import_react106.useId)();
  const newId = id3 || generatedId;
  const context = (0, import_react106.useContext)(ComboboxContext);
  const { activeIndex } = useComboboxId();
  const dispatch = useComboboxIdDispatch();
  if (!context) {
    throw new Error("ComboboxOption must be used within a Combobox");
  }
  const { selectedOptions, onOptionClick, setListRef, customIds, filteredOptions } = context;
  const index3 = (0, import_react106.useMemo)(() => filteredOptions.indexOf(prefix(String(value))) + customIds.length, [customIds.length, filteredOptions, value]);
  const combinedRef = useMergeRefs([
    (node) => {
      setListRef(index3, node);
    },
    ref
  ]);
  if (index3 === -1) {
    throw new Error("Internal error: ComboboxOption did not find index");
  }
  const selected = selectedOptions[prefix(value)];
  const active = activeIndex === index3;
  (0, import_react106.useEffect)(() => {
    if (active) {
      dispatch == null ? void 0 : dispatch({ type: "SET_ACTIVE_INDEX", payload: index3 });
    }
  }, [generatedId, id3, dispatch, active, index3]);
  const onOptionClickDebounced = useDebounceCallback(() => onOptionClick(value), 50);
  return {
    id: newId,
    ref: combinedRef,
    selected,
    active,
    onOptionClick: onOptionClickDebounced
  };
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Option/Option.js
var ComboboxOption = (0, import_react107.memo)((0, import_react107.forwardRef)(({ value, description, children, className, ...rest }, forwardedRef) => {
  const labelId = (0, import_react107.useId)();
  const { id: id3, ref, selected, active, onOptionClick } = useComboboxOption({
    id: rest.id,
    ref: forwardedRef,
    value
  });
  const context = (0, import_react107.useContext)(ComboboxContext);
  if (!context) {
    throw new Error("ComboboxOption must be used within a Combobox");
  }
  const { size: size4, multiple, getItemProps } = context;
  const props = getItemProps();
  return (0, import_jsx_runtime86.jsx)(Label, { "data-size": "md", asChild: true, children: (0, import_jsx_runtime86.jsxs)("button", {
    ref,
    id: id3,
    // biome-ignore lint/a11y/useSemanticElements: biome wants me to use the <option> element
    role: "option",
    type: "button",
    "aria-selected": !!selected,
    "aria-labelledby": labelId,
    tabIndex: -1,
    onClick: (e) => {
      var _a4;
      onOptionClick();
      (_a4 = rest.onClick) == null ? void 0 : _a4.call(rest, e);
    },
    className: lite_default("ds-combobox__option", active && "ds-combobox__option--active", multiple && "ds-combobox__option--multiple", className),
    ...omit(["displayValue"], rest),
    ...omit(["onClick", "onPointerLeave"], props),
    children: [(0, import_jsx_runtime86.jsx)(Label, { asChild: true, "data-size": size4, children: (0, import_jsx_runtime86.jsx)("span", { children: (0, import_jsx_runtime86.jsx)(SelectedIcon, { multiple, selected: !!selected }) }) }), (0, import_jsx_runtime86.jsxs)(Label, { className: "ds-combobox__option__label", "data-size": size4, id: labelId, children: [children, description && (0, import_jsx_runtime86.jsx)(ComboboxOptionDescription, { children: description })] })]
  }) });
}));
ComboboxOption.displayName = "ComboboxOption";
function isComboboxOption(child) {
  return (0, import_react107.isValidElement)(child) && child.type === ComboboxOption;
}

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/useCombobox.js
var isOption = (option) => !!option;
function useCombobox({ children, inputValue, multiple, filter = (inputValue2, option) => {
  return option.label.toLowerCase().startsWith(inputValue2.toLowerCase());
}, initialValue }) {
  const filterCallback = (0, import_react108.useCallback)(filter, [filter]);
  const { optionsChildren, customIds, restChildren, interactiveChildren } = (0, import_react108.useMemo)(() => {
    const allChildren = import_react108.Children.toArray(children);
    const result = allChildren.reduce((acc, child) => {
      if (isComboboxOption(child)) {
        acc.optionsChildren.push(child);
      } else {
        acc.restChildren.push(child);
        if (isInteractiveComboboxCustom(child)) {
          const childElement = child;
          acc.interactiveChildren.push(childElement);
          if (!childElement.props.id) {
            throw new Error("If ComboboxCustom is interactive, it must have an id");
          }
          acc.customIds.push(childElement.props.id);
        }
      }
      return acc;
    }, {
      optionsChildren: [],
      customIds: [],
      restChildren: [],
      interactiveChildren: []
    });
    return result;
  }, [children]);
  const options = (0, import_react108.useMemo)(() => {
    const values = [];
    const allOptions = {};
    optionsChildren.map((child) => {
      const props = child.props;
      let label2 = props.displayValue || "";
      if (!props.displayValue) {
        let childrenLabel = "";
        import_react108.Children.forEach(props.children, (child2) => {
          if (typeof child2 === "string") {
            childrenLabel += child2;
          } else {
            throw new Error("If ComboboxOption is not a string, it must have a displayValue prop");
          }
        });
        label2 = childrenLabel;
      }
      if (values.includes(props.value)) {
        console.warn(`Combobox has multiple options with the same value: ${props.value}`);
      }
      values.push(props.value);
      allOptions[prefix(String(props.value))] = {
        value: String(props.value),
        label: label2,
        displayValue: props.displayValue,
        description: props.description
      };
    });
    return allOptions;
  }, [optionsChildren]);
  const preSelectedOptions = (0, import_react108.useMemo)(() => ((initialValue == null ? void 0 : initialValue.map((key) => {
    return prefix(key);
  })) || []).reduce((acc, value) => {
    const option = options[value];
    if (isOption(option)) {
      acc[value] = option;
    }
    return acc;
  }, {}), [initialValue, options]);
  const [selectedOptions, setSelectedOptions] = (0, import_react108.useState)(preSelectedOptions);
  const { filteredOptions, filteredOptionsChildren } = (0, import_react108.useMemo)(() => {
    const filteredOptions2 = [];
    const filteredOptionsChildren2 = Object.keys(options).map((option, index3) => {
      if (!multiple && Object.keys(selectedOptions).length === 1) {
        filteredOptions2.push(option);
        return optionsChildren[index3];
      }
      if (multiple && selectedOptions[option]) {
        filteredOptions2.push(option);
        return optionsChildren[index3];
      }
      if (filterCallback(inputValue, options[option])) {
        filteredOptions2.push(option);
        return optionsChildren[index3];
      }
      return;
    }).filter((child) => child);
    return { filteredOptions: filteredOptions2, filteredOptionsChildren: filteredOptionsChildren2 };
  }, [
    filterCallback,
    inputValue,
    multiple,
    options,
    optionsChildren,
    selectedOptions
  ]);
  return {
    filteredOptionsChildren,
    filteredOptions,
    restChildren,
    options,
    customIds,
    selectedOptions,
    interactiveChildren,
    setSelectedOptions
  };
}

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/useComboboxKeyboard.js
var useComboboxKeyboard = ({ readOnly, disabled, interactiveChildren, filteredOptions, inputValue, selectedOptions, multiple, open, options, setOpen, handleSelectOption }) => {
  const { activeIndex } = useComboboxId();
  const handleKeyDownFunc = (event) => {
    if (readOnly || disabled)
      return;
    if (!event)
      return;
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        if (open)
          break;
        setOpen(true);
        break;
      case "ArrowUp":
        event.preventDefault();
        if (activeIndex !== 0)
          break;
        setOpen(false);
        break;
      case "Enter": {
        event.preventDefault();
        if (!open)
          break;
        if (activeIndex <= interactiveChildren.length - 1) {
          const selectedComponent = interactiveChildren[activeIndex];
          if (selectedComponent.props.onSelect) {
            selectedComponent == null ? void 0 : selectedComponent.props.onSelect();
            return;
          }
        }
        const valueIndex = activeIndex - interactiveChildren.length;
        const option = filteredOptions[valueIndex];
        handleSelectOption({ option: options[option] });
        break;
      }
      case "Backspace":
        if (!multiple) {
          const lastOption = Object.keys(selectedOptions).pop();
          lastOption && handleSelectOption({
            option: selectedOptions[lastOption],
            remove: true
          });
          break;
        }
        if (inputValue === "" && multiple) {
          const lastOption = Object.keys(selectedOptions).pop();
          lastOption && handleSelectOption({
            option: selectedOptions[lastOption],
            remove: true
          });
        }
        break;
    }
  };
  const handleKeyDown = useDebounceCallback(handleKeyDownFunc, 20);
  return handleKeyDown;
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/useFloatingCombobox.js
var import_react110 = __toESM(require_react(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
var useFloatingCombobox = ({ listRef }) => {
  const [open, setOpen] = (0, import_react110.useState)(false);
  const { activeIndex } = useComboboxId();
  const dispatch = useComboboxIdDispatch();
  const { refs, floatingStyles, context } = useFloating2({
    open,
    onOpenChange: (newOpen) => {
      if (!newOpen)
        dispatch == null ? void 0 : dispatch({ type: "SET_ACTIVE_INDEX", payload: 0 });
      (0, import_react_dom4.flushSync)(() => {
        if (refs.floating.current && !newOpen) {
          refs.floating.current.scrollTop = 0;
        }
        setTimeout(() => {
          setOpen(newOpen);
        }, 1);
      });
    },
    whileElementsMounted: (reference, floating, update) => {
      autoUpdate(reference, floating, update);
      return () => {
        floating.scrollTop = 0;
      };
    },
    middleware: [
      flip3({ padding: 10 }),
      size3({
        apply({ rects, elements }) {
          requestAnimationFrame(() => {
            Object.assign(elements.floating.style, {
              width: `${rects.reference.width}px`,
              maxHeight: `200px`
            });
          });
        }
      }),
      offset3(10)
    ]
  });
  const role = useRole(context, { role: "listbox" });
  const dismiss = useDismiss(context);
  const listNav = useListNavigation(context, {
    listRef,
    activeIndex,
    virtual: true,
    scrollItemIntoView: true,
    enabled: open,
    focusItemOnHover: true,
    onNavigate: (index3) => {
      dispatch == null ? void 0 : dispatch({ type: "SET_ACTIVE_INDEX", payload: index3 || 0 });
    }
  });
  const { getReferenceProps, getFloatingProps, getItemProps } = useInteractions([role, dismiss, listNav]);
  return {
    open,
    setOpen,
    activeIndex,
    refs,
    floatingStyles,
    context,
    getReferenceProps,
    getFloatingProps,
    getItemProps
  };
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Combobox.js
var ComboboxComponent = (0, import_react112.forwardRef)(({ value, initialValue = [], onValueChange, label: label2, hideLabel = false, description, multiple = false, disabled = false, readOnly = false, hideChips = false, clearButtonLabel = "Fjern alt", hideClearButton = false, error: error2, errorId, id: id3, name, portal = true, htmlSize = 0, virtual = false, children, style, size: size4 = "md", loading, loadingLabel = "Laster...", filter, chipSrLabel = (option) => "Slett " + option.label, className, ...rest }, forwareddRef) => {
  const inputRef = (0, import_react112.useRef)(null);
  const portalRef = (0, import_react112.useRef)(null);
  const listRef = (0, import_react112.useRef)([]);
  const [inputValue, setInputValue] = (0, import_react112.useState)(rest.inputValue || "");
  (0, import_react112.useEffect)(() => {
    if (typeof rest.inputValue === "string") {
      setInputValue(rest.inputValue);
    }
  }, [rest.inputValue]);
  const { selectedOptions, options, restChildren, interactiveChildren, customIds, filteredOptionsChildren, filteredOptions, setSelectedOptions } = useCombobox({
    children,
    inputValue,
    filter,
    multiple,
    initialValue
  });
  const { open, setOpen, refs, floatingStyles, context, getReferenceProps, getFloatingProps, getItemProps } = useFloatingCombobox({
    listRef
  });
  const formFieldProps = useFormField({
    disabled,
    error: error2,
    errorId,
    size: size4,
    description,
    id: id3
  }, "combobox");
  (0, import_react112.useEffect)(() => {
    if (value && value.length > 0 && !multiple) {
      const option = options[prefix(value[0])];
      inputRef.current && setReactInputValue(inputRef.current, (option == null ? void 0 : option.label) || "");
    }
  }, [multiple, value, options]);
  (0, import_react112.useEffect)(() => {
    if (value && Object.keys(options).length >= 0) {
      const updatedSelectedOptions = value.map((option) => {
        const value2 = options[prefix(option)];
        return value2;
      });
      setSelectedOptions(updatedSelectedOptions.reduce((acc, value2) => {
        acc[prefix(value2.value)] = value2;
        return acc;
      }, {}));
    }
  }, [multiple, value, options, setSelectedOptions]);
  const handleSelectOption = (args) => {
    var _a4, _b;
    const { option, clear, remove } = args;
    if (clear) {
      setSelectedOptions({});
      inputRef.current && setReactInputValue(inputRef.current, "");
      onValueChange == null ? void 0 : onValueChange([]);
      return;
    }
    if (!option)
      return;
    if (remove) {
      const newSelectedOptions2 = { ...selectedOptions };
      delete newSelectedOptions2[prefix(option.value)];
      setSelectedOptions(newSelectedOptions2);
      onValueChange == null ? void 0 : onValueChange(Object.keys(newSelectedOptions2).map((key) => removePrefix(key)));
      return;
    }
    const newSelectedOptions = { ...selectedOptions };
    if (multiple) {
      if (newSelectedOptions[prefix(option.value)]) {
        delete newSelectedOptions[prefix(option.value)];
      } else {
        newSelectedOptions[prefix(option.value)] = option;
      }
      inputRef.current && setReactInputValue(inputRef.current, "");
      (_a4 = inputRef.current) == null ? void 0 : _a4.focus();
    } else {
      for (const key of Object.keys(newSelectedOptions)) {
        delete newSelectedOptions[key];
      }
      newSelectedOptions[prefix(option.value)] = option;
      inputRef.current && setReactInputValue(inputRef.current, (option == null ? void 0 : option.label) || "");
      setTimeout(() => {
        var _a5, _b2, _c;
        (_c = inputRef.current) == null ? void 0 : _c.setSelectionRange(((_a5 = option == null ? void 0 : option.label) == null ? void 0 : _a5.length) || 0, ((_b2 = option == null ? void 0 : option.label) == null ? void 0 : _b2.length) || 0);
      }, 0);
    }
    setSelectedOptions(newSelectedOptions);
    onValueChange == null ? void 0 : onValueChange(Object.keys(newSelectedOptions).map((key) => removePrefix(key)));
    !multiple && setOpen(false);
    (_b = refs.domReference.current) == null ? void 0 : _b.focus();
  };
  const debouncedHandleSelectOption = useDebounceCallback(handleSelectOption, 50);
  const handleKeyDown = useComboboxKeyboard({
    filteredOptions,
    selectedOptions,
    readOnly: formFieldProps.readOnly || false,
    disabled,
    multiple,
    inputValue,
    options,
    open,
    interactiveChildren,
    setOpen,
    handleSelectOption: debouncedHandleSelectOption
  });
  const rowVirtualizer = useVirtualizer({
    count: Object.keys(filteredOptionsChildren).length,
    getScrollElement: () => virtual ? refs.floating.current : null,
    estimateSize: () => 70,
    measureElement: (elem) => {
      return elem.getBoundingClientRect().height;
    },
    overscan: 7
  });
  return (0, import_jsx_runtime87.jsxs)(ComboboxContext.Provider, { value: {
    size: size4,
    options,
    selectedOptions,
    multiple,
    disabled,
    readOnly,
    open,
    inputRef,
    refs,
    inputValue,
    formFieldProps,
    htmlSize,
    clearButtonLabel,
    customIds,
    filteredOptions,
    setInputValue,
    setOpen,
    getReferenceProps,
    getItemProps,
    /* Recieves the value of the option, and searches for it in our values lookup */
    onOptionClick: (value2) => {
      if (readOnly)
        return;
      if (disabled)
        return;
      const option = options[prefix(value2)];
      debouncedHandleSelectOption({ option });
    },
    handleSelectOption: debouncedHandleSelectOption,
    chipSrLabel,
    listRef,
    forwareddRef,
    setListRef: (index3, node) => {
      listRef.current[index3] = node;
    }
  }, children: [(0, import_jsx_runtime87.jsxs)("div", { className: lite_default("ds-combobox", `ds-combobox--${size4}`, disabled && "ds-combobox__disabled", className), style, ref: portalRef, children: [name && (0, import_jsx_runtime87.jsx)(ComboboxNative, { name, selectedOptions, multiple }), (0, import_jsx_runtime87.jsx)(ComboboxLabel, { label: label2, description, size: size4, readOnly, hideLabel, formFieldProps }), (0, import_jsx_runtime87.jsx)(ComboboxInput, { ...omit(["inputValue"], rest), hideClearButton, listId: context.floatingId || "", error: error2, hideChips, handleKeyDown, "aria-busy": loading }), (0, import_jsx_runtime87.jsx)(ComboboxError, { size: size4, error: error2, formFieldProps })] }), open && (0, import_jsx_runtime87.jsx)(FloatingPortal, { root: portal ? null : portalRef, children: (0, import_jsx_runtime87.jsx)(FloatingFocusManager, { context, initialFocus: -1, visuallyHiddenDismiss: true, children: (0, import_jsx_runtime87.jsxs)("div", { "aria-labelledby": formFieldProps.inputProps.id, "aria-autocomplete": "list", tabIndex: -1, ...getFloatingProps({
    ref: refs.setFloating,
    style: {
      ...floatingStyles
    }
  }), className: lite_default("ds-combobox__options-wrapper", `ds-combobox--${size4}`), children: [virtual && (0, import_jsx_runtime87.jsx)("div", { style: {
    height: `${rowVirtualizer.getTotalSize()}px`,
    width: "100%",
    position: "relative"
  }, children: rowVirtualizer.getVirtualItems().map((virtualRow) => (0, import_jsx_runtime87.jsx)("div", { ref: rowVirtualizer.measureElement, "data-index": virtualRow.index, style: {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    transform: `translateY(${virtualRow.start}px)`
  }, children: filteredOptionsChildren[virtualRow.index] }, virtualRow.index)) }), loading ? (0, import_jsx_runtime87.jsxs)(ComboboxCustom, { className: "ds-combobox__loading", children: [(0, import_jsx_runtime87.jsx)(Spinner, { "aria-label": "Laster", "data-size": "sm" }), loadingLabel] }) : (0, import_jsx_runtime87.jsxs)(import_jsx_runtime87.Fragment, { children: [restChildren, !virtual && filteredOptionsChildren] })] }) }) })] });
});
var Combobox = (0, import_react112.forwardRef)((props, ref) => (0, import_jsx_runtime87.jsx)(ComboboxIdProvider, { children: (0, import_jsx_runtime87.jsx)(ComboboxComponent, { ...props, ref }) }));
Combobox.displayName = "Combobox";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/Empty.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var import_react113 = __toESM(require_react(), 1);
var ComboboxEmpty = (0, import_react113.forwardRef)(({ children, className, ...rest }, ref) => {
  const context = (0, import_react113.useContext)(ComboboxContext);
  if (!context) {
    throw new Error("ComboboxEmpty must be used within a Combobox");
  }
  const { filteredOptions, size: size4 } = context;
  return filteredOptions.length === 0 && (0, import_jsx_runtime88.jsx)(Label, { "data-size": size4, asChild: true, children: (0, import_jsx_runtime88.jsx)("div", { ref, className: lite_default("ds-combobox__empty", className), ...rest, children }) });
});
ComboboxEmpty.displayName = "ComboboxEmpty";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Combobox/index.js
var Combobox2 = Combobox;
Combobox2.Option = ComboboxOption;
Combobox2.Empty = ComboboxEmpty;
Combobox2.Option.displayName = "Combobox.Option";
Combobox2.Empty.displayName = "Combobox.Empty";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Table/Table.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var import_react114 = __toESM(require_react(), 1);
var Table = (0, import_react114.forwardRef)(function Table2({ zebra = false, stickyHeader = false, border = false, hover = false, className, children, ...rest }, ref) {
  return (0, import_jsx_runtime89.jsx)("table", { className: lite_default("ds-table", className), "data-border": border || void 0, "data-hover": hover || void 0, "data-sticky-header": stickyHeader || void 0, "data-zebra": zebra || void 0, ref, ...rest, children });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Table/TableBody.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var import_react115 = __toESM(require_react(), 1);
var TableBody = (0, import_react115.forwardRef)(function TableBody2(rest, ref) {
  return (0, import_jsx_runtime90.jsx)("tbody", { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Table/TableCell.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_react116 = __toESM(require_react(), 1);
var TableCell = (0, import_react116.forwardRef)(function TableCell2(rest, ref) {
  return (0, import_jsx_runtime91.jsx)("td", { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Table/TableFoot.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_react117 = __toESM(require_react(), 1);
var TableFoot = (0, import_react117.forwardRef)(function TableFoot2(rest, ref) {
  return (0, import_jsx_runtime92.jsx)("tfoot", { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Table/TableHead.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_react118 = __toESM(require_react(), 1);
var TableHead = (0, import_react118.forwardRef)(function TableHead2(rest, ref) {
  return (0, import_jsx_runtime93.jsx)("thead", { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Table/TableHeaderCell.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_react119 = __toESM(require_react(), 1);
var TableHeaderCell = (0, import_react119.forwardRef)(function TableHeaderCell2({ sort, children, ...rest }, ref) {
  return (0, import_jsx_runtime94.jsx)("th", { "aria-sort": sort, ref, ...rest, children: sort ? (0, import_jsx_runtime94.jsx)("button", { type: "button", children }) : children });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Table/TableRow.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react120 = __toESM(require_react(), 1);
var TableRow = (0, import_react120.forwardRef)(function TableRow2(rest, ref) {
  return (0, import_jsx_runtime95.jsx)("tr", { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Table/index.js
var Table3 = Object.assign(Table, {
  Head: TableHead,
  Body: TableBody,
  Row: TableRow,
  Cell: TableCell,
  HeaderCell: TableHeaderCell,
  Foot: TableFoot
});
Table3.displayName = "Table";
Table3.Head.displayName = "Table.Head";
Table3.Body.displayName = "Table.Body";
Table3.Row.displayName = "Table.Row";
Table3.Cell.displayName = "Table.Cell";
Table3.HeaderCell.displayName = "Table.HeaderCell";
Table3.Foot.displayName = "Table.Foot";

// node_modules/@digdir/designsystemet-react/dist/esm/components/ErrorSummary/ErrorSummary.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react121 = __toESM(require_react(), 1);
var ErrorSummaryContext = (0, import_react121.createContext)({
  headingId: "heading",
  setHeadingId: () => {
  }
});
var ErrorSummary = (0, import_react121.forwardRef)(function ErrorSummary2({ asChild, role = "alert", "aria-live": ariaLive = "polite", "aria-relevant": ariaRelevant = "all", className, ...rest }, ref) {
  const randomId = (0, import_react121.useId)();
  const [headingId, setHeadingId] = (0, import_react121.useState)(randomId);
  const Component = asChild ? Slot : "div";
  return (0, import_jsx_runtime96.jsx)(ErrorSummaryContext.Provider, { value: { headingId, setHeadingId }, children: (0, import_jsx_runtime96.jsx)(Component, { "aria-labelledby": headingId, "aria-live": ariaLive, "aria-relevant": ariaRelevant, className: lite_default("ds-error-summary", className), ref, role, ...rest }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/ErrorSummary/ErrorSummaryHeading.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react122 = __toESM(require_react(), 1);
var ErrorSummaryHeading = (0, import_react122.forwardRef)(function ErrorSummaryHeading2({ className, id: id3, ...rest }, ref) {
  const { headingId, setHeadingId } = (0, import_react122.useContext)(ErrorSummaryContext);
  (0, import_react122.useEffect)(() => {
    if (id3 && headingId !== id3)
      setHeadingId(id3);
  }, [headingId, id3, setHeadingId]);
  return (0, import_jsx_runtime97.jsx)(Heading, { id: headingId, ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/ErrorSummary/ErrorSummaryItem.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react123 = __toESM(require_react(), 1);
var ErrorSummaryItem = (0, import_react123.forwardRef)(function ErrorSummaryItem2({ ...rest }, ref) {
  return (0, import_jsx_runtime98.jsx)(ListItem, { ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/ErrorSummary/ErrorSummaryLink.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react124 = __toESM(require_react(), 1);
var ErrorSummaryLink = (0, import_react124.forwardRef)(function ErrorSummaryLink2({ ...rest }, ref) {
  return (0, import_jsx_runtime99.jsx)(Link, { ref, "data-color": "neutral", ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/ErrorSummary/ErrorSummaryList.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var import_react125 = __toESM(require_react(), 1);
var ErrorSummaryList = (0, import_react125.forwardRef)(function ErrorSummaryList2({ ...rest }, ref) {
  return (0, import_jsx_runtime100.jsx)(List.Unordered, { ...rest, ref });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/ErrorSummary/index.js
var ErrorSummary3 = Object.assign(ErrorSummary, {
  Heading: ErrorSummaryHeading,
  Item: ErrorSummaryItem,
  List: ErrorSummaryList,
  Link: ErrorSummaryLink
});
ErrorSummary3.Item.displayName = "ErrorSummary.Item";
ErrorSummary3.Heading.displayName = "ErrorSummary.Heading";
ErrorSummary3.List.displayName = "ErrorSummary.List";
ErrorSummary3.Link.displayName = "ErrorSummary.Link";

// node_modules/@digdir/designsystemet-react/dist/esm/components/Suggestion/Suggestion.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);

// node_modules/@u-elements/u-datalist/dist/u-datalist.js
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var IS_BROWSER2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.navigator !== "undefined";
var IS_ANDROID = IS_BROWSER2 && /android/i.test(navigator.userAgent);
var IS_FIREFOX = IS_BROWSER2 && /firefox/i.test(navigator.userAgent);
var IS_IOS = IS_BROWSER2 && /iPad|iPhone|iPod/.test(navigator.userAgent);
var IS_SAFARI = IS_BROWSER2 && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var _a2;
IS_BROWSER2 && // @ts-expect-error Typescript has not implemented userAgentData yet https://stackoverflow.com/a/71392474
/^Mac/i.test(((_a2 = navigator.userAgentData) == null ? void 0 : _a2.platform) || navigator.platform);
var SAFE_LABELLEDBY = `${IS_ANDROID ? "data" : "aria"}-labelledby`;
var SAFE_MULTISELECTABLE = `${IS_SAFARI ? "aria" : "data"}-multiselectable`;
var DISPLAY_BLOCK2 = ":host(:not([hidden])) { display: block }";
var FOCUS_OUTLINE = "outline: 1px dotted; outline: 5px auto Highlight; outline: 5px auto -webkit-focus-ring-color";
var UHTMLElement2 = typeof HTMLElement === "undefined" ? class {
} : HTMLElement;
function attr3(el, name, value) {
  var _a22;
  if (value === void 0)
    return (_a22 = el.getAttribute(name)) != null ? _a22 : null;
  if (value === null)
    el.removeAttribute(name);
  else if (el.getAttribute(name) !== value)
    el.setAttribute(name, value);
  return null;
}
var events2 = (action, element, rest) => {
  for (const type of rest[0].split(",")) {
    rest[0] = type;
    Element.prototype[`${action}EventListener`].apply(element, rest);
  }
};
var on2 = (element, ...rest) => events2("add", element, rest);
var off2 = (element, ...rest) => events2("remove", element, rest);
var attachStyle = (element, css) => element.attachShadow({ mode: "open" }).append(
  createElement3("slot"),
  // Unnamed slot does automatically render all top element nodes
  createElement3("style", css)
);
var observers = /* @__PURE__ */ new WeakMap();
var mutationObserver = (element, options) => {
  if (options === void 0)
    return observers.get(element);
  try {
    observers.get(element).disconnect();
    observers.delete(element);
  } catch (err) {
  }
  if (options) {
    const observer = new MutationObserver(
      (detail) => element.handleEvent({ type: "mutation", detail })
    );
    observer.observe(element, options);
    observers.set(element, observer);
  }
};
var getRoot2 = (node) => {
  var _a22;
  const root = ((_a22 = node.getRootNode) == null ? void 0 : _a22.call(node)) || node.ownerDocument;
  return root instanceof Document || root instanceof ShadowRoot ? root : document;
};
var id = 0;
var useId12 = (el) => {
  if (!el)
    return "";
  if (!el.id)
    el.id = `:${el.nodeName.toLowerCase()}${(++id).toString(32)}`;
  return el.id;
};
var createElement3 = (tagName, text, attrs) => {
  const el = document.createElement(tagName);
  if (text)
    el.textContent = text;
  return el;
};
var customElements2 = {
  define: (name, instance) => !IS_BROWSER2 || window.customElements.get(name) || window.customElements.define(name, instance)
};
var createAriaLive = (mode) => {
  if (!IS_BROWSER2)
    return null;
  const live = createElement3("div");
  live.style.cssText = "position:fixed;overflow:hidden;width:1px;white-space:nowrap";
  attr3(live, "aria-live", mode);
  return document.body.appendChild(live);
};
function attributeTexts(texts, prop, value) {
  if (!prop)
    return Object.keys(texts).map((key2) => `data-sr-${key2}`);
  const key = (prop == null ? void 0 : prop.startsWith("data-sr-")) && prop.slice(8);
  if (key && value && texts[key])
    texts[key] = value;
  return [];
}
var DISABLED = "disabled";
var SELECTED = "selected";
var UHTMLOptionElement = class extends UHTMLElement2 {
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return [DISABLED, SELECTED];
  }
  constructor() {
    super();
    attachStyle(
      this,
      `${DISPLAY_BLOCK2}:host(:focus){${FOCUS_OUTLINE}}:host{ cursor: pointer }`
    );
  }
  connectedCallback() {
    if (!IS_IOS)
      this.tabIndex = -1;
    if (!attr3(this, "role"))
      attr3(this, "role", "option");
    this.attributeChangedCallback();
  }
  attributeChangedCallback() {
    attr3(this, "aria-disabled", `${this.disabled}`);
    attr3(this, "aria-selected", `${this.selected}`);
  }
  /** Sets or retrieves whether the option in the list box is the default item. */
  get defaultSelected() {
    return this[SELECTED];
  }
  set defaultSelected(value) {
    this[SELECTED] = value;
  }
  get disabled() {
    return attr3(this, DISABLED) !== null;
  }
  set disabled(value) {
    attr3(this, DISABLED, value ? "" : null);
  }
  /** Retrieves a reference to the form that the object is embedded in. */
  get form() {
    return this.closest("form");
  }
  /** Sets or retrieves the ordinal position of an option in a list box. */
  get index() {
    var _a22;
    const options = (_a22 = this.closest("u-datalist")) == null ? void 0 : _a22.getElementsByTagName("u-option");
    return Array.from(options || [this]).indexOf(this);
  }
  /** Sets or retrieves a value that you can use to implement your own label functionality for the object. */
  get label() {
    return attr3(this, "label") || this.text;
  }
  set label(value) {
    attr3(this, "label", value);
  }
  get selected() {
    return attr3(this, SELECTED) !== null;
  }
  set selected(value) {
    attr3(this, SELECTED, value ? "" : null);
  }
  /** Sets or retrieves the text string specified by the option tag. */
  get text() {
    var _a22;
    return ((_a22 = this.textContent) == null ? void 0 : _a22.trim()) || "";
  }
  set text(text) {
    this.textContent = text;
  }
  /** Sets or retrieves the value which is returned to the server when the form control is submitted. */
  get value() {
    return attr3(this, "value") || this.text;
  }
  set value(value) {
    attr3(this, "value", value);
  }
};
customElements2.define("u-option", UHTMLOptionElement);
var IS_PRESS = false;
var LIVE_TIMER;
var LIVE_SR_FIX = 0;
var LIVE = createAriaLive("assertive");
var IS_SAFARI_MAC = IS_SAFARI && !IS_IOS;
var EVENTS = "click,focusout,input,keydown,mousedown,mouseup";
var TEXTS = {
  singular: "%d hit",
  plural: "%d hits"
};
var UHTMLDataListElement = class extends UHTMLElement2 {
  constructor() {
    super();
    this._blurTimer = 0;
    this._input = null;
    this._root = null;
    this._value = "";
    this._texts = __spreadValues({}, TEXTS);
    attachStyle(
      this,
      `${DISPLAY_BLOCK2}::slotted(u-option[disabled]) { display: none !important }`
      // Hide disabled options
    );
  }
  // Speed up translated texts
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return ["id", ...attributeTexts(TEXTS)];
  }
  connectedCallback() {
    this.hidden = true;
    this._root = getRoot2(this);
    if (LIVE && !LIVE.isConnected)
      document.body.append(LIVE);
    attr3(this, "role", "listbox");
    on2(this._root, "focusin", this);
    on2(this._root, "focus", this, true);
    setTimeout(() => this.attributeChangedCallback());
  }
  disconnectedCallback() {
    off2(this._root || this, "focus", this, true);
    off2(this._root || this, "focusin", this);
    disconnectInput(this);
    this._root = null;
  }
  attributeChangedCallback(prop, _prev, next) {
    var _a22;
    attributeTexts(this._texts, prop, next);
    const inputs = (_a22 = this._root) == null ? void 0 : _a22.querySelectorAll(`input[list="${this.id}"]`);
    for (const input of inputs || [])
      setupInput(this, input);
  }
  handleEvent(event) {
    const { type } = event;
    if (event.defaultPrevented)
      return;
    if (type === "click")
      onClick(this, event);
    if (type === "focus" || type === "focusin")
      onFocusIn(this, event);
    if (type === "focusout")
      onFocusOut(this);
    if (type === "keydown")
      onKeyDown(this, event);
    if (type === "mutation" || type === "input")
      setupOptions(this, event);
    if (type === "mouseup")
      IS_PRESS = false;
    if (type === "mousedown")
      IS_PRESS = this.contains(event.target);
  }
  get options() {
    return this.getElementsByTagName("u-option");
  }
};
var onFocusIn = (self, { target }) => {
  var _a22;
  const isInput3 = self._input === target;
  const isInside = isInput3 || self.contains(target);
  if (isInside)
    return clearTimeout(self._blurTimer);
  if (!isInput3 && target instanceof HTMLInputElement && attr3(target, "list") === self.id) {
    if (self._input)
      disconnectInput(self);
    self._input = target;
    attr3(self, SAFE_LABELLEDBY, useId12((_a22 = self._input.labels) == null ? void 0 : _a22[0]));
    on2(self._root || self, EVENTS, self);
    mutationObserver(self, {
      attributeFilter: ["value"],
      // Listen for value changes to show u-options
      attributes: true,
      childList: true,
      subtree: true
    });
    setExpanded(self, true);
  }
};
var onFocusOut = (self) => {
  if (!IS_PRESS)
    self._blurTimer = setTimeout(() => disconnectInput(self));
};
var onClick = (self, { target }) => {
  var _a22, _b, _c, _d, _e;
  const isSingle = attr3(self, SAFE_MULTISELECTABLE) !== "true";
  const option = [...self.options].find((opt) => opt.contains(target));
  if (self._input === target) {
    setExpanded(self, true);
  } else if (option && isInteractiveOption(option)) {
    for (const opt of self.options) {
      if (opt === option)
        opt.selected = true;
      else if (isSingle)
        opt.selected = false;
    }
    (_b = (_a22 = Object.getOwnPropertyDescriptor(
      HTMLInputElement.prototype,
      "value"
    )) == null ? void 0 : _a22.set) == null ? void 0 : _b.call(self._input, option.value);
    if (isSingle) {
      (_c = self._input) == null ? void 0 : _c.focus();
      setExpanded(self, false);
    }
    (_d = self._input) == null ? void 0 : _d.dispatchEvent(
      new Event("input", { bubbles: true, composed: true })
    );
    (_e = self._input) == null ? void 0 : _e.dispatchEvent(new Event("change", { bubbles: true }));
  }
};
var onKeyDown = (self, event) => {
  var _a22, _b;
  if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey)
    return;
  if (event.key !== "Escape")
    setExpanded(self, true);
  const { key } = event;
  const active = (_a22 = self._root) == null ? void 0 : _a22.activeElement;
  const options = getVisibleOptions(self);
  const index3 = options.indexOf(active);
  let next = -1;
  if (key === "ArrowDown")
    next = (index3 + 1) % options.length;
  if (key === "ArrowUp")
    next = (~index3 ? index3 : options.length) - 1;
  if (~index3) {
    if (key === "Home" || key === "PageUp")
      next = 0;
    if (key === "End" || key === "PageDown")
      next = options.length - 1;
    if (key === "Enter") {
      options[index3].click();
      return event.preventDefault();
    }
  }
  if (options[next])
    for (const option of options)
      option.tabIndex = -1;
  if (options[next])
    event.preventDefault();
  (_b = options[next] || self._input) == null ? void 0 : _b.focus();
  if (key === "Escape")
    setExpanded(self, false);
};
var setExpanded = (self, open) => {
  self.hidden = !open;
  if (self.popover)
    self.togglePopover(open);
  if (self._input)
    setupInput(self, self._input, open);
  if (open)
    setupOptions(self);
};
var disconnectInput = (self) => {
  off2(self._root || self, EVENTS, self);
  mutationObserver(self, false);
  setExpanded(self, false);
  self._input = null;
};
var getVisibleOptions = (self) => [...self.options].filter(
  (opt) => !opt.disabled && opt.offsetWidth && opt.offsetHeight
  // Checks disabled or visibility (since hidden attribute can be overwritten by display: block)
);
var isInteractiveOption = (option) => option instanceof HTMLOptionElement || option.getAttribute("role") === "option";
var setupInput = (self, input, open = false) => {
  attr3(input, "popovertarget", useId12(self));
  attr3(input, "aria-autocomplete", "list");
  attr3(input, "aria-controls", useId12(self));
  attr3(input, "aria-expanded", `${IS_SAFARI_MAC || open}`);
  attr3(input, "autocomplete", "off");
  attr3(input, "role", "combobox");
};
var sanitize = (str) => (str == null ? void 0 : str.toLowerCase().trim()) || "";
var setupOptions = (self, event) => {
  var _a22;
  const value = sanitize((_a22 = self._input) == null ? void 0 : _a22.value);
  const hasChange = (event == null ? void 0 : event.type) === "mutation" || self._value !== value;
  if (!hasChange)
    return;
  const hidden = self.hidden;
  const isSingle = attr3(self, SAFE_MULTISELECTABLE) !== "true";
  const isTyping = event instanceof InputEvent && !isDatalistClick(event);
  self.hidden = true;
  self._value = value;
  for (const opt of self.options) {
    const content = [opt.value, opt.label, opt.text].map(sanitize);
    opt.hidden = !content.some((str) => str.includes(value));
    if (isSingle && isTyping && isInteractiveOption(opt))
      opt.selected = content.includes(value);
  }
  self.hidden = hidden;
  const visible = getVisibleOptions(self);
  clearTimeout(LIVE_TIMER);
  LIVE_TIMER = setTimeout(() => {
    const { length } = visible.filter(isInteractiveOption);
    const liveSrFix = ++LIVE_SR_FIX % 2 ? "Â " : "";
    const countText = `${`${self._texts[length === 1 ? "singular" : "plural"]}`.replace("%d", `${length}`)}`;
    if (LIVE)
      LIVE.textContent = `${!length && self.innerText.trim() || countText}${liveSrFix}`;
  }, 1e3);
  if (IS_IOS)
    visible.map((opt, index3, length) => {
      opt.title = `${index3 + 1}/${length}`;
    });
};
if (IS_BROWSER2)
  Object.defineProperty(HTMLInputElement.prototype, "list", {
    configurable: true,
    enumerable: true,
    get() {
      return getRoot2(this).getElementById(attr3(this, "list") || "");
    }
  });
customElements2.define("u-datalist", UHTMLDataListElement);
var SPLIT_CHAR = "â€".repeat(100);
var SPLIT_ATTR = IS_FIREFOX ? "label" : "value";
var FIREFOX_OPTION_CLICK = "insertReplacementText";
var getDatalistValue = ({
  value
}) => value.split(SPLIT_CHAR)[0];
function isDatalistClick(event) {
  var _a22;
  const isClick = event instanceof Event && event.type === "input" && event.target instanceof HTMLInputElement && (!event.inputType || event.inputType === FIREFOX_OPTION_CLICK);
  if (isClick) {
    const value = event.target.value;
    const ignored = Array.from(((_a22 = event.target.list) == null ? void 0 : _a22.options) || []).some(
      (opt) => opt.value === value && !isInteractiveOption(opt)
    );
    event.target.value = value.split(SPLIT_CHAR)[ignored ? 1 : 0];
  }
  return isClick;
}
function syncDatalistState(input) {
  var _a22;
  for (const option of ((_a22 = input.list) == null ? void 0 : _a22.children) || [])
    if (option instanceof HTMLOptionElement || option instanceof UHTMLOptionElement) {
      option[SPLIT_ATTR] = `${getDatalistValue(option)}${SPLIT_CHAR}${input.value}`;
    }
}

// node_modules/@digdir/designsystemet-react/dist/esm/components/Suggestion/Suggestion.js
var import_react126 = __toESM(require_react(), 1);
var SuggestionContext = (0, import_react126.createContext)({});
var Suggestion = (0, import_react126.forwardRef)(function Suggestion2({ className, filter = true, asChild, ...rest }, ref) {
  const Component = asChild ? Slot : "div";
  const [listId, setListId] = (0, import_react126.useState)((0, import_react126.useId)());
  const inputRef = (0, import_react126.useRef)(null);
  const handleFilter = (0, import_react126.useCallback)((input) => {
    const list = input == null ? void 0 : input.list;
    if (filter === true || !list)
      return;
    console.log(list);
    if (filter !== false) {
      let index3 = 0;
      for (const option of list.getElementsByTagName("u-option")) {
        if (!option.hasAttribute("data-empty"))
          option.disabled = !filter({
            index: index3++,
            // Increment index for each <option>
            input,
            optionElement: option,
            text: option.text,
            value: getDatalistValue(option)
          });
      }
    }
    syncDatalistState(input);
  }, [filter]);
  return (0, import_jsx_runtime101.jsx)(SuggestionContext.Provider, { value: { inputRef, listId, setListId, handleFilter }, children: (0, import_jsx_runtime101.jsx)(Component, { className: lite_default("ds-suggestion", className), ref, ...rest }) });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Suggestion/SuggestionClear.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react127 = __toESM(require_react(), 1);
var SuggestionClear = (0, import_react127.forwardRef)(function SuggestionClear2({ "aria-label": label2 = "TÃ¸m", onClick: onClick3, ...rest }, ref) {
  const { inputRef } = (0, import_react127.useContext)(SuggestionContext);
  const handleClear = (event) => {
    if (!(inputRef == null ? void 0 : inputRef.current))
      throw new Error("Input is missing");
    if (!((inputRef == null ? void 0 : inputRef.current) instanceof HTMLInputElement))
      throw new Error("Input is not an input element");
    event.preventDefault();
    setReactInputValue2(inputRef.current, "");
    inputRef.current.focus();
    onClick3 == null ? void 0 : onClick3(event);
  };
  return (0, import_jsx_runtime102.jsx)(Button, { ref, variant: "tertiary", type: "reset", "aria-label": label2, onClick: handleClear, icon: true, ...rest });
});
var setReactInputValue2 = (input, value) => {
  var _a4;
  const nativeInputValueSetter = (_a4 = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value")) == null ? void 0 : _a4.set;
  if (nativeInputValueSetter) {
    nativeInputValueSetter.call(input, value);
  } else {
    throw new Error("Unable to find the native input value setter");
  }
  const inputEvent = new Event("input", { bubbles: true });
  const changeEvent = new Event("change", { bubbles: true });
  input.dispatchEvent(inputEvent);
  input.dispatchEvent(changeEvent);
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/Suggestion/SuggestionEmpty.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var import_react128 = __toESM(require_react(), 1);
var SuggestionEmpty = (0, import_react128.forwardRef)(function SuggestionEmpty2(rest, ref) {
  return (
    // biome-ignore lint/a11y/noInteractiveElementToNoninteractiveRole: Empty option shoult not be interactive
    (0, import_jsx_runtime103.jsx)("u-option", { "data-empty": true, role: "none", ref, ...rest })
  );
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Suggestion/SuggestionInput.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_react130 = __toESM(require_react(), 1);
var SuggestionInput = (0, import_react130.forwardRef)(function SuggestionList({ value, onInput, ...rest }, ref) {
  const { listId, inputRef, handleFilter } = (0, import_react130.useContext)(SuggestionContext);
  const mergedRefs = useMergeRefs([inputRef, ref]);
  const updateSelected = (0, import_react130.useCallback)(() => {
    const { list, value: value2 } = (inputRef == null ? void 0 : inputRef.current) || {};
    for (const option of (list == null ? void 0 : list.options) || []) {
      option.selected = getDatalistValue(option) === value2;
    }
  }, []);
  (0, import_react130.useEffect)(() => {
    updateSelected();
    handleFilter == null ? void 0 : handleFilter(inputRef == null ? void 0 : inputRef.current);
  }, [value]);
  return (0, import_jsx_runtime104.jsx)(Input, {
    ref: mergedRefs,
    list: listId,
    value,
    onInput: (event) => {
      onInput == null ? void 0 : onInput(event);
      updateSelected();
      if (!isDatalistClick(event.nativeEvent))
        handleFilter == null ? void 0 : handleFilter(inputRef == null ? void 0 : inputRef.current);
    },
    placeholder: "",
    ...rest
  });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Suggestion/SuggestionList.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var import_react131 = __toESM(require_react(), 1);
var SuggestionList2 = (0, import_react131.forwardRef)(function SuggestionList3({ singular = "%d forslag", plural = "%d forslag", className, id: id3, ...rest }, ref) {
  const { inputRef, listId, setListId, handleFilter } = (0, import_react131.useContext)(SuggestionContext);
  (0, import_react131.useEffect)(() => handleFilter == null ? void 0 : handleFilter(inputRef == null ? void 0 : inputRef.current));
  (0, import_react131.useEffect)(() => {
    if (id3 && listId !== id3)
      setListId == null ? void 0 : setListId(id3);
  }, [listId, id3, setListId]);
  return (0, import_jsx_runtime105.jsx)("u-datalist", { "data-sr-singular": singular, "data-sr-plural": plural, class: className, id: listId, ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Suggestion/SuggestionOption.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var import_react132 = __toESM(require_react(), 1);
var SuggestionOption = (0, import_react132.forwardRef)(function SuggestionOption2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime106.jsx)("u-option", { class: className, ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/Suggestion/index.js
var EXPERIMENTAL_Suggestion = Object.assign(Suggestion, {
  List: SuggestionList2,
  Input: SuggestionInput,
  Empty: SuggestionEmpty,
  Option: SuggestionOption,
  Clear: SuggestionClear
});
EXPERIMENTAL_Suggestion.displayName = "EXPERIMENTAL_Suggestion";
EXPERIMENTAL_Suggestion.List.displayName = "EXPERIMENTAL_Suggestion.List";
EXPERIMENTAL_Suggestion.Input.displayName = "EXPERIMENTAL_Suggestion.Input";
EXPERIMENTAL_Suggestion.Empty.displayName = "EXPERIMENTAL_Suggestion.Empty";
EXPERIMENTAL_Suggestion.Option.displayName = "EXPERIMENTAL_Suggestion.Option";
EXPERIMENTAL_Suggestion.Clear.displayName = "EXPERIMENTAL_Suggestion.Clear";

// node_modules/@digdir/designsystemet-react/dist/esm/components/MultiSuggestion/MultiSuggestion.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var import_react133 = __toESM(require_react(), 1);

// node_modules/@u-elements/u-tags/dist/u-tags.js
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var IS_BROWSER3 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.navigator !== "undefined";
var IS_ANDROID2 = IS_BROWSER3 && /android/i.test(navigator.userAgent);
var IS_FIREFOX2 = IS_BROWSER3 && /firefox/i.test(navigator.userAgent);
var IS_IOS2 = IS_BROWSER3 && /iPad|iPhone|iPod/.test(navigator.userAgent);
var IS_SAFARI2 = IS_BROWSER3 && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var _a3;
var IS_MAC = IS_BROWSER3 && // @ts-expect-error Typescript has not implemented userAgentData yet https://stackoverflow.com/a/71392474
/^Mac/i.test(((_a3 = navigator.userAgentData) == null ? void 0 : _a3.platform) || navigator.platform);
var SAFE_LABELLEDBY2 = `${IS_ANDROID2 ? "data" : "aria"}-labelledby`;
var SAFE_MULTISELECTABLE2 = `${IS_SAFARI2 ? "aria" : "data"}-multiselectable`;
var DISPLAY_BLOCK3 = ":host(:not([hidden])) { display: block }";
var FOCUS_OUTLINE2 = "outline: 1px dotted; outline: 5px auto Highlight; outline: 5px auto -webkit-focus-ring-color";
var UHTMLElement3 = typeof HTMLElement === "undefined" ? class {
} : HTMLElement;
function attr4(el, name, value) {
  var _a22;
  if (value === void 0)
    return (_a22 = el.getAttribute(name)) != null ? _a22 : null;
  if (value === null)
    el.removeAttribute(name);
  else if (el.getAttribute(name) !== value)
    el.setAttribute(name, value);
  return null;
}
var events3 = (action, element, rest) => {
  for (const type of rest[0].split(",")) {
    rest[0] = type;
    Element.prototype[`${action}EventListener`].apply(element, rest);
  }
};
var on3 = (element, ...rest) => events3("add", element, rest);
var off3 = (element, ...rest) => events3("remove", element, rest);
var attachStyle2 = (element, css) => element.attachShadow({ mode: "open" }).append(
  createElement4("slot"),
  // Unnamed slot does automatically render all top element nodes
  createElement4("style", css)
);
var observers2 = /* @__PURE__ */ new WeakMap();
var mutationObserver2 = (element, options) => {
  if (options === void 0)
    return observers2.get(element);
  try {
    observers2.get(element).disconnect();
    observers2.delete(element);
  } catch (err) {
  }
  if (options) {
    const observer = new MutationObserver(
      (detail) => element.handleEvent({ type: "mutation", detail })
    );
    observer.observe(element, options);
    observers2.set(element, observer);
  }
};
var asButton2 = (event) => {
  const isClick = "key" in event && (event.key === " " || event.key === "Enter");
  if (isClick)
    event.preventDefault();
  if (isClick && event.target instanceof HTMLElement)
    event.target.click();
  return isClick;
};
var getRoot3 = (node) => {
  var _a22;
  const root = ((_a22 = node.getRootNode) == null ? void 0 : _a22.call(node)) || node.ownerDocument;
  return root instanceof Document || root instanceof ShadowRoot ? root : document;
};
var id2 = 0;
var useId14 = (el) => {
  if (!el)
    return "";
  if (!el.id)
    el.id = `:${el.nodeName.toLowerCase()}${(++id2).toString(32)}`;
  return el.id;
};
var createElement4 = (tagName, text, attrs) => {
  const el = document.createElement(tagName);
  if (text)
    el.textContent = text;
  if (attrs)
    for (const [key, val] of Object.entries(attrs))
      attr4(el, key, val);
  return el;
};
var customElements3 = {
  define: (name, instance) => !IS_BROWSER3 || window.customElements.get(name) || window.customElements.define(name, instance)
};
var createAriaLive2 = (mode) => {
  if (!IS_BROWSER3)
    return null;
  const live = createElement4("div");
  live.style.cssText = "position:fixed;overflow:hidden;width:1px;white-space:nowrap";
  attr4(live, "aria-live", mode);
  return document.body.appendChild(live);
};
function attributeTexts2(texts, prop, value) {
  if (!prop)
    return Object.keys(texts).map((key2) => `data-sr-${key2}`);
  const key = (prop == null ? void 0 : prop.startsWith("data-sr-")) && prop.slice(8);
  if (key && value && texts[key])
    texts[key] = value;
  return [];
}
var DISABLED2 = "disabled";
var SELECTED2 = "selected";
var UHTMLOptionElement2 = class extends UHTMLElement3 {
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return [DISABLED2, SELECTED2];
  }
  constructor() {
    super();
    attachStyle2(
      this,
      `${DISPLAY_BLOCK3}:host(:focus){${FOCUS_OUTLINE2}}:host{ cursor: pointer }`
    );
  }
  connectedCallback() {
    if (!IS_IOS2)
      this.tabIndex = -1;
    if (!attr4(this, "role"))
      attr4(this, "role", "option");
    this.attributeChangedCallback();
  }
  attributeChangedCallback() {
    attr4(this, "aria-disabled", `${this.disabled}`);
    attr4(this, "aria-selected", `${this.selected}`);
  }
  /** Sets or retrieves whether the option in the list box is the default item. */
  get defaultSelected() {
    return this[SELECTED2];
  }
  set defaultSelected(value) {
    this[SELECTED2] = value;
  }
  get disabled() {
    return attr4(this, DISABLED2) !== null;
  }
  set disabled(value) {
    attr4(this, DISABLED2, value ? "" : null);
  }
  /** Retrieves a reference to the form that the object is embedded in. */
  get form() {
    return this.closest("form");
  }
  /** Sets or retrieves the ordinal position of an option in a list box. */
  get index() {
    var _a22;
    const options = (_a22 = this.closest("u-datalist")) == null ? void 0 : _a22.getElementsByTagName("u-option");
    return Array.from(options || [this]).indexOf(this);
  }
  /** Sets or retrieves a value that you can use to implement your own label functionality for the object. */
  get label() {
    return attr4(this, "label") || this.text;
  }
  set label(value) {
    attr4(this, "label", value);
  }
  get selected() {
    return attr4(this, SELECTED2) !== null;
  }
  set selected(value) {
    attr4(this, SELECTED2, value ? "" : null);
  }
  /** Sets or retrieves the text string specified by the option tag. */
  get text() {
    var _a22;
    return ((_a22 = this.textContent) == null ? void 0 : _a22.trim()) || "";
  }
  set text(text) {
    this.textContent = text;
  }
  /** Sets or retrieves the value which is returned to the server when the form control is submitted. */
  get value() {
    return attr4(this, "value") || this.text;
  }
  set value(value) {
    attr4(this, "value", value);
  }
};
customElements3.define("u-option", UHTMLOptionElement2);
var IS_PRESS2 = false;
var LIVE_TIMER2;
var LIVE_SR_FIX2 = 0;
var LIVE2 = createAriaLive2("assertive");
var IS_SAFARI_MAC2 = IS_SAFARI2 && !IS_IOS2;
var EVENTS2 = "click,focusout,input,keydown,mousedown,mouseup";
var TEXTS2 = {
  singular: "%d hit",
  plural: "%d hits"
};
var UHTMLDataListElement2 = class extends UHTMLElement3 {
  constructor() {
    super();
    this._blurTimer = 0;
    this._input = null;
    this._root = null;
    this._value = "";
    this._texts = __spreadValues2({}, TEXTS2);
    attachStyle2(
      this,
      `${DISPLAY_BLOCK3}::slotted(u-option[disabled]) { display: none !important }`
      // Hide disabled options
    );
  }
  // Speed up translated texts
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return ["id", ...attributeTexts2(TEXTS2)];
  }
  connectedCallback() {
    this.hidden = true;
    this._root = getRoot3(this);
    if (LIVE2 && !LIVE2.isConnected)
      document.body.append(LIVE2);
    attr4(this, "role", "listbox");
    on3(this._root, "focusin", this);
    on3(this._root, "focus", this, true);
    setTimeout(() => this.attributeChangedCallback());
  }
  disconnectedCallback() {
    off3(this._root || this, "focus", this, true);
    off3(this._root || this, "focusin", this);
    disconnectInput2(this);
    this._root = null;
  }
  attributeChangedCallback(prop, _prev, next) {
    var _a22;
    attributeTexts2(this._texts, prop, next);
    const inputs = (_a22 = this._root) == null ? void 0 : _a22.querySelectorAll(`input[list="${this.id}"]`);
    for (const input of inputs || [])
      setupInput2(this, input);
  }
  handleEvent(event) {
    const { type } = event;
    if (event.defaultPrevented)
      return;
    if (type === "click")
      onClick2(this, event);
    if (type === "focus" || type === "focusin")
      onFocusIn2(this, event);
    if (type === "focusout")
      onFocusOut2(this);
    if (type === "keydown")
      onKeyDown2(this, event);
    if (type === "mutation" || type === "input")
      setupOptions2(this, event);
    if (type === "mouseup")
      IS_PRESS2 = false;
    if (type === "mousedown")
      IS_PRESS2 = this.contains(event.target);
  }
  get options() {
    return this.getElementsByTagName("u-option");
  }
};
var onFocusIn2 = (self, { target }) => {
  var _a22;
  const isInput3 = self._input === target;
  const isInside = isInput3 || self.contains(target);
  if (isInside)
    return clearTimeout(self._blurTimer);
  if (!isInput3 && target instanceof HTMLInputElement && attr4(target, "list") === self.id) {
    if (self._input)
      disconnectInput2(self);
    self._input = target;
    attr4(self, SAFE_LABELLEDBY2, useId14((_a22 = self._input.labels) == null ? void 0 : _a22[0]));
    on3(self._root || self, EVENTS2, self);
    mutationObserver2(self, {
      attributeFilter: ["value"],
      // Listen for value changes to show u-options
      attributes: true,
      childList: true,
      subtree: true
    });
    setExpanded2(self, true);
  }
};
var onFocusOut2 = (self) => {
  if (!IS_PRESS2)
    self._blurTimer = setTimeout(() => disconnectInput2(self));
};
var onClick2 = (self, { target }) => {
  var _a22, _b, _c, _d, _e;
  const isSingle = attr4(self, SAFE_MULTISELECTABLE2) !== "true";
  const option = [...self.options].find((opt) => opt.contains(target));
  if (self._input === target) {
    setExpanded2(self, true);
  } else if (option && isInteractiveOption2(option)) {
    for (const opt of self.options) {
      if (opt === option)
        opt.selected = true;
      else if (isSingle)
        opt.selected = false;
    }
    (_b = (_a22 = Object.getOwnPropertyDescriptor(
      HTMLInputElement.prototype,
      "value"
    )) == null ? void 0 : _a22.set) == null ? void 0 : _b.call(self._input, option.value);
    if (isSingle) {
      (_c = self._input) == null ? void 0 : _c.focus();
      setExpanded2(self, false);
    }
    (_d = self._input) == null ? void 0 : _d.dispatchEvent(
      new Event("input", { bubbles: true, composed: true })
    );
    (_e = self._input) == null ? void 0 : _e.dispatchEvent(new Event("change", { bubbles: true }));
  }
};
var onKeyDown2 = (self, event) => {
  var _a22, _b;
  if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey)
    return;
  if (event.key !== "Escape")
    setExpanded2(self, true);
  const { key } = event;
  const active = (_a22 = self._root) == null ? void 0 : _a22.activeElement;
  const options = getVisibleOptions2(self);
  const index3 = options.indexOf(active);
  let next = -1;
  if (key === "ArrowDown")
    next = (index3 + 1) % options.length;
  if (key === "ArrowUp")
    next = (~index3 ? index3 : options.length) - 1;
  if (~index3) {
    if (key === "Home" || key === "PageUp")
      next = 0;
    if (key === "End" || key === "PageDown")
      next = options.length - 1;
    if (key === "Enter") {
      options[index3].click();
      return event.preventDefault();
    }
  }
  if (options[next])
    for (const option of options)
      option.tabIndex = -1;
  if (options[next])
    event.preventDefault();
  (_b = options[next] || self._input) == null ? void 0 : _b.focus();
  if (key === "Escape")
    setExpanded2(self, false);
};
var setExpanded2 = (self, open) => {
  self.hidden = !open;
  if (self.popover)
    self.togglePopover(open);
  if (self._input)
    setupInput2(self, self._input, open);
  if (open)
    setupOptions2(self);
};
var disconnectInput2 = (self) => {
  off3(self._root || self, EVENTS2, self);
  mutationObserver2(self, false);
  setExpanded2(self, false);
  self._input = null;
};
var getVisibleOptions2 = (self) => [...self.options].filter(
  (opt) => !opt.disabled && opt.offsetWidth && opt.offsetHeight
  // Checks disabled or visibility (since hidden attribute can be overwritten by display: block)
);
var isInteractiveOption2 = (option) => option instanceof HTMLOptionElement || option.getAttribute("role") === "option";
var setupInput2 = (self, input, open = false) => {
  attr4(input, "popovertarget", useId14(self));
  attr4(input, "aria-autocomplete", "list");
  attr4(input, "aria-controls", useId14(self));
  attr4(input, "aria-expanded", `${IS_SAFARI_MAC2 || open}`);
  attr4(input, "autocomplete", "off");
  attr4(input, "role", "combobox");
};
var sanitize2 = (str) => (str == null ? void 0 : str.toLowerCase().trim()) || "";
var setupOptions2 = (self, event) => {
  var _a22;
  const value = sanitize2((_a22 = self._input) == null ? void 0 : _a22.value);
  const hasChange = (event == null ? void 0 : event.type) === "mutation" || self._value !== value;
  if (!hasChange)
    return;
  const hidden = self.hidden;
  const isSingle = attr4(self, SAFE_MULTISELECTABLE2) !== "true";
  const isTyping = event instanceof InputEvent && !isDatalistClick2(event);
  self.hidden = true;
  self._value = value;
  for (const opt of self.options) {
    const content = [opt.value, opt.label, opt.text].map(sanitize2);
    opt.hidden = !content.some((str) => str.includes(value));
    if (isSingle && isTyping && isInteractiveOption2(opt))
      opt.selected = content.includes(value);
  }
  self.hidden = hidden;
  const visible = getVisibleOptions2(self);
  clearTimeout(LIVE_TIMER2);
  LIVE_TIMER2 = setTimeout(() => {
    const { length } = visible.filter(isInteractiveOption2);
    const liveSrFix = ++LIVE_SR_FIX2 % 2 ? "Â " : "";
    const countText = `${`${self._texts[length === 1 ? "singular" : "plural"]}`.replace("%d", `${length}`)}`;
    if (LIVE2)
      LIVE2.textContent = `${!length && self.innerText.trim() || countText}${liveSrFix}`;
  }, 1e3);
  if (IS_IOS2)
    visible.map((opt, index3, length) => {
      opt.title = `${index3 + 1}/${length}`;
    });
};
if (IS_BROWSER3)
  Object.defineProperty(HTMLInputElement.prototype, "list", {
    configurable: true,
    enumerable: true,
    get() {
      return getRoot3(this).getElementById(attr4(this, "list") || "");
    }
  });
customElements3.define("u-datalist", UHTMLDataListElement2);
var SPLIT_CHAR2 = "â€".repeat(100);
var FIREFOX_OPTION_CLICK2 = "insertReplacementText";
var getDatalistValue2 = ({
  value
}) => value.split(SPLIT_CHAR2)[0];
function isDatalistClick2(event) {
  var _a22;
  const isClick = event instanceof Event && event.type === "input" && event.target instanceof HTMLInputElement && (!event.inputType || event.inputType === FIREFOX_OPTION_CLICK2);
  if (isClick) {
    const value = event.target.value;
    const ignored = Array.from(((_a22 = event.target.list) == null ? void 0 : _a22.options) || []).some(
      (opt) => opt.value === value && !isInteractiveOption2(opt)
    );
    event.target.value = value.split(SPLIT_CHAR2)[ignored ? 1 : 0];
  }
  return isClick;
}
var IS_MOBILE = IS_ANDROID2 || IS_IOS2;
var IS_FIREFOX_MAC = IS_FIREFOX2 || IS_MAC;
var LIVE22 = createAriaLive2("polite");
var EVENTS22 = "input,focusin,focusout,keydown";
var TEXTS22 = {
  added: "Added",
  remove: "Press to remove",
  removed: "Removed",
  empty: "No selected",
  found: "Navigate left to find %d selected",
  of: "of"
};
var UHTMLTagsElement = class extends UHTMLElement3 {
  constructor() {
    super();
    this._blurAnnounceReset = false;
    this._blurTimer = 0;
    this._focusIndex = null;
    this._root = null;
    this._texts = __spreadValues2({}, TEXTS22);
    this.attachShadow({ mode: "open" }).append(
      createElement4("slot"),
      // Content slot
      createElement4(
        "style",
        `:host(:not([hidden])){ display: inline-block }
        ::slotted(data) { cursor: pointer; display: inline-block; outline: none; pointer-events: none }
        ::slotted(data)::after { content: '\\00D7'; content: '\\00D7' / ''; padding-inline: .5ch; pointer-events: auto }
        ::slotted(data:focus)::after { ${FOCUS_OUTLINE2} }`
        // Show focus outline around ::after only
      )
    );
  }
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return attributeTexts2(TEXTS22);
  }
  connectedCallback() {
    this._root = getRoot3(this);
    if (LIVE22 && !LIVE22.isConnected)
      document.body.append(LIVE22);
    mutationObserver2(this, { childList: true });
    on3(this._root, "click", this);
    on3(this, EVENTS22, this);
    setTimeout(() => render2(this));
  }
  attributeChangedCallback(prop, _prev, next) {
    attributeTexts2(this._texts, prop, next);
  }
  disconnectedCallback() {
    mutationObserver2(this, false);
    off3(this._root || this, "click", this);
    off3(this, EVENTS22, this);
    this._root = null;
  }
  handleEvent(event) {
    if (event.defaultPrevented)
      return;
    if (event.type === "click")
      onClick22(this, event);
    if (event.type === "focusin")
      onFocusIn22(this, event);
    if (event.type === "focusout")
      onFocusOut22(this);
    if (event.type === "input")
      onInputOptionClick(this, event);
    if (event.type === "keydown")
      onKeyDown22(this, event);
    if (event.type === "mutation")
      render2(this, event);
  }
  get items() {
    return this.querySelectorAll("data");
  }
  get control() {
    return this.querySelector("input");
  }
};
var dispatchChange = (self, item) => {
  return self.dispatchEvent(
    new CustomEvent("tags", {
      bubbles: true,
      cancelable: true,
      detail: { item, action: item.isConnected ? "remove" : "add" }
    })
  );
};
var render2 = (self, event) => {
  var _a22, _b, _c, _d, _e;
  const texts = self._texts;
  const change = Number.isNaN(self._focusIndex) ? null : event == null ? void 0 : event.detail[0];
  const changeItem = (change == null ? void 0 : change.addedNodes[0]) || (change == null ? void 0 : change.removedNodes[0]);
  const changeText = `${changeItem ? `${changeItem.isConnected ? texts.added : texts.removed} ${changeItem.textContent}, ` : ""}`;
  const label2 = ((_c = (_b = (_a22 = self.control) == null ? void 0 : _a22.labels) == null ? void 0 : _b[0]) == null ? void 0 : _c.textContent) || "";
  const values = [];
  attr4(self, "role", "group");
  attr4(self, "aria-label", label2);
  self.items.forEach((item, index3, { length }) => {
    var _a32;
    const label22 = `${changeText}${item.textContent}, ${texts.remove}, ${index3 + 1} ${texts.of} ${length}`;
    attr4(item, "aria-label", label22);
    attr4(item, "role", "button");
    item.tabIndex = -1;
    item.value = item.value || ((_a32 = item.textContent) == null ? void 0 : _a32.trim()) || "";
    values.push(item.value);
  });
  const control = self.control;
  const controlLabel = `${changeText}${label2}, ${values.length ? texts.found.replace("%d", `${values.length}`) : texts.empty}`;
  const list = control && document.getElementById(attr4(control, "list") || "");
  const options = list == null ? void 0 : list.children;
  if (control)
    attr4(control, "aria-label", controlLabel);
  if (list)
    attr4(list, SAFE_MULTISELECTABLE2, "true");
  for (const option of options || [])
    option.selected = values.includes(getDatalistValue2(option));
  if (changeText) {
    const nextFocus = self.items[(self._focusIndex || 1) - 1] || control;
    const sameFocus = nextFocus === ((_d = getRoot3(self)) == null ? void 0 : _d.activeElement);
    const tmpFocus = options || self.items;
    self._blurAnnounceReset = false;
    if (nextFocus === control) {
      if (sameFocus) {
        if (IS_MOBILE && LIVE22)
          LIVE22.textContent = changeText;
        else
          (_e = tmpFocus[0]) == null ? void 0 : _e.focus();
      }
      setTimeout(() => nextFocus == null ? void 0 : nextFocus.focus(), 100);
    } else
      nextFocus == null ? void 0 : nextFocus.focus();
    setTimeout(() => {
      if (!IS_FIREFOX_MAC)
        return render2(self);
      self._blurAnnounceReset = true;
    }, 500);
  }
};
var onFocusIn22 = (self, { target }) => {
  clearTimeout(self._blurTimer);
  self._focusIndex = [...self.items].indexOf(target);
};
var onFocusOut22 = (self) => {
  if (self._blurAnnounceReset)
    render2(self);
  self._blurTimer = setTimeout(() => {
    self._focusIndex = null;
  });
};
var onClick22 = (self, { target, clientX: x, clientY: y }) => {
  var _a22;
  const items = self.contains(target) ? [...self.items] : null;
  const itemRemove = items == null ? void 0 : items.find((item) => item.contains(target));
  const itemClicked = items == null ? void 0 : items.find((item) => {
    const { top, right, bottom, left } = item.getBoundingClientRect();
    return y >= top && y <= bottom && x >= left && x <= right;
  });
  if (itemRemove)
    dispatchChange(self, itemRemove) && itemRemove.remove();
  else if (itemClicked)
    itemClicked.focus();
  else if (target === self)
    (_a22 = self.control) == null ? void 0 : _a22.focus();
};
var onInputOptionClick = (self, event) => {
  var _a22;
  const input = event.target;
  if (!isDatalistClick2(event) || !(input == null ? void 0 : input.value.trim()))
    return;
  const value = getDatalistValue2(input);
  const items = [...self.items];
  const options = [...((_a22 = input == null ? void 0 : input.list) == null ? void 0 : _a22.children) || []];
  const optionClicked = options.find((opt) => getDatalistValue2(opt) === value);
  const itemRemove = items.find((item) => item.value === value);
  const itemAdd = createElement4("data", (optionClicked == null ? void 0 : optionClicked.text) || value, {
    value
  });
  input.value = "";
  if (!dispatchChange(self, itemRemove || itemAdd))
    return;
  if (itemRemove)
    return itemRemove.remove();
  if (!items[0])
    return self.prepend(itemAdd);
  items[items.length - 1].insertAdjacentElement("afterend", itemAdd);
};
var onKeyDown22 = (self, event) => {
  var _a22, _b;
  const { key, repeat, target } = event;
  const input = self.control === target ? self.control : null;
  const isCaretInside = input == null ? void 0 : input.selectionEnd;
  let index3 = input ? self.items.length : (_a22 = self._focusIndex) != null ? _a22 : -1;
  if (index3 === -1 || !input && asButton2(event))
    return;
  if (key === "ArrowRight" && !input)
    index3 += 1;
  else if (key === "ArrowLeft" && !isCaretInside)
    index3 -= 1;
  else if (key === "Enter" && input) {
    event.preventDefault();
    return input.dispatchEvent(new Event("input", { bubbles: true }));
  } else if ((key === "Backspace" || key === "Delete") && !isCaretInside) {
    const remove = !repeat && self.items[index3];
    event.preventDefault();
    if (remove)
      return dispatchChange(self, remove) && remove.remove();
    if (input)
      index3 -= 1;
  } else
    return;
  event.preventDefault();
  (_b = self.items[Math.max(0, index3)] || self.control) == null ? void 0 : _b.focus();
};
customElements3.define("u-tags", UHTMLTagsElement);

// node_modules/@digdir/designsystemet-react/dist/esm/components/MultiSuggestion/MultiSuggestion.js
var MultiSuggestionContext = (0, import_react133.createContext)({});
var MultiSuggestion = (0, import_react133.forwardRef)(function MultiSuggestion2({ value, defaultValue, onValueChange, name, filter = true, allowCreate = false, className, ...rest }, ref) {
  const [listId, setListId] = (0, import_react133.useState)((0, import_react133.useId)());
  const [selectedItems, setSelectedItems] = (0, import_react133.useState)({});
  const inputRef = (0, import_react133.useRef)(null);
  const uTagsRef = (0, import_react133.useRef)(null);
  const mergedRefs = useMergeRefs([ref, uTagsRef]);
  const isControlled = Boolean(value);
  const [controlledDirty, setControlledDirty] = (0, import_react133.useState)(false);
  (0, import_react133.useEffect)(() => {
    var _a4, _b;
    if (!defaultValue)
      return;
    if (value) {
      console.warn("defaultValue can not be used in combination with value");
      return;
    }
    const items = (_a4 = uTagsRef.current) == null ? void 0 : _a4.querySelectorAll("u-option");
    if (!items)
      return;
    const defaultItems = Array.from(items).filter((item) => defaultValue.includes(item.value));
    for (const item of defaultItems) {
      (_b = uTagsRef.current) == null ? void 0 : _b.dispatchEvent(new CustomEvent("add", {
        detail: { item }
      }));
      setSelectedItems((prevItems) => ({
        ...prevItems,
        [item.value]: item
      }));
    }
    return () => {
      console.error("Default value changed during render");
    };
  }, [defaultValue]);
  (0, import_react133.useEffect)(() => {
    var _a4, _b, _c, _d;
    if (!value)
      return;
    const items = (_b = (_a4 = inputRef.current) == null ? void 0 : _a4.list) == null ? void 0 : _b.options;
    if (!items)
      return;
    const itemsArray = Array.from(items);
    const itemsArrayValues = itemsArray.map((item) => item.value);
    const selectedArray = Object.keys(selectedItems);
    const validValues = value.filter((val) => itemsArrayValues.includes(val));
    const itemsToAdd = validValues.filter((val) => !selectedArray.includes(val));
    const itemsToRemove = selectedArray.filter((val) => !validValues.includes(val));
    for (const item of itemsArray) {
      if (itemsToAdd.includes(item.value)) {
        (_c = uTagsRef.current) == null ? void 0 : _c.dispatchEvent(new CustomEvent("add", {
          detail: { item }
        }));
        setSelectedItems((prevItems) => ({
          ...prevItems,
          [item.value]: item
        }));
      }
      if (itemsToRemove.includes(item.value)) {
        (_d = uTagsRef.current) == null ? void 0 : _d.dispatchEvent(new CustomEvent("remove", {
          detail: { item }
        }));
        setSelectedItems((prevItems) => {
          const { [item.value]: _, ...rest2 } = prevItems;
          return rest2;
        });
      }
    }
  }, [value]);
  (0, import_react133.useEffect)(() => {
    if (!(uTagsRef == null ? void 0 : uTagsRef.current))
      return;
    const handleItemsChange = (e) => {
      var _a4, _b;
      e.preventDefault();
      const item = e.detail.item;
      if (e.detail.action === "add") {
        if (!allowCreate) {
          const optionExists = Array.from(((_b = (_a4 = inputRef.current) == null ? void 0 : _a4.list) == null ? void 0 : _b.options) || [], getDatalistValue).includes(item.value);
          if (!optionExists)
            return;
        }
        setSelectedItems((prevItems) => ({
          ...prevItems,
          [item.value]: item
        }));
      }
      if (e.detail.action === "remove") {
        setSelectedItems((prevItems) => {
          const { [item.value]: _, ...rest2 } = prevItems;
          return rest2;
        });
      }
      if (isControlled)
        setControlledDirty(true);
    };
    uTagsRef.current.addEventListener("tags", handleItemsChange);
    return () => {
      var _a4;
      (_a4 = uTagsRef.current) == null ? void 0 : _a4.removeEventListener("tags", handleItemsChange);
    };
  }, [uTagsRef, setSelectedItems]);
  (0, import_react133.useEffect)(() => {
    if (!controlledDirty)
      return;
    onValueChange == null ? void 0 : onValueChange(Object.keys(selectedItems));
    setControlledDirty(false);
  }, [controlledDirty]);
  const handleFilter = (0, import_react133.useCallback)((input) => {
    const list = input == null ? void 0 : input.list;
    if (filter === true || !list)
      return;
    if (filter !== false) {
      let index3 = 0;
      for (const option of list.getElementsByTagName("u-option")) {
        if (!option.hasAttribute("data-empty"))
          option.disabled = !filter({
            index: index3++,
            // Increment index for each <option>
            input,
            optionElement: option,
            text: option.text,
            value: getDatalistValue(option)
          });
      }
    }
    syncDatalistState(input);
  }, [filter]);
  return (0, import_jsx_runtime107.jsxs)(MultiSuggestionContext.Provider, { value: {
    inputRef,
    listId,
    selectedItems,
    setListId,
    handleFilter
  }, children: [(0, import_jsx_runtime107.jsx)("u-tags", { class: lite_default("ds-multi-suggestion", className), ref: mergedRefs, ...rest }), name && (0, import_jsx_runtime107.jsx)("select", { multiple: true, hidden: true, name, children: Object.values(selectedItems).map((item) => (0, import_jsx_runtime107.jsx)("option", { value: item.value }, item.value)) })] });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/MultiSuggestion/MultiSuggestionChips.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react135 = __toESM(require_react(), 1);
var MultiSuggestionChips = ({ render: render3 = ({ value }) => value }) => {
  const { selectedItems } = (0, import_react135.useContext)(MultiSuggestionContext);
  return (0, import_jsx_runtime108.jsx)(import_jsx_runtime108.Fragment, { children: selectedItems && Object.values(selectedItems).map((item) => (0, import_jsx_runtime108.jsx)(Chip.Removable, { value: item.value, asChild: true, children: (0, import_jsx_runtime108.jsx)("data", { children: render3({
    text: item.textContent || item.value,
    value: item.value,
    element: item
  }) }) }, item.value)) });
};
MultiSuggestionChips.displayName = "MultiSuggestionChips";

// node_modules/@digdir/designsystemet-react/dist/esm/components/MultiSuggestion/MultiSuggestionClear.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var import_react136 = __toESM(require_react(), 1);
var MultiSuggestionClear = (0, import_react136.forwardRef)(function MultiSuggestionClear2({ "aria-label": label2 = "TÃ¸m", onClick: onClick3, ...rest }, ref) {
  const { inputRef } = (0, import_react136.useContext)(MultiSuggestionContext);
  const handleClear = (event) => {
    if (!(inputRef == null ? void 0 : inputRef.current))
      throw new Error("Input is missing");
    if (!((inputRef == null ? void 0 : inputRef.current) instanceof HTMLInputElement))
      throw new Error("Input is not an input element");
    event.preventDefault();
    setReactInputValue3(inputRef.current, "");
    inputRef.current.focus();
    onClick3 == null ? void 0 : onClick3(event);
  };
  return (0, import_jsx_runtime109.jsx)(Button, { ref, variant: "tertiary", type: "reset", "aria-label": label2, onClick: handleClear, icon: true, ...rest });
});
var setReactInputValue3 = (input, value) => {
  var _a4;
  const nativeInputValueSetter = (_a4 = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value")) == null ? void 0 : _a4.set;
  if (nativeInputValueSetter) {
    nativeInputValueSetter.call(input, value);
  } else {
    throw new Error("Unable to find the native input value setter");
  }
  const inputEvent = new Event("input", { bubbles: true });
  const changeEvent = new Event("change", { bubbles: true });
  input.dispatchEvent(inputEvent);
  input.dispatchEvent(changeEvent);
};

// node_modules/@digdir/designsystemet-react/dist/esm/components/MultiSuggestion/MultiSuggestionEmpty.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var import_react137 = __toESM(require_react(), 1);
var MultiSuggestionEmpty = (0, import_react137.forwardRef)(function MultiSuggestionEmpty2(rest, ref) {
  return (
    // biome-ignore lint/a11y/noInteractiveElementToNoninteractiveRole: Empty option shoult not be interactive
    (0, import_jsx_runtime110.jsx)("u-option", { "data-empty": true, role: "none", ref, ...rest })
  );
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/MultiSuggestion/MultiSuggestionInput.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var import_react139 = __toESM(require_react(), 1);
var MultiSuggestionInput = (0, import_react139.forwardRef)(function MultiSuggestionList({ value, onInput, ...rest }, ref) {
  const { listId, inputRef, handleFilter } = (0, import_react139.useContext)(MultiSuggestionContext);
  const mergedRefs = useMergeRefs([inputRef, ref]);
  (0, import_react139.useEffect)(() => {
    handleFilter == null ? void 0 : handleFilter(inputRef == null ? void 0 : inputRef.current);
  }, [value]);
  return (0, import_jsx_runtime111.jsx)(Input, {
    ref: mergedRefs,
    list: listId,
    value,
    onInput: (event) => {
      onInput == null ? void 0 : onInput(event);
      if (!isDatalistClick(event.nativeEvent))
        handleFilter == null ? void 0 : handleFilter(inputRef == null ? void 0 : inputRef.current);
    },
    placeholder: "",
    ...rest
  });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/MultiSuggestion/MultiSuggestionList.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var import_react140 = __toESM(require_react(), 1);
var MultiSuggestionList2 = (0, import_react140.forwardRef)(function MultiSuggestionList3({ singular = "%d forslag", plural = "%d forslag", className, id: id3, ...rest }, ref) {
  const { inputRef, listId, setListId, handleFilter } = (0, import_react140.useContext)(MultiSuggestionContext);
  (0, import_react140.useEffect)(() => handleFilter == null ? void 0 : handleFilter(inputRef == null ? void 0 : inputRef.current));
  (0, import_react140.useEffect)(() => {
    if (id3 && listId !== id3)
      setListId == null ? void 0 : setListId(id3);
  }, [listId, id3, setListId]);
  return (0, import_jsx_runtime112.jsx)("u-datalist", { "data-sr-singular": singular, "data-sr-plural": plural, class: className, id: listId, ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/MultiSuggestion/MultiSuggestionOption.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var import_react141 = __toESM(require_react(), 1);
var MultiSuggestionOption = (0, import_react141.forwardRef)(function MultiSuggestionOption2({ className, ...rest }, ref) {
  return (0, import_jsx_runtime113.jsx)("u-option", { class: className, ref, ...rest });
});

// node_modules/@digdir/designsystemet-react/dist/esm/components/MultiSuggestion/index.js
var MultiSuggestion3 = Object.assign(MultiSuggestion, {
  Input: MultiSuggestionInput,
  List: MultiSuggestionList2,
  Option: MultiSuggestionOption,
  Chips: MultiSuggestionChips,
  Empty: MultiSuggestionEmpty,
  Clear: MultiSuggestionClear
});
MultiSuggestion3.displayName = "EXPERIMENTRAL_MultiSuggestion";
MultiSuggestion3.Input.displayName = "EXPERIMENTRAL_MultiSuggestion.Input";
MultiSuggestion3.List.displayName = "EXPERIMENTRAL_MultiSuggestion.List";
MultiSuggestion3.Option.displayName = "EXPERIMENTRAL_MultiSuggestion.Option";
MultiSuggestion3.Chips.displayName = "EXPERIMENTRAL_MultiSuggestion.Chips";
MultiSuggestion3.Empty.displayName = "EXPERIMENTRAL_MultiSuggestion.Empty";
MultiSuggestion3.Clear.displayName = "EXPERIMENTRAL_MultiSuggestion.Clear";

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/hooks/useCheckboxGroup/useCheckboxGroup.js
var import_react142 = __toESM(require_react(), 1);
var toggleIndeterminate = (getIndeterminateInputs, getInputs) => {
  const inputs = getIndeterminateInputs();
  const checked = !!getInputs(true).length;
  const unchecked = !!getInputs(false).length;
  for (const input of inputs) {
    input.indeterminate = unchecked && checked;
    input.checked = !unchecked && checked;
  }
};
function useCheckboxGroup(props) {
  const { error: error2, name: groupName, onChange, value = [], disabled, readOnly, required } = props || {};
  const [groupValue, setGroupValue] = (0, import_react142.useState)(value);
  const namedId = (0, import_react142.useId)();
  const errorId = (0, import_react142.useId)();
  const checkboxRefs = (0, import_react142.useRef)(/* @__PURE__ */ new Set());
  const indeterminateRefs = (0, import_react142.useRef)(/* @__PURE__ */ new Set());
  const inputRefs = (0, import_react142.useRef)(/* @__PURE__ */ new Map());
  const getInputs = (checked) => Array.from(checkboxRefs.current.values()).filter((input) => input.checked === checked);
  const getIndeterminateInputs = () => Array.from(indeterminateRefs.current.values());
  (0, import_react142.useEffect)(() => {
    toggleIndeterminate(getIndeterminateInputs, getInputs);
  }, [groupValue]);
  return {
    /**
     * Current value of the group.
     */
    value: groupValue,
    /**
     * Set the value of the group.
     *
     * @param value string[]
     * @returns void
     */
    setValue: setGroupValue,
    /**
     * Props to send to the `Checkbox` component.
     * Accepts value or object
     * @example
     * <Checkbox {...getCheckboxProps('value')} />
     *
     * @example allow indeterminate
     * <Checkbox {...getCheckboxProps({ value: 'all', allowIndeterminate: true })} />
     */
    getCheckboxProps: (propsOrValue) => {
      const props2 = typeof propsOrValue === "string" ? { value: propsOrValue } : propsOrValue || {};
      const { allowIndeterminate = false, ref: forwardedRef = void 0, value: value2 = "", ...rest } = props2;
      const handleRef = (element) => {
        if (element) {
          const refs = allowIndeterminate ? indeterminateRefs : checkboxRefs;
          refs.current.add(element);
          inputRefs.current.set(value2, element);
          if (getIndeterminateInputs().length) {
            toggleIndeterminate(getIndeterminateInputs, getInputs);
          }
        } else {
          const oldElement = inputRefs.current.get(value2);
          if (oldElement) {
            checkboxRefs.current.delete(oldElement);
            indeterminateRefs.current.delete(oldElement);
            inputRefs.current.delete(value2);
          }
        }
        if (forwardedRef) {
          if (typeof forwardedRef === "function") {
            forwardedRef(element);
          } else {
            forwardedRef.current = element;
          }
        }
      };
      const handleChange = () => {
        const nextGroupValue = Array.from(getInputs(true), ({ value: value3 }) => value3);
        setGroupValue(nextGroupValue);
        onChange == null ? void 0 : onChange(nextGroupValue, groupValue);
      };
      const indeterminateChange = () => {
        const element = inputRefs.current.get(value2);
        if (!element)
          return;
        const checked = !!element.checked;
        for (const input of getInputs(!checked)) {
          input.click();
        }
      };
      return {
        ...rest,
        "aria-describedby": `${error2 ? errorId : ""} ${rest["aria-describedby"] || ""}`.trim() || void 0,
        "aria-invalid": !!error2 || rest["aria-invalid"],
        checked: allowIndeterminate ? void 0 : groupValue.includes(value2),
        name: rest.name || groupName || namedId,
        onChange: (e) => {
          var _a4;
          (_a4 = rest.onChange) == null ? void 0 : _a4.call(rest, e);
          if (e.defaultPrevented)
            return;
          allowIndeterminate && indeterminateChange();
          handleChange();
        },
        ref: handleRef,
        value: value2,
        disabled: disabled || rest.disabled,
        readOnly: readOnly || rest.readOnly,
        required: required || rest.required
      };
    },
    /**
     * Props to send to the `ValidationMessage` component.
     *
     * @example
     * <ValidationMessage {...validationMessageProps} />
     */
    validationMessageProps: {
      children: error2,
      hidden: !error2,
      id: errorId
    }
  };
}

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/hooks/useMediaQuery/useMediaQuery.js
var import_react143 = __toESM(require_react(), 1);
var IS_SERVER = typeof window === "undefined";
function useMediaQuery(query, { defaultValue = false, initializeWithValue = true } = {}) {
  const getMatches = (query2) => {
    if (IS_SERVER) {
      return defaultValue;
    }
    return window.matchMedia(query2).matches;
  };
  const [matches2, setMatches] = (0, import_react143.useState)(() => {
    if (initializeWithValue) {
      return getMatches(query);
    }
    return defaultValue;
  });
  function handleChange() {
    setMatches(getMatches(query));
  }
  useIsomorphicLayoutEffect(() => {
    const matchMedia = window.matchMedia(query);
    handleChange();
    if (matchMedia.addListener) {
      matchMedia.addListener(handleChange);
    } else {
      matchMedia.addEventListener("change", handleChange);
    }
    return () => {
      if (matchMedia.removeListener) {
        matchMedia.removeListener(handleChange);
      } else {
        matchMedia.removeEventListener("change", handleChange);
      }
    };
  }, [query]);
  return matches2;
}

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/hooks/useRadioGroup/useRadioGroup.js
var import_react144 = __toESM(require_react(), 1);
function useRadioGroup({ error: error2, readOnly, required, disabled, name, onChange, value: initalValue = "" } = {}) {
  const [groupValue, setGroupValue] = (0, import_react144.useState)(initalValue);
  const errorId = (0, import_react144.useId)();
  const namedId = (0, import_react144.useId)();
  const radioGroupName = name || namedId;
  return {
    /**
     * Current value of the group.
     */
    value: groupValue,
    /**
     * Set the value of the group.
     *
     * @param value string[]
     * @returns void
     */
    setValue: setGroupValue,
    /**
     * Props to send to the `Radio` component.
     * @example
     * <Radio label="Option 1" {...getRadioProps('option-1')} />
     */
    getRadioProps: (propsOrValue) => {
      const props = typeof propsOrValue === "string" ? { value: propsOrValue } : propsOrValue;
      const { ref: forwardedRef = void 0, value = "", ...rest } = props;
      const handleRef = (element) => {
        if (element) {
          element.checked = value === groupValue;
        }
        if (forwardedRef) {
          if (typeof forwardedRef === "function") {
            forwardedRef(element);
          } else {
            forwardedRef.current = element;
          }
        }
      };
      const handleChange = (e) => {
        if (e.target.name === radioGroupName) {
          setGroupValue((prevValue) => {
            onChange == null ? void 0 : onChange(e.target.value, prevValue);
            return e.target.value;
          });
        }
      };
      return {
        ...rest,
        name: radioGroupName,
        "aria-describedby": `${error2 ? errorId : ""} ${rest["aria-describedby"] || ""}`.trim() || void 0,
        "aria-invalid": !!error2 || rest["aria-invalid"],
        value,
        ref: handleRef,
        required: required || rest.required,
        readOnly: readOnly || rest.readOnly,
        disabled: disabled || rest.disabled,
        onChange: (e) => {
          var _a4;
          (_a4 = rest.onChange) == null ? void 0 : _a4.call(rest, e);
          if (e.defaultPrevented)
            return;
          handleChange(e);
        }
      };
    },
    /**
     * Props to send to the `ValidationMessage` component.
     *
     * @example
     * <ValidationMessage {...validationMessageProps} />
     */
    validationMessageProps: {
      children: error2,
      hidden: !error2,
      id: errorId
    }
  };
}

// node_modules/@digdir/designsystemet-react/dist/esm/utilities/hooks/usePagination/usePagination.js
var import_react145 = __toESM(require_react(), 1);
var getSteps = (now, max2, show) => {
  const offset4 = (show - 1) / 2;
  const start = Math.min(Math.max(now - Math.floor(offset4), 1), max2 - show + 1);
  const end = Math.min(Math.max(now + Math.ceil(offset4), show), max2);
  const pages = Array.from({ length: end + 1 - start }, (_, i) => i + start);
  if (show > 4 && start > 1)
    pages.splice(0, 2, 1, 0);
  if (show > 3 && end < max2)
    pages.splice(-2, 2, 0, max2);
  return pages;
};
var usePagination = ({ currentPage = 1, setCurrentPage, onChange, totalPages = 1, showPages = 7 }) => (0, import_react145.useMemo)(() => {
  const hasNext = currentPage < totalPages;
  const hasPrev = currentPage !== 1;
  const handleClick = (page) => (event) => {
    if (page < 1 || page > totalPages)
      return event.preventDefault();
    onChange == null ? void 0 : onChange(event, page);
    if (!event.defaultPrevented)
      setCurrentPage == null ? void 0 : setCurrentPage(page);
  };
  return {
    /** Number of steps */
    pages: getSteps(currentPage, totalPages, showPages).map((page, index3) => ({
      /**
       * Page number or "ellipsis" for the ellipsis item
       */
      page: page || "ellipsis",
      /**
       * Unique key for the item
       */
      itemKey: page ? `page-${page}` : `ellipsis-${index3}`,
      // React key utility
      /**
       * Properties to spread on Pagination.Button
       */
      buttonProps: page ? {
        "aria-current": page === currentPage ? "page" : void 0,
        onClick: handleClick(page),
        variant: page === currentPage ? "primary" : "tertiary"
      } : null
    })),
    /** Properties to spread on Pagination.Button used for previous naviagation */
    prevButtonProps: {
      "aria-disabled": !hasPrev,
      // Using aria-disabled to support all HTML elements because of potential asChild
      onClick: handleClick(currentPage - 1),
      variant: "tertiary"
    },
    /** Properties to spread on Pagination.Button used for next naviagation */
    nextButtonProps: {
      "aria-disabled": !hasNext,
      // Using aria-disabled to support all HTML elements because of potential asChild
      onClick: handleClick(currentPage + 1),
      variant: "tertiary"
    },
    /** Indication if previous page action should be shown or not */
    hasPrev,
    /** Indication if next page action should be shown or not */
    hasNext
  };
}, [currentPage, totalPages, showPages]);
export {
  Alert,
  Avatar,
  Badge3 as Badge,
  BadgePosition,
  Breadcrumbs2 as Breadcrumbs,
  BreadcrumbsItem,
  BreadcrumbsLink,
  BreadcrumbsList,
  Button,
  Card3 as Card,
  CardBlock,
  Checkbox,
  Chip,
  ChipButton,
  ChipCheckbox,
  ChipRadio,
  ChipRemovable,
  Combobox2 as Combobox,
  ComboboxEmpty,
  ComboboxOption,
  Details3 as Details,
  DetailsContent,
  DetailsSummary,
  Dialog3 as Dialog,
  DialogBlock,
  DialogTrigger,
  DialogTriggerContext,
  Divider,
  Dropdown2 as Dropdown,
  DropdownButton,
  DropdownHeading,
  DropdownItem,
  DropdownList,
  DropdownTrigger,
  DropdownTriggerContext,
  MultiSuggestion3 as EXPERIMENTAL_MultiSuggestion,
  MultiSuggestionChips as EXPERIMENTAL_MultiSuggestionChips,
  MultiSuggestionClear as EXPERIMENTAL_MultiSuggestionClear,
  MultiSuggestionEmpty as EXPERIMENTAL_MultiSuggestionEmpty,
  MultiSuggestionInput as EXPERIMENTAL_MultiSuggestionInput,
  MultiSuggestionList2 as EXPERIMENTAL_MultiSuggestionList,
  MultiSuggestionOption as EXPERIMENTAL_MultiSuggestionOption,
  EXPERIMENTAL_Suggestion,
  SuggestionClear as EXPERIMENTAL_SuggestionClear,
  SuggestionEmpty as EXPERIMENTAL_SuggestionEmpty,
  SuggestionInput as EXPERIMENTAL_SuggestionInput,
  SuggestionList2 as EXPERIMENTAL_SuggestionList,
  SuggestionOption as EXPERIMENTAL_SuggestionOption,
  ErrorSummary3 as ErrorSummary,
  ErrorSummaryHeading,
  ErrorSummaryItem,
  ErrorSummaryLink,
  ErrorSummaryList,
  Field3 as Field,
  FieldAffix,
  FieldAffixes,
  FieldCounter,
  FieldDescription,
  Fieldset3 as Fieldset,
  FieldsetDescription,
  FieldsetLegend,
  Heading,
  Input,
  Label,
  Link,
  List,
  ListItem,
  ListOrdered,
  ListUnordered,
  Pagination3 as Pagination,
  PaginationButton,
  PaginationItem,
  PaginationList,
  Paragraph,
  Popover3 as Popover,
  PopoverTrigger,
  PopoverTriggerContext,
  Radio,
  RovingFocusItem,
  RovingFocusRoot,
  Search3 as Search,
  SearchButton,
  SearchClear,
  SearchInput,
  Select3 as Select,
  SelectOptgroup,
  SelectOption,
  Skeleton,
  SkipLink,
  Spinner,
  Switch,
  Table3 as Table,
  TableBody,
  TableCell,
  TableFoot,
  TableHead,
  TableHeaderCell,
  TableRow,
  Tabs3 as Tabs,
  TabsList,
  TabsPanel,
  TabsTab,
  Tag,
  Textarea,
  Textfield,
  ToggleGroup3 as ToggleGroup,
  ToggleGroupItem,
  Tooltip,
  ValidationMessage,
  getNextFocusableValue,
  getPrevFocusableValue,
  omit,
  useCheckboxGroup,
  useDebounceCallback,
  useIsomorphicLayoutEffect,
  useMediaQuery,
  usePagination,
  useRadioGroup,
  useRovingFocus,
  useSynchronizedAnimation
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=@digdir_designsystemet-react.js.map
